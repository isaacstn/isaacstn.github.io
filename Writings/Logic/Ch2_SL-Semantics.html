<!DOCTYPE html>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xml:lang="en-US" lang="en-US">

<head>
	<meta charset="utf-8"/>

	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/Computer-Modern/serif/cmun-serif.css"/><!--CMU Serif-->
	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/STIXGeneral/STIXGeneral.css"/><!--STIXGeneral-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/FelipaFraktur/FelipaFraktur.css"/><!--Felipa,Unifraktur-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/NotoSerifTC/NotoSerifTC.css"/><!--Noto Serif TC-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/AdobeTC/AdobeTC.css"/><!--Adobe TC-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/docstyle_v1.2.css"/><!--docstyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/jqmath-0.4.3.css"/><!--jqmath-->

	<style>
	h1::before {
		counter-increment:chapter 2;
	}
	div#main {
		counter-reset:page 24;
	}
	</style>

	<title>Ch2_SL-Semantics</title>
</head>

<body>
	<div id="main">
		<h1>語句邏輯的語意</h1>
		
		<div class="chapter">
		
			<h2>語意和真假</h2>
			
			<div class="section">
				<p>
				語句邏輯的語言是具有組合性的語言，當我們說一個語言是有組合性的時候，意思是：一、這個語言中所有複雜的表達式都是由語言中的基本元素所構成的；而且二、這個語言中所有複雜表達式的意義都是由那些基本元素的意義所決定的。
				</p>
				<p>
				由於語句邏輯中的基本元素是原子語句（也就是所有僅僅由語句符號所構成的語句），因此所有語句邏輯中的所有語句的意義，都會是由原子語句的意義所決定的。也就是說，只要確定了每一個原子語句的意義是什麼，我們就可以知道所有複雜語句（就是那些至少利用了一個語句連接詞來建構的語句）的意義是什麼。
				</p>
				<p>
				在自然語言中，語句的意義就是語句表達的實質內容，比如說：
					<ol class="lltd tight song">
						<li>南華大學在嘉義縣大林鎮。</li>
					</ol>
				這個語句表達的實質內容，就是在說有一個名叫「南華大學」的教育研究機構，這個機構的地理位置位在一個名叫「嘉義縣大林鎮」的地方。但語句邏輯中的語句其實都沒有實質的內容，因為語句邏輯中的語句只是用來表現出一個語句的形式結構而已，所以在決定語句邏輯中的語句的意義時，我們就只談它們的真或假而已。
				</p>
				<p>
				整理以上的討論：由於語句邏輯是個組合性的語言，所以語句邏輯中所有複雜表達性的意義都是由構成這些表達式的基本元素所決定的。而語句邏輯中所有語句的意義就是這些語句的真假。所以綜合起來，我們可以知道，語句邏輯中所有語句的真假，都是由構成那個語句的基本元素（也就是原子語句）的真假所決定的。換言之，只要給定了所有原子語句的真假，我們就能知道語句邏輯中所有語句的真假。
				</p>
				<p>
				舉例來說，當我們看到 '$&not;A&and;(B&or;C)$' 這個語句邏輯的語句時，我們要如何判斷它的真假呢？我們需要先知道這個語句中使用到的每一個原子語句的真假是什麼。由於我們不知道 '$A$'、'$B$'、'$C$' 這三個原子語句分別表達了什麼內容，所以無法直接知道它們分別是真還是假，所以我們就先用假設的。
				</p>
				<p>
				讓我們先假設 '$A$' 為真、'$B$' 為真、'$C$' 為假。根據前面對完構式的討論，我們知道 '$&not;A&and;(B&or;C)$' 這個語句的主要連接詞是 '$&and;$'，因此可以知道這個語句是用 '$&and;$' 來分別連接 '$&not;A$' 和 '$B&or;C$' 這兩個語句。因此為了判斷 '$&not;A&and;(B&or;C)$' 這個語句的真假，我們需要先判斷 '$&not;A$' 和 '$B&or;C$' 這兩個語句的真假。
				</p>
				<p>
				我們先來判斷 '$&not;A$' 的真假：由於 '$&not;A$' 是用來表達對 '$A$' 的否定，所以在假定了 '$A$' 為真的情況下，我們就可以知道 '$&not;A$' 是假的。接下來判斷 '$B&or;C$' 的真假：由於 '$B&or;C$' 是用來肯定 '$B$' 和 '$C$' 這兩個語句中至少有一個是真的，因此，在假定了 '$B$' 為真而 '$C$' 為假的情況下，因為 '$B$' 是真的，所以 '$B$' 和 '$C$' 這兩個語句就確實至少有一個是真的，因此 '$B&or;C$' 就是真的。
				</p>
				<p>
				在判斷完 '$&not;A$' 和 '$B&or;C$' 的真假之後，我們就可以來判斷 '$&not;A&and;(B&or;C)$' 這個語句的真假。前面已經分析過了，這個語句是用 '$&and;$' 來連接 '$&not;A$' 和 '$B&or;C$' 這兩個語句，因此這個語句是在同時肯定 '$&not;A$' 和 '$B&or;C$' 這兩個語句都為真。而根據上面的討論，我們已經知道，在假設了 '$A$' 為真、'$B$' 為真、'$C$' 為假的情況下，'$&not;A$' 是假的，而 '$B&or;C$' 是真的，因此這兩個語句並不都為真，因此 '$&not;A&and;(B&or;C)$' 就不為真，因此是假的（因為語句邏輯是二值性的語言）。
				</p>
				<p>
				上面這個例子是在假設了 '$A$' 為真、'$B$' 為真、'$C$' 為假的情況下，去判斷 '$&not;A&and;(B&or;C)$' 的真假會是什麼，然而當 '$A$'、'$B$'、'$C$' 這三個語句的真假與我們假設的情況不同時，'$&not;A&and;(B&or;C)$' 這個語句的真假就有可能會隨之改變。因為 '$&not;A&and;(B&or;C)$' 這個語句使用了三個原子語句，而三個原子語句分別都有真或假兩種可能，所以為了知道 '$&not;A&and;(B&or;C)$' 在所有不同的可能情況下分別是真還是假，我們一共會有 $2^3$ ($=8$) 種不同的情況需要討論。<span class="note"><span class="box">分別是（依 '$A$'、'$B$'、'$C$' 之真假的順序排列）：「真真真、真真假、真假真、真假假、假真真、假真假、假假真、假假假」這 $8$ 種不同的可能情況。</span></span>
				</p>
				
				<h3>真值表</h3>
				<div class="subsection">
					<p>
					為了方便判斷語句邏輯中每個語句在不同情況下的真假，邏輯學家開發出<b>真值表 (truth table)</b> 這套工具來幫助我們整理每個語句在不同的假設情況下的真假。而為了介紹真值表的用法，我將延用之前在介紹語句邏輯中的完構式時使用到的後設符號來提供協助，我一樣會用小寫的希臘字母來表示任何一個語句邏輯中的語句，然後分別用真值表來介紹當系統中的五個語句連接詞被當成語句中的主要連接詞時，那個語句在所有可能的情況下分別是真還是假。
					</p>
					<p>
					<b>否定句 (negation)</b>：當一個語句的主要連接詞是 '$&not;$' 的時候，我們稱呼這樣的語句是一個否定句，它具有 '$&not;&alpha;$' 的形式。否定句是用來否定被 '$&not;$' 這個連接詞所連接的那個語句的，因此當 '$&not;$' 所連接的語句為真時，否定句就為假；當 '$&not;$' 所連接的語句為假時，否定句就為真。故否定句 '$&not;&alpha;$' 的真值表如下：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&not;&alpha;$</td></tr>
							<tr><td>T</td><td>F</td></tr>
							<tr><td>F</td><td>T</td></tr>
						</table>
					真值表的最右邊那一欄代表的就是我們要判斷的語句的真假，而真值表左邊的欄位則表示被連接詞所連接起來的語句共有哪些真假的可能性。因為 '$&not;$' 是一元連接詞，所以它只會連接一個語句，因此我們只需要考慮它所連接的那一個語句分別為真或為假的情況，一共是 $2^1$ ($=2$) 種。
					</p>
					<p>
					當一個語句為真時，我們就填入 'T'，取「真」的英文 (true) 字首，當一個語句為假時，我們就填入 'F'，取「假」的英文 (false) 字首。因此，這個真值表的寫法意味著：當 '$&alpha;$' 為真時（第一列），'$&not;&alpha;$' 為假；當 '$&alpha;$' 為假時（第二列），'$&not;&alpha;$' 為真。
					</p>
					<p>
					<b>連言句 (conjunction)</b>：當一個語句的主要連接詞是 '$&and;$' 的時候，我們稱呼這樣的語句是一個連言句，它具有 '$&alpha;&and;&beta;$' 的形式。連言句是用來同時肯定由 '$&and;$' 這個連接詞所連接起來的兩個語句的，因此當 '$&and;$' 所連接的兩個語句皆為真時，連言句就為真；而當 '$&and;$' 所連接的兩個語句中有任何一個是假的時，連言句就為假。故連言句 '$&alpha;&and;&beta;$' 的真值表如下：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&and;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>F</td></tr>
							<tr><td>F</td><td>F</td><td>F</td></tr>
						</table>
					</p>
					<p>
					<b>選言句 (disjunction)</b>：當一個語句的主要連接詞是 '$&or;$' 的時候，我們稱呼這樣的語句是一個選言句，它具有 '$&alpha;&or;&beta;$' 的形式。選言句是用來肯定由 '$&or;$' 這個連接詞所連接起來的兩個語句中的至少一個的，因此當 '$&or;$' 所連接的兩個語句中至少有一個為真時，選言句就為真；當 '$&or;$' 所連接的兩個語句皆為假時，選言句就為假。故選言句 '$&alpha;&or;&beta;$' 的真值表如下：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&or;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>T</td></tr>
							<tr><td>F</td><td>T</td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>F</td></tr>
						</table>
					</p>
					<p>
					<b>實質條件句 (material conditional)</b>：當一個語句的主要連接詞是 '$&rarr;$' 的時候，我們稱呼這樣的語句是一個實質條件句，它具有 '$&alpha;&rarr;&beta;$' 的形式，我們將位在 '$&alpha;$' 的位置上的語句稱為<b>前件</b>，將位在 '$&beta;$' 的位置上的語句稱為<b>後件</b>。實質條件句是用來表達前件和後件之間的單向實質蘊涵關係，說 '$&alpha;$' 實質蘊涵 '$&beta;$'，意思就是<b>當 '$&alpha;$' 為真時，'$&beta;$' 不能為假。</b>因此，當前件為真而後件為假時，實質條件句就為假；而在其餘的情況下，實質條件句皆不為假，因此為真（因為語句邏輯是二值性的語言）。故實質條件句 '$&alpha;&rarr;&beta;$' 的真值表如下：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&rarr;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>T</td></tr>
						</table>
					如果大家還有印象的話，我之前在介紹 '$&rarr;$' 這個語句連接詞的時候，我說這個語句連接詞可以被翻譯成中文裡的「如果……，則……」，但從真值表的情況來看，我們不難發現兩者其實有明顯的差異。比如說考慮以下這個句子：
						<ol class="lltd song">
							<li>如果科科期中考不及格，則科科的通識邏輯會被當。</li>
						</ol>
					假如安安和科科針對這句話的真假打賭，安安賭這句話是真的，科科賭這句話是假的，結果科科的期中考及格了，試問誰才贏了這場賭局？請務必注意，科科和安安的賭局並不是針對「科科的通識邏輯會不會被當」這件事，而是針對 b 這個語句的真假。當 b 為真時安安贏，當 b 為假時則是科科贏。所以要判斷科科和安安誰贏了這場賭局，就必須判斷 b 到底是真的還是假的。
					</p>
					<p>
					假如科科的期中考確實不及格（也就是條件句的前件為真），那麼我們只要看看科科的通識邏輯會不會被當，就能知道這個條件句是真還是假了：只要科科的通識邏輯確實因此被當了，就表示條件句為真，安安贏了賭局；只要科科的通識邏輯沒有被當，就表示條件句是假的，科科贏了賭局。
					</p>
					<p>
					然而現在科科的期中考及格了（也就是條件句的前件為假），那麼不管科科的通識邏輯是否被當了，我們都無從得知那和科科的期中考不及格到底有沒有任何關係，因此我們無法知道 b 到底是不是真的，也就無法判斷科科和安安到底誰能贏得賭局。換言之，當我們在自然語言中使用條件句時，如果前件為假時，我們多半是無法得知條件句本身的真假的。
					</p>
					<p>
					但語句邏輯中的實質條件句卻不一樣，根據上述的真值表，我們發現，只要一個實質條件句的前件為假時，那麼無論後件的真假如何，整個條件句都是真的。也就是說，如果把 b 看成是一個語句邏輯中的實質條件句，那麼只要我們確定了前件為假（也就是科科的期中考及格了），我們就能輕易知道 b 是真的。因此，語句邏輯中的實值條件句，和自然語言中的條件句，其實意思明顯不相同，不能混為一談。
					</p>
					<p>
					接下來我們要看的是最後一個語句連接詞 '$&harr;$' 作為主要連接詞時所形成的句型：
					</p>
					<p>
					<b>實質雙條件句 (material biconditional)</b>：當一個語句的主要連接詞是 '$&harr;$' 的時候，我們稱呼這樣的語句是一個實質雙條件句，它具有 '$&alpha;&harr;&beta;$' 的形式，我們一樣將位在 '$&alpha;$' 位置上的語句稱為<b>前件</b>，將位在 '$&beta;$' 位置上的語句稱為<b>後件</b>。實質雙條件句是用來表達前件和後件之間的雙向實質蘊涵關係，即 '$&alpha;$' 和 '$&beta;$' 實質蘊涵彼此，也就是說，<b>當 '$&alpha;$' 為真時，'$&beta;$' 不能為假，而且，當 '$&beta;$' 為真時，'$&alpha;$' 也不能為假。</b>因此，當前件為真而後件為假，或者當前件為假而後件為真時，實質雙條件句就為假；而在其餘的情況下，實質雙條件句皆不為假，因此為真（因為語句邏輯是二值性的語言）。故實質雙條件句 '$&alpha;&harr;&beta;$' 的真值表如下：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&harr;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>F</td></tr>
							<tr><td>F</td><td>F</td><td>T</td></tr>
						</table>
					由於實質雙條件句是在條件句的前、後件同真或同假時為真，在前、後件的真假不同時為假，所以我們也把實質雙條件句所表達的雙向實質蘊涵關係稱為<b>實質等值 (material equivalence)</b>。之所以說「等值」，正是取<b>當雙條件句為真時，前、後件的真值會相等</b>之意。
					</p>
					<p>
					一樣要注意的是，由於實質雙條件句其實就是兩個實質條件句的縮寫，每個實質雙條件句 '$&alpha;&harr;&beta;$' 都可以被分解成 '$&alpha;&rarr;&beta;$' 和 '$&beta;&rarr;&alpha;$' 這樣的兩個實質條件句的連言，因此既然實質條件句的意思和自然語言中的條件句的意思有明顯的不同而不能混為一談，實質雙條件句和自然語言中的雙條件句當然也不相同。
					</p>
				</div>
				
				<h3>真值表的使用方式</h3>
				
				<div class="subsection">
					<p>
					給定上述五個真值表，我們就能判斷任何語句邏輯中的完構式在不同的可能情況下的真假。比如我們在本章一開始示範的那個語句 '$&not;A&and;(B&or;C)$'，我說因為這個語句用到了三個原子語句，所以一共有 $8$ 種不同的情況需要考慮，現在有了真值表，我們就能有系統地判斷出這個語句在所有可能的情況下的真假為何。首先，我們將三個原子語句寫在真值表的最左邊三欄，將語句本身寫在最右邊那一欄，因為可能的情況一共有 $8$ 種，所以在底下畫出八列：
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$&not;A&and;(B&or;C)$</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
						</table>
					接著，我們先將所有原子語句之真假的不同情況填進去最左邊的三欄：<span class="note"><span class="box">這裡提供一個可以把所有不同排列組合都列出來，既不會重複、也不會遺漏的方法：一、先看語句中用了幾個不同的原子語句，並根據不同原子語句的數量計算出總共有多少不同排列組合的可能性（用了 $n$ 個不同的原子語句，就會有總共 $2^n$ 種不同的可能性需要列出）；二、在列第一個原子語句的真假時，以一格 <b>T</b>、一格 <b>F</b> 的方式交錯填滿欄位；在列第二個原子語句的真假時，則以二格 <b>T</b>、兩格 <b>F</b> 的方式交錯填滿欄位；在列第三個原子語句的真假時，以四格 <b>T</b>、四格 <b>F</b> 的方式交錯填滿欄位……，以此類推，直到所有原子語句的真假都被填完了為止。</span></span>
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$&not;A&and;(B&or;C)$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td></tr>
						</table>
					接著，我們要找出我們想要判斷其真假的語句的主要連接詞，並將它標示出來：
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$&not;A$</td><td class="mainc">$&and;$</td><td>$(B&or;C)$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
						</table>
						主要連接詞所在的那一欄，就代表著 '$&not;A&and;(B&or;C)$' 這個語句的真假，而為了要判斷這一欄在每一列（也就是每一種可能的情況下）分別該填入 'T' 或 'F'，我們就需要判斷它所連接的左右兩側的語句分別是真還是假。首先先判斷 '$&not;A$' 在這八種不同的情況裡分別是真還是假：
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$&not;A$</td><td class="mainc">$&and;$</td><td>$(B&or;C)$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
						</table>
						因為 '$&not;A$' 只有使用到 '$A$' 這個原子語句，因此 '$&not;A$' 的真假完全決定於 '$A$' 的真假，所以我們只要看 '$A$' 的那一欄，再根據前面介紹的否定句的真值表來填入即可，故在 '$A$' 為真的那四列中，'$&not;A$' 皆為假，而在 '$A$' 為假的那四列中，'$&not;A$' 則皆為真。接下來我們判斷 '$(B&or;C)$' 的真假：
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$&not;A$</td><td class="mainc">$&and;$</td><td>$(B&or;C)$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>F</td><td class="mainc">&ensp;</td><td>T</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>F</td><td class="mainc">&ensp;</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>F</td><td class="mainc">&ensp;</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>F</td><td class="mainc">&ensp;</td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>T</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>T</td><td class="mainc">&ensp;</td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>T</td><td class="mainc">&ensp;</td><td>F</td></tr>
						</table>
						因為 '$(B&or;C)$' 只有使用到 '$B$'、'$C$' 兩個原子語句，故 '$(B&or;C)$' 的真假完全決定於 '$B$'、'$C$' 的真假，所以我們只要看 '$B$'、'$C$' 那兩欄，再根據前面介紹的選言句的真值表來填入即可。故在 '$B$'、'$C$' 中至少有一個為真的那六列中，'$(B&or;C)$' 為真，而在 '$B$'、'$C$' 皆為假的那兩列中，'$(B&or;C)$' 為假。最後，在確定了由整個語句的主要連接詞 '$&and;$' 所連接起來的兩個語句（即 '$&not;A$' 和 '$(B&or;C)$'）在八種不同的可能情況下的真假後，我們終於可以來判斷 '$&not;A&and;(B&or;C)$' 的真假：
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$&not;A$</td><td class="mainc">$&and;$</td><td>$(B&or;C)$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>T</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>T</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>T</td><td class="mainc"><b><i>F</i></b></td><td>F</td></tr>
						</table>
					</p>
					<p>
					無論是多複雜的語句，只要一步步根據完構式的建構方式將它拆解成更基本的語句，最後就能根據原子語句的真假來判斷出該語句在不同的假設情況下分別是真還是假。我們再看一個例子：$(A&rarr;(B&or;&not;C))&or;((C&and;&not;B)&harr;(A&and;B))$
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A&rarr;(B&or;&not;C))&or;((C&and;&not;B)&harr;(A&and;B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td></tr>
						</table>
					雖然這個語句比較長，結構上也比較複雜（我們是用一個語句使用的語句連接詞的數量來定義語句的結構複雜的程度），但因為總共只用了三個原子語句，故所有的可能性依然只有 $2^3$ ($=8$) 種，所以一樣畫八列真值表，並分別填入三個原子語句之真假的不同排列組合。接著，我們把要判斷其真假的語句的主要連接詞那欄標示出來：
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A&rarr;(B&or;&not;C))$</td><td class="mainc">$&or;$</td><td>$((C&and;&not;B)&harr;(A&and;B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td></tr>
						</table>
					為了判斷主要連接詞那一欄的真假，我們必須判斷由主要連接詞所連接的左、右兩個語句的真假，因此我們也需要標示出這兩個語句各自的主要連接詞：
						<table class="truth triple bigrank full">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td class="mainc2">&rarr;</td><td>$(B&or;&not;C))$</td><td class="mainc">$&or;$</td><td>$((C&and;&not;B)$</td><td class="mainc2">$&harr;$</td><td>$(A&and;B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td></tr>
						</table>
					為了判斷 '$(A&rarr;(B&or;&not;C))$' 的真假，我們需要先判斷 '$(B&or;&not;C)$' 的真假，所以一樣要把 '$(B&or;&not;C)$' 的主要連接詞那一欄標示出來；同理，為了判斷 '$((C&and;&not;B)&harr;(A&and;B))$' 的真假，我們也需要先分別判斷 '$(C&and;&not;B)$' 和 '$(A&and;B)$' 的真假，因此也要分別將這兩個語句的主要連接詞那一欄標示出來：
						<table class="truth triple bigrank full">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td class="mainc2">&rarr;</td><td>$(B$</td><td>$&or;$</td><td>$&not;C))$</td><td class="mainc">$&or;$</td><td>$((C$</td><td>$&and;$</td><td>$&not;B)$</td><td class="mainc2">$&harr;$</td><td>$(A$</td><td>$&and;$</td><td>$B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
						</table>
					然後就可以一步一步從結構最簡單的語句一路填到結構最複雜的語句。首先，我們把 '$&not;C$' 和 '$&not;B$' 那兩欄的真假填進去：
						<table class="truth triple bigrank full">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td class="mainc2">&rarr;</td><td>$(B$</td><td>$&or;$</td><td>$&not;C))$</td><td class="mainc">$&or;$</td><td>$((C$</td><td>$&and;$</td><td>$&not;B)$</td><td class="mainc2">$&harr;$</td><td>$(A$</td><td>$&and;$</td><td>$B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td class="mainc2">&ensp;</td><td>&ensp;</td><td>&ensp;</td><td>&ensp;</td></tr>
						</table>
					接著，我們可以用 '$B$' 和 '$&not;C$' 的真假來判斷 '$(B&or;&not;C)$' 的真假，用 '$C$' 和 '$&not;B$' 的真假來判斷 '$(C&and;&not;B)$' 的真假，用 '$A$' 和 '$B$' 的真假來判斷 '$(A&and;B)$' 的真假，然後就可以將這三個語句的真假也分別填進去：
						<table class="truth triple bigrank full">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td class="mainc2">&rarr;</td><td>$(B$</td><td>$&or;$</td><td>$&not;C))$</td><td class="mainc">$&or;$</td><td>$((C$</td><td>$&and;$</td><td>$&not;B)$</td><td class="mainc2">$&harr;$</td><td>$(A$</td><td>$&and;$</td><td>$B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>F</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>F</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>T</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>T</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>F</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>F</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>T</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>T</i></b></td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>T</td><td class="mainc2">&ensp;</td><td>&ensp;</td><td><b><i>F</i></b></td><td>&ensp;</td></tr>
						</table>
					下一步，我們就可以用 '$A$' 和 '$(B&or;&not;C)$' 的真假來判斷 '$(A&rarr;(B&or;&not;C))$' 的真假，用 '$(C&and;&not;B)$' 和 '$(A&and;B)$' 的真假來判斷 '$((C&and;&not;B)&harr;(A&and;B))$' 的真假，並將這兩個語句的真假分別填入：
						<table class="truth triple bigrank full">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td class="mainc2">&rarr;</td><td>$(B$</td><td>$&or;$</td><td>$&not;C))$</td><td class="mainc">$&or;$</td><td>$((C$</td><td>$&and;$</td><td>$&not;B)$</td><td class="mainc2">$&harr;$</td><td>$(A$</td><td>$&and;$</td><td>$B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>T</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2"><b><i>F</i></b></td><td>&ensp;</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2"><b><i>F</i></b></td><td>&ensp;</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2"><b><i>F</i></b></td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc2"><b><i>F</i></b></td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>F</td><td>T</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>T</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc2"><b><i>F</i></b></td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc">&ensp;</td><td>&ensp;</td><td>F</td><td>T</td><td class="mainc2"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
						</table>
					最後，我們就能用 '$(A&rarr;(B&or;&not;C))$' 和 '$((C&and;&not;B)&harr;(A&and;B))$' 這兩個語句的真假，根據選言句的真值表來判斷 '$(A&rarr;(B&or;&not;C))&or;((C&and;&not;B)&harr;(A&and;B))$' 的真假：
						<table class="truth triple bigrank full">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td class="mainc2">&rarr;</td><td>$(B$</td><td>$&or;$</td><td>$&not;C))$</td><td class="mainc">$&or;$</td><td>$((C$</td><td>$&and;$</td><td>$&not;B)$</td><td class="mainc2">$&harr;$</td><td>$(A$</td><td>$&and;$</td><td>$B))$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">T</td><td>&ensp;</td><td>T</td><td>F</td><td class="mainc"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2">F</td><td>&ensp;</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">T</td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2">F</td><td>&ensp;</td><td>T</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">F</td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc2">F</td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">T</td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>T</td><td class="mainc2">T</td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>&ensp;</td><td class="mainc2">T</td><td>&ensp;</td><td>T</td><td>F</td><td class="mainc"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2">T</td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>&ensp;</td><td class="mainc2">T</td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc2">T</td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>&ensp;</td><td class="mainc2">T</td><td>&ensp;</td><td>F</td><td>F</td><td class="mainc"><b><i>T</i></b></td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc2">F</td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>&ensp;</td><td class="mainc2">T</td><td>&ensp;</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>&ensp;</td><td>F</td><td>T</td><td class="mainc2">T</td><td>&ensp;</td><td>F</td><td>&ensp;</td></tr>
						</table>
					</p>
					<p>
					要熟悉真值表的使用方式，無非就是練習，所以我會在下面列出幾個語句邏輯中的語句，請你試著用真值表來判斷這些語句在所有的不同可能情況下，真假為何：
						<ol class="numd tight">
							<li>$A&rarr;&not;B$</li>
							<li>$&not;(B&or;(A&rarr;C))$</li>
							<li>$&not;(A&and;B)&rarr;&not;(A&or;C)$</li>
							<li>$(A&rarr;B)&or;(A&and;&not;B)$</li>
							<li>$A&rarr;(B&rarr;A)$</li>
							<li>$(A&or;B)&and;(&not;A&and;&not;B)$</li>
						</ol>
					</p>
				</div>
			</div>
			
			<h2>語句邏輯的語意模型</h2>
			
			<div class="section">
			
				<h3>何謂語意模型？</h3>
				
				<div class="subsection">
					<p>
					前面說過，在語句邏輯中每一個語句的真假都可以由該語句使用到的原子語句的真假來決定。換言之，只要能夠確認一個語句使用到的所有原子語句的真假，我們就能據此判斷出該語句的真假。比如說，'$&not;A&and;(B&or;C)$' 這個語句用到了三個原子語句，分別是 '$A$'、'$B$'、'$C$'。因此，要判斷它的真假，就需要先知道 '$A$'、'$B$'、'$C$' 三者的真假。
					</p>
					<p>
					假設 '$A$' 為真、'$B$' 為假、'$C$' 為真，在這個情況下，我們可以知道：因為 '$A$' 為真，所以 '$&not;A$' 為假；因為 '$B$' 為假而 '$C$' 為真，所以 '$B&or;C$' 為真。最後，我們可以根據 '$&not;A$' 為假，以及 '$B&or;C$' 為真，判斷出來 '$&not;A&and;(B&or;C)$' 為假。
					</p>
					<p>
					既然只要知道了一個語句使用到的所有原子語句的真假，我們就能知道一個語句的真假，那麼，只要我們能夠知道<b>所有原子語句</b>的真假，我們豈不是就能知道<b>所有語句</b>的真假了？也就是說，不只是去確定 '$A$'、'$B$'、'$C$' 的真假，我們還要一併確認 '$D$'、'$E$'、'$F$'、……、'$Z$' 的真假，同時還包括 '$A_1$'、'$A_2$'、'$A_3$'、……、'$A_n$'、……的真假，還有 '$B_1$'、$B_2$'、'$B_3$'、……、'$B_n$'、……的真假，'$C_1$'、'$C_2$'、'$C_3$'、……、'$C_n$'、……的真假，一直到 '$Z_1$'、'$Z_2$'、'$Z_3$'、……、'$Z_n$'、……的真假。
					</p>
					<p>
					沒錯。因為在語句邏輯的語言中，所有的語句一定都是用原子語句組合出來的，因此只要我們可以確認<b>每一個原子語句</b>的真假，我們就能夠確定<b>每一個語句</b>的真假。就像在畫真值表一樣，我們可以試著把語句邏輯中所有的原子語句一一排列出來：
						<table class="truth bigrank nosen">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td class="omit"></td><td>$Z$</td><td>$A_1$</td><td>$A_2$</td><td>$A_3$</td><td class="omit"></td><td>$A_n$</td><td class="omit"></td><td>$B_1$</td><td>$B_2$</td><td>$B_3$</td><td class="omit"></td><td>$B_n$</td><td class="omit"></td><td>$Z_1$</td><td>$Z_2$</td><td>$Z_3$</td><td class="omit"></td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
							<tr class="omit"><td>&vellip;<br/>&vellip;</td><td></td><td></td><td class="omit"></td><td></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td>F</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>F</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td class="omit"></td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td class="omit"></td><td>F</td><td>F</td><td>T</td><td>F</td><td class="omit"></td><td>F</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>F</td><td>T</td><td>F</td><td class="omit"></td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>F</td><td class="omit"></td><td>F</td><td class="omit"></td><td>F</td><td>F</td><td>T</td><td class="omit"></td><td>F</td><td class="omit"></td><td>F</td><td>T</td><td>T</td><td class="omit"></td></tr>
							<tr class="omit"><td>&vellip;<br/>&vellip;</td><td></td><td></td><td class="omit"></td><td></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td></tr>
						</table>
					其中的每一列都代表一種可能性。第一列代表著<b>所有原子語句</b>都為真的可能性；第二列代表了 '$A$' 為假但其餘的原子語句全部為真的可能性；第三列則代表了 '$B$' 為假但其餘原子語句全部為真的可能性；第四列則代表了 '$A$'、'$C$' 為假而其餘原子語句全部為真的可能性……。
					</p>
					<p>
					因為這些可能性涵括了<b>所有原子語句</b>的真假，所以只要給定了其中一種可能性，那隨便挑一個語句邏輯中的語句，都可以判斷出它的真假是什麼。比如說，我們先給定第一種可能性，也就是所有原子語句皆為真的可能性。在這個可能性之下，我們可以試著判斷 '$(((A&and;Z_1)&or;Y_32)&rarr;&not;(Q&and;P_997))&harr;((R_13&or;(S&rarr;&not;T))&and;&not;N_66)$' 的真假：
					</p>
					<p>
					因為目前給定的可能性是所有原子語句皆為真，所以這個語句裡使用到的每一個原子語句當然都為真。因此，我們可以知道 '$A&and;Z_1$' 為真、'$Y_32$' 為真、'$Q&and;P_997$' 為真、'$R_13$' 為真、'$S&rarr;&not;T$' 為假、'$&not;N_66$' 也為假。
					</p>
					<p>
					下一步：因為 '$A&and;Z_1$' 和 '$Y_32$' 皆為真，所以 '$(A&and;Z_1)&or;Y_32$' 為真；因為 '$Q&and;P_997$' 為真，所以 '$&not;(Q&and;P_997)$' 就為假；因為 '$R_13$' 為真而 '$S&rarr;&not;T$' 為假，故 '$(R_13&or;(S&rarr;&not;T)'$ 為真。
					</p>
					<p>
					接著：因為 '$(A&and;Z_1)&or;Y_32$' 為真，而 '$&not;(Q&and;P_997)$' 為假，因此由這兩個語句組成的條件句 '$((A&and;Z_1)&or;Y_32)&rarr;&not;(Q&and;P_997)$' 便為假（因為前件真而後件假）；然後，因為 '$R_13&or;(S&rarr;&not;T)$' 為真，而 '$&not;N_66$' 為假，故 '$(R_13&or;(S&rarr;&not;T))&and;&not;N_66$' 便為假（因為連言句的其中一項為假，故連言句為假）。
					</p>
					<p>
					最後：因為 '$((A&and;Z_1)&or;Y_32)&rarr;&not;(Q&and;P_997)$' 為假，而且 '$(R_13&or;(S&rarr;&not;T))&and;&not;N_66$' 也為假，所以 '$(((A&and;Z_1)&or;Y_32)&rarr;&not;(Q&and;P_997))&harr;((R_13&or;(S&rarr;&not;T))&and;&not;N_66)$' 為真（因為當雙條件句的前後件同真或同假時，雙條件句即為真）。
					</p>
					<p>
					我們把這些涵括了<b>所有原子語句</b>之真假的可能性，稱為一個<b>語意模型 (semantic model)</b>，每一個不同的可能性都是一個獨特的語意模型。所有原子語句皆為真的可能性是一個語意模型，而 '$A$' 為假但其餘原子語句皆為真的可能性是另一個語意模型，'$B$' 為假而其餘原子語句都為真的可能性又是另一個語意模型……。
					</p>
					<p>
					為了方便稱呼這些語意模型，我們用<b>書寫體的小寫英文字母 '$\sc{v}$'</b> 來表示，並且為了區分不同的語意模型，我們就用數字下標來為不同的語意模型編號。比如說，我們可以將所有原子語句皆為真的語意模型稱作 '$\sc{v}_1$'（表示這是編號 1 號的語意模型），將 '$A$' 為假但其餘原子語句皆為真的語意模型稱作 '$\sc{v}_2$'（表示這是編號 2 號的語意模型），……。以此類推，我們可以將所有語意模型表列如下：
					</p>
					<table class="truth bigrank nosen model">
						<tr><td></td><td>$A$</td><td>$B$</td><td>$C$</td><td class="omit"></td><td>$Z$</td><td>$A_1$</td><td>$A_2$</td><td>$A_3$</td><td class="omit"></td><td>$A_n$</td><td class="omit"></td><td>$B_1$</td><td>$B_2$</td><td>$B_3$</td><td class="omit"></td><td>$B_n$</td><td class="omit"></td><td>$Z_1$</td><td>$Z_2$</td><td>$Z_3$</td><td class="omit"></td></tr>
						<tr><td>$\sc{v}_1$</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
						<tr><td>$\sc{v}_2$</td><td>F</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
						<tr><td>$\sc{v}_3$</td><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
						<tr><td>$\sc{v}_4$</td><td>F</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td class="omit"></td></tr>
						<tr class="omit"><td>&vellip;<br/>&vellip;</td><td></td><td></td><td></td><td class="omit"></td><td></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td></tr>
						<tr><td>$\sc{v}_n$</td><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td>F</td><td class="omit"></td><td>T</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>F</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td class="omit"></td></tr>
						<tr><td>$\sc{v}_{n+1}$</td><td>F</td><td>T</td><td>F</td><td class="omit"></td><td>F</td><td>F</td><td>T</td><td>F</td><td class="omit"></td><td>F</td><td class="omit"></td><td>T</td><td>F</td><td>T</td><td class="omit"></td><td>T</td><td class="omit"></td><td>F</td><td>T</td><td>F</td><td class="omit"></td></tr>
						<tr><td>$\sc{v}_{n+2}$</td><td>T</td><td>F</td><td>F</td><td class="omit"></td><td>T</td><td>T</td><td>T</td><td>F</td><td class="omit"></td><td>F</td><td class="omit"></td><td>F</td><td>F</td><td>T</td><td class="omit"></td><td>F</td><td class="omit"></td><td>F</td><td>T</td><td>T</td><td class="omit"></td></tr>
						<tr class="omit"><td>&vellip;<br/>&vellip;</td><td></td><td></td><td></td><td class="omit"></td><td></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td><td></td><td class="omit"></td><td></td><td></td><td></td><td class="omit"></td></tr>
					</table>
					<p>
					如此一來，只要我們給定一個特定的語意模型（例如 $\sc{v}_i$，$i$ 是某個自然數），我們就能根據這個語意模型中每一個原子語句的真假，來判斷出任何語句的真假。也就是說，在每一個語意模型之下，任何一個語句一定都有一個確定的真假值。
					</p>
				</div>
			
				<h3>語意模型和世界</h3>
				
				<div class="subsection">
					<p>
					語意模型本身是個很抽象的概念，要直接理解這個概念並使用它並不容易，但透過一些比較具體的概念來類比，還是可以幫助我們更容易瞭解語意模型到底是什麼東西。以下，我將把每一個不同的語意模型都類比成一個世界，並透過這樣的類比，來試著瞭解語意模型。
					</p>
					<p>
					在介紹基本概念的時候，我提到自然語言中的語句依其功能可以分成不同的類型，常見的有用來提出問題的<b>疑問句</b>，或是向別人提出請求或下達命令的<b>祈使句</b>，還有用來描述事實的<b>陳述句</b>等。此外我也提到，在這些不同的語句類型當中，只有陳述句是有真假可言的，而判斷陳述句真假的方法，就是去檢查陳述句的描述和事實是否相符，相符者就是真的，不相符者就是假的。
					</p>
					<p>
					也就是說，在判斷陳述句的真假時，我們一共需要確認兩樣東西：一、我們要判斷其真假的那個陳述句到底描述了什麼？二、我們的世界長什麼樣子？在分別確認過這兩件事之後，我們才有可能去比較兩者之間是否相符。由於每一個陳述句一定都是在描述一個事情的狀態，我們就把每一個陳述句描述的內容稱為<b>事態 (state of affairs)</b>。
					</p>
					<p>
					什麼是事態？事態（或事情的狀態）指的就是事物呈現出來的狀態。一個事態可以是關於單一個事物的狀態，那麼這個事態就是關於那個事物本身的狀態；但一個事態也可以是關於多個事物所共同呈現的狀態，那麼這個事態就會是關於多個事物之間的關係。
					</p>
					<p>
					例如，當我們說「<q>這張桌子是咖啡色的</q>」，我們就是在描述一個事物（這張桌子）本身的狀態（它的顏色是咖啡色的）。又比如，當我們說「<q>科科比安安還要高</q>」的時候，我們就是在描述兩個事物（科科、安安）之間的關係（科科比安安還要高），而這個關係，當然就是這兩個事物共同呈現出來的狀態。
					</p>
					<p>
					當我們在判斷一個陳述句是否為真的時候，我們其實就是在判斷這個陳述句描述到了什麼事態，然後判斷它所描述的那個事態和事實是否相符。舉例來說：
						<ol class="lltd tight song" style="counter-reset:lltd;">
							<li>南華大學在嘉義縣大林鎮。</li>
						</ol>
					要判斷這個陳述句的真假，就需要先確認這個陳述句描述了什麼事態。
					一但確認了這個陳述句所描述的事態是什麼以後，我們就能去比較這個事態是否符合事實，只要符合事實，那這個陳述句就為真。
					</p>
					<p>
					根據我們對中文的理解，我們知道這個陳述句是在描述一個名叫「南華大學」的教育研究機構的地理位置是在一個被稱作「嘉義縣大林鎮」的地方（可以看得出來，這是在描述一個機構和一個地點之間的關係）。在確認了這個陳述句所描述的事態以後，我們進一步就要確認這個事態是否符合事實，也就是確認這個世界上是不是有這麼一個名叫「南華大學」的教育研究機構，而它是不是確實位在一個被稱作「嘉義縣大林鎮」的地方？
					</p>
					<p>
					經過確認之後，我們發現確實有這麼一個名叫「南華大學」的教育研究機構，這個機構的地理位置也確實是在一個被稱作「嘉義縣大林鎮」的地方，因此我們可以判斷，a 這個陳述句是真的。
					</p>
					<p>
					中文裡的陳述句當然不會只有 a 這麼一個，實際上，中文裡的陳述句有無限多個。比如說，除了 a 以外，我們知道：
						<ol class="lltd tight song" style="counter-reset:lltd 2;">
							<li>中山大學在高雄市鼓山區。</li>
						</ol>
					這個語句也是一個中文裡的陳述句，它也描述了一個事態。並且，因為 c 所描述的事態與事實是符合的，所以我們也會知道 c 是一個真語句。同理：
						<ol class="lltd tight song">
							<li>政治大學在台北市文山區。</li>
							<li>文化大學在台北市士林區。</li>
							<li>逢甲大學在台中市西屯區。</li>
							<li>環球科技大學在雲林縣斗六市。</li>
						</ol>
					這些語句也都各自描述了一個事態，而且因為它們所描述的事態符合事實，所以這些中文的陳述句也都為真。相對地，像以下這些中文裡的描述句就都是假的：
						<ol class="lltd tight song">
							<li>台南市在嘉義市的北邊。</li>
							<li>台北市在花蓮市的東邊。</li>
							<li>南投縣四面都靠海。</li>
							<li>澎湖縣的陸地與台灣本島相連。</li>
						</ol>
					因為這些語句所描述的事態都與事實並不相符。
					</p>
					<p>
					值得注意的是，以上的 a 和 c-k 這些語句，因為都不包含任何語句連接詞的關係，所以它們都是原子語句。既然它們都是原子語句，我們就把這些中文裡的原子語句所描述的事態稱為<b>原子事態 (atomic state of affairs)</b>。並且，因為這些語句都是原子語句的關係，當我們要用語句邏輯的語言來改寫它們的時候，我們就可以用不同的語句符號來分別代表每一個語句（因為語句符號就是用來代表原子語句的）。
					</p>
					<p>
					為了方便起見，我們分別用對應的大寫英文字母來代表這些原子語句，比如說，我們可以用 '$A$' 來代表語句 a、用 '$C$' 來代表語句 c，用 '$D$' 來代表語句 d……，以此類推。在給定了代表這些語句的語句符號之後，我們也可以根據這些原子語句所描述的原子事態是否符合事實，來判斷出 '$A$' 為真、'$C$' 為真、'$D$' 為真，'$E$' 為真，'$F$' 為真，'$G$' 為真，'$H$' 為假，'$I$' 為假、'$J$' 為假、'$K$' 為假……。
					</p>
					<p>
					既然它們都是原子語句，我們當然也可以用各種語句連接詞來連接它們，以創造出新的、結構比較複雜的語句。比如說，我們可以將語句  a 和語句 c 用「……而且……」這個連接詞連接起來，形成：
						<ol class="lltd song tight" style="counter-reset:lltd 11;">
							<li>南華大學在嘉義縣大林鎮，而且，中山大學在高雄市鼓山區。</li>
						</ol>
					我們也可以將語句 d 和語句 h 用「……或者……」連接起來，形成：
						<ol class="lltd song tight">
							<li>政治大學在台北市文山區，或者，台南市在嘉義市的北邊。</li>
						</ol>
					我們也可以用「並非……」來連接語句 i 來形成：
						<ol class="lltd song tight">
							<li>並非台北市在花蓮市的東邊。</li>
						</ol>
					而語句 l、m、n 則分別可以用語句邏輯的符號寫成：
						<ol class="lltpd tight song" style="counter-reset:lltpd 11;">
							<li>$A&and;C$</li>
							<li>$D&or;H$</li>
							<li>$&not;I$</li>
						</ol>
					要注意的是，由於 l、m、n 這三個語句都不是原子語句，它們都是用原子語句和語句連接詞共同組合而成的複雜語句，所以當我們要用語句邏輯的符號來改寫這些語句時，就不能直接用一個語句符號來代表它們，而必須用 l'、m'、n' 這樣的寫法將它們的語句結構完整呈現出來。因此像是語句 b：
						<ol class="song lltd tight" style="counter-reset:lltd 1;">
							<li>如果科科期中考不及格，則科科的通識邏輯會被當。</li>
						</ol>
					由於這也不是一個原子語句，所以當我們要用語句邏輯的符號來改寫它時，當然也不能直接用一個語句符號來代表它，必須先將它的結構分析出來以後，再分別選用一個尚未被用過的語句符號來代表其中的原子語句，然後再將它寫成語句邏輯中的語句。
					</p>
					<p>
					以 b 這個例子來說，它的結構顯然是由「如果……則……」這個語句連接詞，再加上以下兩個語句：
						<ol class="lltd song tight" style="counter-reset:lltd 14;">
							<li>科科期中考不及格。</li>
							<li>科科的通識邏輯會被當。</li>
						</ol>
					共同組合而成的一個實質單條件句。不過分析其實還沒結束，雖然這不見得可以很容易看得出來，但語句 o 其實也不是一個原子語句，語句 o 的意思其實是「並非科科期中考及格」，也就是說，它事實上是由「並非……」這個語句連接詞和以下語句：
					<ol class="lltd song">
						<li>科科期中考及格。</li>
					</ol>
					所共同構成的一個否定句。
					</p>
					<p>
					既然 b 的結構已經被完全分析完了，我們也找到了其中使用到的兩個原子語句，我們就可以選用兩個尚未被使用到的語句符號來分別代表 p 和 q 這兩個原子語句，例如 '$P$' 和 '$Q$'，然後我們就能將 b 改寫成：
						<ol class="lltpd song" style="counter-reset:lltpd 1;">
							<li>$&not;Q&rarr;P$</li>
						</ol>
					</p>
					<p>
					此外，由於我們已經知道這些語句所使用到的原子語句在現實世界中的真假，所以我們也可以直接用真值表來判斷 l'、m'、n' 這些語句的真假，並藉此得知 l、m、n 等語句的真假。比如說，因為 '$A$'（代表語句 a：「南華大學在嘉義縣大林鎮」）實際上為真，而 '$C$'（代表語句 c：「中山大學在高雄市鼓山區」）也是真的，所以根據連言句的真值表的第一列，我們可以知道 l'（也就是：'$A&and;C$'）會是真的。
					</p>
					<p>
					而且這個透過真值表所做的語句真假的判斷是可以受到檢驗的。以 l' 為例，因為它是對 l 的改寫，所以我們可以直接檢查語句 l 到底是否為真。語句 l 說：「南華大學在嘉義縣大林鎮，而且，中山大學在高雄市鼓山區」，這個語句要怎樣才會為真？就是當這個語句所描述的事態符合事實的時候，它就為真。
					</p>
					<p>
					那這個語句描述了什麼事態呢？我在前面談到原子語句時提到，原子語句所描述的事態可被稱為<b>原子事態</b>，那麼既然像 l、m、n 等語句是由原子語句所組合成的複合語句，我們就將這些語句所描述的事態統稱為<b>複合事態</b>。因為 l 這個複雜語句是由 a 和 c 這兩個原子語句所組合成的，它所描述的複合事態當然就是關於 a 和 c 這兩個原子語句所描述的原子事態。l 所描述的複合事態就是：<b>a 和 c 這兩個語句所描述的原子事態都符合事實</b>。
					</p>
					<p>
					既然知道了 l 這個複雜語句所描述的複合事態是什麼，要判斷 l 是否為真，就變成是要判斷 l 所描述的複合事態是不是符合事實。既然 l 所描述的複合事態是「a 和 c 這兩個語句所描述的原子事態都符合事實」，那麼，只要 a 和 c 這兩個語句所描述的原子事態都符合事實，l 就為真；相對地，只要 a 和 c 這兩個語句所描述的原子事態至少有一個不符合事實，l 就為假。而根據我們前面的討論，我們知道 a 和 c 這兩個語句所描述的原子事態的確都符合事實，因此 l 為真。
					</p>
					<p>
					這個結果顯示了：我們利用真值表來判斷 l' 的真假所得到的結果，確實和它所改寫的語句 l 的真假是一樣的。
					</p>
					<p>
					讓我們再來看一個例子：m' 是 '$D&or;H$'，因此要判斷 m' 的真假就需要先知道 '$D$' 和 '$H$' 的真假。由於 '$D$' 是用來代表語句 d（也就是「政治大學在台北市文山區」），而 '$H$' 是用來代表語句 h（也就是「台南市在嘉義市的北邊」），而根據前面的判斷，我們知道 d 為真而 h 為假，因此我們可以知道 '$D$' 為真但 '$H$' 為假，那麼，根據選言句真值表的第二列，我們就能知道 '$D&or;H$' 為真，也就是 m' 為真。
					</p>
					<p>
					接著，因為 m' 是用改寫自 m 這個語句的，因此我們也可以藉由檢查語句 m 描述的事態是否符合事實，並以此來檢驗透過真值表來判斷出 m' 的真假是否正確。為了做這件事，我們需要先確定語句 m 描述了什麼。語句 m 說：「政治大學在台北市文山區，或者，台南市在嘉義市的北邊」，因此，語句 m 說的是，d 和 h 這兩個原子語句描述的原子事態中至少有一個符合事實。
					</p>
					<p>
					確實，參考我們實際生活的這個現實世界，儘管語句 h 描述的原子事態並不符合事實，但至少語句 d 描述的原子事態是符合事實的，因此這兩個語句所描述的事態中確實至少有一個是符合事實的，因此語句 m 描述的複合事態是符合事實的。也就是說，透過真值表來判斷出 m' 為真確實得到了驗證。
					</p>
					<p>
					礙於篇幅的關係，我沒辦法列舉太多例子，但讀者自己如果有興趣的話，可以自己試驗看看。首先先隨便列出一些原子語句，然後用語句連接詞將這些原子語句連接起來組成複雜的語句，接著再將這些語句按照前述的方法改寫成語句邏輯中的語句。然後，讀者可以自行根據這些原子語句描述的事態是否符合事實，來判斷它們各自的真假，接著再用真值表來判斷用那些複雜語句的真假。
					</p>
					<p>
					最後，讀者可以直接檢查那些複雜語句本身所描述的複合事態是否符合事實，並看看檢查出來的結果是否和先前用真值表所判斷出來的真假相同。只要這個流程中的每一個步驟都沒有出錯，那用這兩種方法判斷出來的語句真假一定會是相同的。
					</p>
				</div>
					
				<h3>不同的語意模型對應到不同的世界</h3>
					
				<div class="subsection">
					<p>
					前面說過，中文裡的陳述句有無限多個，這是包含了原子語句和複雜語句的情況，畢竟就算原子語句是有限的，我們也有無限多種不同的方法可以組合它們來形成無限多個不同的複雜語句。那中文裡的原子語句有多少個呢？其實這是沒有辦法去計算的，但是反正我們的語句邏輯裡有無限多個可以用的語句符號，所以就算中文裡有無限多個原子語句，我們也不用怕語句符號不夠用。
					</p>
					<p>
					無論中文裡的原子語句有多少個，這些原子語句都會描述到一個事態，而且這些原子語句所描述到的事態一定都與事實是符合或不符合的。即使是那些我們不可能去確定真假的語句，也一定都描述到了一個要麼符合事實、要麼不符合事實的事態。所以就算是「<q>南華大學裡的所有草皮上總共有四千六百三十八億五千七百九十六萬三千五百四十三根草</q>」這樣的原子語句，雖然沒有人可以數得清楚到底有幾根草，它所描述的事態依然要麼符合事實，要麼就不符合事實，不會有第三種情況。
					</p>
					<p>
					換言之，在這個世界上，每一個中文的原子語句都會有一個確定的真假值，即使我們不一定能知道。那麼，這個世界其實就像是一個語意模型一樣，只要給定了這個世界的狀態，那每一個原子語句就會有一個確定的真假值；這就好像只要給定了一個語意模型 $\sc{v}_n$（'$n$' 是未知數），那麼每一個語句邏輯中的原子語句都會有一個確定的真假值一樣。
					</p>
					<p>
					也就是說，只要我們將語句邏輯中的每一個語句符號都用來代表一個中文裡的原子語句，那麼就會有一個語意模型可以完全描述我們的世界。因為只要我們找到一個語意模型，它剛好讓中文裡所有真的原子語句為真，同時讓中文裡所有假的原子語句為假，那麼，所有用原子語句加上語句連接詞所組合起來的複雜語句的真假就一定也會一樣。這件事情我在上一個小節裡已經用幾個例子來說明過了。
					</p>
					<p>
					舉例來說，假設 $\sc{v}_k$（$k$ 是某個特定的自然數）就是可以完全描述我們生活的這個世界的語意模型，那麼，基於語句 a、c、d、e、f、g 都為真，而且語句 h、i、j、k 都為假，而且 '$A$' 代表語句 a、'$C$' 代表語句 c、'$D$' 代表語句 d、……、'$K$' 代表語句 k，所以，根據 $\sc{v}_k$ 這個語意模型，'$A$'、'$C$'、'$D$'、'$E$'、'$F$'、'$G$' 這些原子語句都為真，而 '$H$'、'$I$'、'$J$'、'$K$' 則都為假。
					</p>
					<p>
					為了方便記述這些事，我們可以把（例如）「在 $\sc{v}_k$ 這個語意模型中，'$A$' 為真」寫成：'$\sc{v}_k&vDash;A$'，把「在 $\sc{v}_k$ 這個語意模型中，'$H$' 為假」這件事寫成：'$\sc{v}_k&nvDash;H$'。在這種寫法裡用到的 '$&vDash;$'、'$&nvDash;$' 這兩個符號，可以分別讀成「……讓……為真」和「……讓……不為真」。也就是說，$\sc{v}_k&vDash;A$ 可以讀成「$\sc{v}_k$ 讓 $A$ 為真」，而 '$\sc{v}_k&nvDash;H$' 則可以讀成「$\sc{v}_k$ 讓 $H$ 不為真」（當 $\sc{v}_k$ 讓 $H$ 不為真的時候，意思當然就是讓 $H$ 為假）。
					</p>
					<p>
					讀到這裡，可能會有讀者產生一個疑惑：既然每個語句一定都有一個確定的真假，為什麼我們需要用到語意模型來說這件事？為什麼我們不能直接說一個語句是真或是假就好了？比如說，我們都知道南華大學的確就在嘉義縣大林鎮，既然如此，為什麼我們不直接說 '$A$' 為真就好了？為什麼還要說 $\sc{v}_k$ 這個語意模型讓 $A$ 為真？
					</p>
					<p>
					之所以要用到語意模型來說這件事，其中有一個主要的理由是，我們不一定總是知道一個語句到底是真還是假。前面所舉的例子都是我們可以用生活常識就能判斷真假的語句，但是像「<q>南華大學裡的所有草皮上總共有四千六百三十八億五千七百九十六萬三千五百四十三根草</q>」這樣的語句，我們不僅沒有辦法用生活常識來判斷它的真假，我們甚至找不到任何方法來確認它的真假。
					</p>
					<p>
					既然我們無法<b>知道</b>這個語句到底是真還是假，我們就不能直接說它是真或是假，我們只能把「它是真的」當成一種可能的情況來考慮，同時把「它是假的」當成另一種可能的情況來考慮。既然需要考慮不同的情況，透過區分不同的語意模型，可以幫助我們知道現在在談的是哪一種情況。比如說，當我們要考慮它為假的情況，那我們要考慮的其實就是所有讓它不為真的 $\sc{v}_n$（$n$ 是一個未知數）。
					</p>
					<p>
					另外一個要用到語意模型來說語句的真假的理由是：即使有些語句我們可以明確地知道它的真假，我們還是會有需要考慮一個跟現實不大一樣的情況的時候。比如說，我們當然都知道南華大學在嘉義縣大林鎮，所以我們都知道 '$A$' 為真，但我們偶爾還是會遇到需要去考慮南華大學其實不在嘉義縣大林鎮的情況。
					</p>
					<p>
					在這種情況下我們當然也不能直接說 '$A$' 為假，因為我們都知道 '$A$' 其實為真。所以為了進行這種思考，我們還是需要一種說法去區分 '$A$' 為真的情況和 '$A$' 為假的情況，而語意模型就是可以做到這件事的一種說法。我們可以說，儘管在我們的世界中 '$A$' 為真（也就是 $\sc{v}_k&vDash;A$，因為我們之前假設可以完全描述我們的世界的語意模型是 $\sc{v}_k$），我們還是可以去考慮另外一些讓 '$A$' 不為真的語意模型 $\sc{v}_n$（'$n$' 是未知數，而且 $n&ne;k$）。
					</p>
					<p>
					也就是說，我們可以把每個不同的語意模型理解成：每個不同的語意模型都描述了是一個不一樣的世界。比如說，根據我們在 2.2.1 小節的最後畫的那個表格，$\sc{v}_1$ 這個語意模型就描述了一個所有原子語句都為真的世界，在那個世界裡，'$A$' 為真（所以南華大學在嘉義縣大林鎮）、'$D$' 為真（所以政治大學在台北市文山區）、'$H$' 也為真（所以台南市在嘉義市的北邊）、'$K$' 也為真（所以澎湖縣的陸地與台灣本島相連）。
					</p>
					<p>
					而 $\sc{v}_2$ 則描述了一個和 $\sc{v}_1$ 不太一樣的世界，因為 $\sc{v}_2$ 描述的是一個除了 '$A$' 以外的原子語句都為真的世界，也就是說，在 $\sc{v}_2$ 所描述的世界中，'$A$' 為假（也就是南華大學不在嘉義縣大林鎮），但 '$D$'、'$H$'、'$K$'、……等語句皆為真（所以政治大學在台北市文山區、台南市在嘉義市的北邊、澎湖縣的陸地與台灣本島相連……）。
					</p>
					<p>
					既然每個語意模型都描述了一個不太一樣的世界，當我們想要考慮某個樣子的世界的時候，我們就可以把描述了那種樣子的世界的語意模型挑出來討論就好，當我們要考慮南華大學不在嘉義縣大林鎮的情況時，我們就是要考慮那些讓 '$A$' 不為真的 $\sc{v}_n$（'$n$' 是未知數）。
					</p>
					<p>
					以語句 b 為例，語句 b 說：「<q>如果科科期中考不及格，則科科的通識邏輯會被當</q>」，這是一個複雜的語句，當我們用 '$Q$' 來代表「<q>科科期中考及格</q>」這個原子語句，並且用 '$P$' 來代表「<q>科科的通識邏輯會被當</q>」這個原子語句時，我們可以把 b 改寫成 b'：'$&not;Q&rarr;P$'。
					</p>
					<p>
					為了要判斷 b 的真假，我們需要知道 '$P$' 和 '$Q$' 各自的真假。可是我們根本不可能知道 '$P$' 和 '$Q$' 到底是真的還是假的，因為科科根本沒有修通識邏輯課（科科只是常常被我當成例子的一個朋友而已）。但即使在現實的情況下科科根本沒有修通識邏輯課，我們還是可以去考慮一個科科有修課，然後科科期中考的確不及格，但是科科沒有被當的情況。
					</p>
					<p>
					也就是說，我們可以去考慮那些讓 '$Q$' 為假而且 '$P$' 也為假的語意模型。當我們去考慮那些語意模型的時候，我們可以根據真值表判斷出來，在那些語意模型中，因為 '$Q$' 為假，所以 '$&not;Q$' 為真；而當 '$&not;Q$' 為真但 '$P$' 為假的時候，'$&not;Q&rarr;P$' 就是假的。因此，在那些 '$Q$' 為假而且 '$P$' 也為假的語意模型中，b' 是假的。也就是說，在一個科科修了通識邏輯課，而且他的期中考不及格，但卻沒有被當的世界裡，「<q>如果科科期中考不及格，則科科的通識邏輯會被當</q>」是假的。
					</p>
					<p>
					當我們對語意模型有了上述的理解以後，我們也可以用語意模型來理解真值表的意義，比如說：
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$&not;A$</td><td class="mainc">$&and;$</td><td>$(B&or;C)$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>T</td></tr>
							<tr><td>T</td><td>T</td><td>F</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>T</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td><td>F</td><td class="mainc"><b><i>F</i></b></td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>T</td></tr>
							<tr><td>F</td><td>T</td><td>F</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>T</td><td>T</td><td class="mainc"><b><i>T</i></b></td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>F</td><td>T</td><td class="mainc"><b><i>F</i></b></td><td>F</td></tr>
						</table>
					這個真值表的第一列其實就是在告訴我們，對於任何一個語意模型 $\sc{v}_n$（'$n$' 是未知數），如果 $\sc{v}_n&vDash;A$，而且 $\sc{v}_n&vDash;B$，而且 $\sc{v}_n&vDash;C$，那麼 $\sc{v}_n&nvDash;&not;A&and;(B&or;C)$；而第二列就是在告訴我們，對於任何一個語意模型 $\sc{v}_n$（'$n$' 是未知數），如果 $\sc{v}_n&vDash;A$，而且 $\sc{v}_n&vDash;B$，而且 $\sc{v}_n&nvDash;C$，那麼 $\sc{v}_n&nvDash;&not;A&and;(B&or;C)$。以下皆可以此類推。
					</p>
					<p>
					也就是說，這個真值表把所有不同的語意模型區分成了八種：第一種是讓 '$A$'、'$B$'、'$C$' 皆為真的；第二種是讓 '$A$'、'$B$' 為真但 '$C$' 為假的；第三種是讓 '$A$'、'$C$' 為真而 '$B$' 為假的；第四種是讓 '$A$' 為真但 '$B$'、'$C$' 皆為假的；第五種是讓 '$A$' 為假但 '$B$'、'$C$' 皆為真的；第六種是讓 '$A$'、'$C$' 為假而 '$B$ 為真的；第七種是讓 '$A$'、'$B$' 為假但 '$C$' 為真的；最後一種則是讓 '$A$'、'$B$'、'$C$' 皆為假的。
					</p>
					<p>
					為什麼說是八<b>種</b>，而不說是八<b>個</b>不同的語意模型呢？那是因為對每一<b>個</b>語句模型來說，它都包括了<b>所有</b>原子語句的真假，只要有一個原子語句的真假是不一樣的，那就會是不同的語意模型。考慮兩個不同的語意模型 $\sc{v}_i$ 和 $\sc{v}_j$（'$i$' 和 '$j$' 都是某個特定的自然數，而且 $i&ne;j$），即使這兩個語意模型都讓 '$A$'、'$B$'、'$C$' 為真，但如果 $\sc{v}_i&vDash;D$ 而 $\sc{v}_j&nvDash;D$，那麼 $\sc{v}_i$ 和 $\sc{v}_j$ 當然就會是兩個不同的語意模型，儘管它們都會被歸類在上面那個真值表的第一列中。
					</p>
					<p>
					換言之，雖然語意模型的個數是有無限多個的，而真值表卻只有聊聊數列，但其實真值表中的那聊聊數列就已經涵括了所有不同的語意模型了。此外，既然我們可以用語意模型來理解任意一個真值表，我們當然也可以用語意模型來理解那五大句型的真值表在說什麼：
					</p>
					<p>
					首先，<b>否定句 (negation)</b>的真值表如下：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&not;&alpha;$</td></tr>
							<tr><td>T</td><td>F</td></tr>
							<tr><td>F</td><td>T</td></tr>
						</table>
					這個真值表即是在說：<b>對任何一個語意模型 $\sc{v}_n$（'$n$' 是未知數），只要 $\sc{v}_n&vDash;&alpha;$，那麼 $\sc{v}_n&nvDash;&not;&alpha;$；而且，只要 $\sc{v}_n&nvDash;&alpha;$，那麼 $\sc{v}_n&vDash;&not;&alpha;$。</b>
					</p>
					<p>
					<b>連言句 (conjunction)</b>的真值表如下：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&and;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>F</td></tr>
							<tr><td>F</td><td>F</td><td>F</td></tr>
						</table>
					這個真值表即是在說：<b>對任何一個語意模型 $\sc{v}_n$（'$n$' 是未知數），只要 $\sc{v}_n&vDash;&alpha;$ 而且 $\sc{v}_n&vDash;&beta;$，那麼 $\sc{v}_n&vDash;&alpha;&and;&beta;$；而且，只要 $\sc{v}_n&nvDash;&alpha;$ 或者 $\sc{v}_n&nvDash;&beta;$，那麼 $\sc{v}_n&nvDash;&alpha;&and;&beta;$。</b>
					</p>
					<p>
					<b>選言句 (disjunction)</b>的真值表如下：：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&or;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>T</td></tr>
							<tr><td>F</td><td>T</td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>F</td></tr>
						</table>
					這個真值表即是在說：<b>對任何一個語意模型 $\sc{v}_n$（'$n$' 是未知數），只要 $\sc{v}_n&vDash;&alpha;$ 或者 $\sc{v}_n&vDash;&beta;$，那麼 $\sc{v}_n&vDash;&alpha;&or;&beta;$；而且，只要 $\sc{v}_n&nvDash;&alpha;$ 而且 $\sc{v}_n&nvDash;&beta;$，那麼 $\sc{v}_n&nvDash;&alpha;&or;&beta;$。</b>
					</p>
					<p>
					<b>實質條件句 (material conditional)</b>的真值表如下：：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&rarr;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>T</td></tr>
							<tr><td>F</td><td>F</td><td>T</td></tr>
						</table>
					這個真值表即是在說：<b>對任何一個語意模型 $\sc{v}_n$（'$n$' 是未知數），只要 $\sc{v}_n&nvDash;&alpha;$ 或者 $\sc{v}_n&vDash;&beta;$，那麼 $\sc{v}_n&vDash;&alpha;&rarr;&beta;$；而且，只要 $\sc{v}_n&vDash;&alpha;$ 而且 $\sc{v}_n&nvDash;&beta;$，那麼 $\sc{v}_n&nvDash;&alpha;&rarr;&beta;$。</b>
					</p>
					<p>
					<b>實質雙條件句 (material biconditional)</b>的真值表如下：：
						<table class="truth">
							<tr><td>$&alpha;$</td><td>$&beta;$</td><td>$&alpha;&harr;&beta;$</td></tr>
							<tr><td>T</td><td>T</td><td>T</td></tr>
							<tr><td>T</td><td>F</td><td>F</td></tr>
							<tr><td>F</td><td>T</td><td>F</td></tr>
							<tr><td>F</td><td>F</td><td>T</td></tr>
						</table>
					這個真值表即是在說：<b>對任何一個語意模型 $\sc{v}_n$（'$n$' 是未知數），只要 $\sc{v}_n&vDash;&alpha;$ 而且 $\sc{v}_n&vDash;&beta;$，或者 $\sc{v}_n&nvDash;&alpha;$ 而且 $\sc{v}_n&nvDash;&beta;$，那麼 $\sc{v}_n&vDash;&alpha;&harr;&beta;$；並且，只要 $\sc{v}_n&vDash;&alpha;$ 而且 $\sc{v}_n&nvDash;&beta;$，或者 $\sc{v}_n&nvDash;&alpha;$ 而且 $\sc{v}_n&vDash;&beta;$，那麼 $\sc{v}_n&nvDash;&alpha;&harr;&beta;$。</b>
					</p>
				</div>
			
			<h2>真值函數</h2>
			
			<div class="section">
				<p>
				之所以可以用真值表來判斷任何一個語句在不同的可能情況下的真假，是因為語句邏輯中的所有語句都是以某個語句連接詞作為主要連接詞構成的，而每一個以某個語句連接詞作為主要連接詞構成的語句都是一個<b>真值函數 (truth function)</b>。
				</p>
				<p>
				為了說明真值函數的意義，以及說明真值函數與真值表之間的關係，我必須先簡單地介紹一下<b>函數 (function)</b> 這個概念。不過因為函數是一個<b>集合論 (set theory)</b> 的概念，它是用來描述兩個集合的成員之間的特殊對應關係，所以為了說明函數的概念，我也會順便介紹一些基礎的集合論觀念。
				</p>
				
				<h3>集合</h3>
				
				<div class="subsection">
					<p>
					什麼是<b>集合 (set)</b>？簡單地說，只要我們任意地蒐集一堆東西，就可以形成一個集合。我們通常用 '$\{\}$' 來表示一個集合，並將所有被蒐集進某一個集合內的東西寫在 '$\{\}$' 之中，然後用 '$,$' 將個別的東西分隔開來。比如說，$\{1,2,3,4,5\}$就是一個蒐集了 1-5 這五個阿拉伯數字的集合，而 $\{(A&rarr;B), (C&and;(D&or;B)), (&not;B), (A)\}$ 則是一個蒐集了 '$A&rarr;B$'、'$C&and;(D&or;B)$'、'$&not;B$'、'$A$' 這四個語句的集合。
					</p>
					<p>
					集合能夠蒐集的東西沒有任何限制，無論是抽象的或具體的事物，都可以被蒐集到某個集合之中，集合之中甚至可以蒐集其它的集合。因為集合可以聚集任意數量的任何東西，所以當我們要談論一堆東西的時候，集合就是一個很方便的概念工具。比如說，當我們要談所有自然數（所有 $&ge;0$ 的整數）的時候，因為自然數有無限多個，我們不可能一一指出來談，但有了集合之後，我們就可以直接談論自然數的集合。
					</p>
					<p>
					既然集合是在蒐集了任意一堆東西後所形成的，我們就說那些被一個集合蒐集起來的東西是那個集合的<b>成員 (member)</b>。比如說，'$1$'、'$2$'、'$3$'、'$4$'、'$5$' 都是 $\{1,2,3,4,5\}$ 這個集合的成員。讓我們用大寫的希臘字母（如 '$\&Gamma;$'、'$\&Delta;$'、'$\&Theta;$' 等）來表示一個集合（必要時可加上數字下標），並且令 $\{1,2,3,4,5\}=\&Gamma;$，我們就可以用 '$1&isin;\&Gamma;$' 來表示 $1$ 是 $\&Gamma;$ 這個集合的成員，我們將它讀作「$1$ 屬於 $\&Gamma;$」。
					</p>
				</div>
				
				<h3>函數</h3>
				
				<div class="subsection">
					<p>
					簡單說明過集合與其成員間的關係後，現在要說明什麼是函數。前面說，函數是用來描述兩個集合的成員之間的特殊對應關係，那這個特殊對應關係是什麼呢？這個特殊的對應關係是這樣的：當我們說 '$\sc{f}$' 是一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數時，意味著以下兩件事：<b>一、$\&Gamma;$ 中的每一個成員都會在 $\&Delta;$ 中找到一個對應的成員；二、$\&Gamma;$ 中的每一個成員，都只會在 $\&Delta;$ 中找到一個對應的成員。</b>我們通常會將「$\sc{f}$ 是一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數」寫作 '$\sc{f}\：\&Gamma;&rarr;\&Delta;$'。
					</p>
					<p>
					換言之，一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數，就是一個以 $\&Gamma;$ 的成員為輸入，並且以 $\&Delta;$ 的成員為輸出的操作程序。若我們以 '$x$' 來代表 $\&Gamma;$ 中的成員，以 '$y$' 來代表 $\&Delta;$ 中的成員，當 $\sc{f}$ 是一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數時，只要從 $\&Gamma;$ 當中挑任何一個 '$x$' 出來並輸入 '$\sc{f}$' 這個函數之中，這個函數就會輸出一個 $\&Delta;$ 中成員 '$y$'，而且只會輸出一個。
					</p>
					<p>
					舉例來說，自然數加法中的 '$&plus;1$' 就是一個從自然數的集合到自然數的集合的函數，對任何自然數的成員 '$x$' 來說，只要將它輸入 $+1$ 這個函數之中（其實就是對 $x$ 做 $+1$ 的操作），就會輸出一個自然數的成員（$x+1$），而且一個輸入一定只會有一個輸出。比如說，$1$ 是自然數的成員，只要我們把 $1$ 輸入 $+1$ 的函數之中，我們就會得到 $2$ 這個輸出，而且只會得到 $2$ 這個輸出；$2$ 也是自然數的成員，只要我們把 $2$ 輸入 $+1$ 這個函數，我們就會得到 $3$ 這個輸出，而且只會得到 $3$ 這個輸出。（如圖一）
					</p>
					<svg height="150">
						<text x="30" y="12">&#x2115;</text>
						<ellipse cx="70" cy="75" rx="40" ry="74" />
						<text x="67" y="30">0
							<tspan x="67" y="50">1</tspan>
							<tspan x="67" y="70">2</tspan>
							<tspan x="67" y="90">3</tspan>
							<tspan x="67" y="110">4</tspan>
							<tspan x="69" y="130">&vellip;</tspan>
						</text>
						<text x="360" y="12">&#x2115;</text>
						<ellipse cx="400" cy="75" rx="40" ry="74" />
						<text x="397" y="20">0
							<tspan x="397" y="40">1</tspan>
							<tspan x="397" y="60">2</tspan>
							<tspan x="397" y="80">3</tspan>
							<tspan x="397" y="100">4</tspan>
							<tspan x="397" y="120">5</tspan>
							<tspan x="399" y="140">&vellip;</tspan>
						</text>
						<polyline points="80,25 390,35 385,31 384.5,39 390,35" />
						<polyline points="80,45 390,55 385,51 384.5,59 390,55" />
						<polyline points="80,65 390,75 385,71 384.5,79 390,75" />
						<polyline points="80,85 390,95 385,91 384.5,99 390,95" />
						<polyline points="80,105 390,115 385,111 384.5,119 390,115" />
						<path d="M100 125 Q155 140 210 140 L206 137 L206 143 L210 140" />
						<text x="145" y="135">輸入</text>
						<path d="M250 140 Q320 140 370 125 L366 123 L368 129 L370 125" />
						<text x="290" y="134">輸出</text>
						<text x="220" y="145">+1</text>
						<text x="450" y="145">【圖一】</text>
					<p>
					再舉一個例子來說，我們平時搭乘的電梯也是一個函數，當你輸入一個電梯樓層的按鈕，電梯就會以「到達對應的樓層」為輸出。你按下「3樓」的按鈕作為輸入，電梯就會以「到達3樓」為輸出；你按下「6樓」的按鈕作為輸入，電梯就會以「到達6樓」為輸出。每一個樓層按鈕的輸入都會對應到一個「到達樓層」的輸出，而且每一個樓層按鈕的輸入都只會對應到一個「到達樓層」的輸出。按下「3樓」的按鈕，電梯就只會到達3樓，而不會到達其它樓層。
					</p>
					<p>
					函數是一個輸入到輸出的操作，有輸入就一定要有輸出，而且每個輸入都一定只能有一個輸出。但函數的輸入可以不只是「一個東西」，有些函數也可以輸入「一組東西」。比如說，前面提到的 '$+1$' 是一個每次都只能輸入「一個東西」的函數，但四則運算中的 '$+$' 就必須同時輸入兩個數字才能得到一個輸出。如果我們只對 '$+$' 輸入一個數字，那不論是 '$2+$' 或 '$+2$'，都不會有任何輸出，唯有同時輸入兩個數字時，比如說 '$1+2$' 或 '$0+1$'，我們才能分別得到 '$3$' 和 '$1$' 這兩個輸出。（如圖二）
					</p>
					<svg height="200">
						<text x="60" y="12">&#x2115;</text>
						<ellipse cx="90" cy="50" rx="30" ry="45" />
						<text x="86" y="25">0
							<tspan x="86" y="45">1</tspan>
							<tspan x="86" y="65">2</tspan>
							<tspan x="88" y="85">&vellip;</tspan>
						</text>
						<text x="60" y="200">&#x2115;</text>
						<ellipse cx="90" cy="150" rx="30" ry="45" />
						<text x="86" y="125">0
							<tspan x="86" y="145">1</tspan>
							<tspan x="86" y="165">2</tspan>
							<tspan x="88" y="185">&vellip;</tspan>
						</text>
						<path d="M100 20 C150 30 150 95 100 120" /><path d="M100 20 C160 32 160 110 100 140" /><path d="M100 20 C170 34 170 125 100 160" />
						<path d="M80 40 C50 45 50 95 80 120" /><path d="M80 40 C40 50 40 110 80 140" /><path d="M80 40 C30 55 30 125 80 160" />
						<path d="M100 60 C110 65 110 115 100 120" /><path d="M100 60 C120 70 120 130 100 140" /><path d="M100 60 C130 75 130 145 100 160" />
						<text x="170" y="110" style="font-size:40px;">&rArr;</text>
						<text x="205" y="12">&#x2115;&times;&#x2115;</text>
						<ellipse cx="265" cy="100" rx="40" ry="99" />
						<text x="408" y="12">&#x2115;</text>
						<ellipse cx="440" cy="100" rx="40" ry="99" />
						<text x="248" y="25">(0,0)
							<tspan x="248" y="40">(0,1)</tspan>
							<tspan x="248" y="55">(0,2)</tspan>
							<tspan x="263" y="70">&vellip;</tspan>
							<tspan x="248" y="85">(1,0)</tspan>
							<tspan x="248" y="100">(1,1)</tspan>
							<tspan x="248" y="115">(1,2)</tspan>
							<tspan x="263" y="130">&vellip;</tspan>
							<tspan x="248" y="145">(2,0)</tspan>
							<tspan x="248" y="160">(2,1)</tspan>
							<tspan x="248" y="175">(2,2)</tspan>
							<tspan x="263" y="190">&vellip;</tspan>
						</text>
						<text x="436" y="30">0
							<tspan x="436" y="60">1</tspan>
							<tspan x="436" y="90">2</tspan>
							<tspan x="436" y="120">3</tspan>
							<tspan x="436" y="150">4</tspan>
							<tspan x="438" y="180">&vellip;</tspan>
						</text>
						<path d="M280 20 L430 25 L426 22 L426 28 L430 25" />
						<path d="M280 35 L430 52 L427 49 L426 55 L430 52" />
						<path d="M280 50 L430 80 L427 77 L426 82 L430 80" />
						<path d="M280 80 L430 60 L426 57 L427 63 L430 60" />
						<path d="M280 95 L430 86 L426 83 L427 89 L430 86" />
						<path d="M280 110 L430 111 L427 108 L427 114 L430 111" />
						<path d="M280 140 L430 91 L427 90 L428 94 L430 91" />
						<path d="M280 155 L430 118 L427 116 L428 121 L430 118" />
						<path d="M280 170 L430 147 L427 145 L428 150 L430 147" />
						<text x="345" y="200">+</text>
						<path d="M288 180 Q310 195 340 195 L338 193 L338 197 L340 195" />
						<path d="M362 195 Q395 195 416 180 L413 180 L415 183 L416 180" />
						<text x="305" y="187">輸入</text>
						<text x="370" y="187">輸出</text>
						<text x="480" y="199">【圖二】</text>
					</svg>
					<p>
					因此，根據一個函數必須輸入多少東西才能得到輸出，我們將函數區分成幾元的函數。必須輸入一個東西的函數被稱為<b>一元</b>函數，必須輸入兩個東西的函數被稱為<b>二元</b>函數，必須輸入三個東西的函數，就被稱為<b>三元</b>函數，以此類推。
					</p>
				</div>
				
				<h3>真值函數</h3>
				
				<div class="subsection">
					<p>
					簡單介紹過集合和函數這兩個概念後，我們就要來談<b>真值函數</b>了。我在這一小節的最開頭提到：語句邏輯中每一個以某個語句連接詞作為主要連接詞的語句，都是一個真值函數。這段話的意思是：當我們以語句的<b>真值 (truth value)</b> 作為輸入時，我們都會得到一個語句的真值作為輸出。
					</p>
					<p>
					舉例來說，'$&alpha;&and;&beta;$' 是一個以 '$&and;$' 作為主要連接詞，將 '$&alpha;$' 和 '$&beta;$' 這兩個言句連接起來的連言句。根據連言句的真值表，我們知道：
						<ul class="tight">
							<li>當 '$&alpha;$' 為真、'$&beta;$' 為真時，'$&alpha;&and;&beta;$' 為真；</li>
							<li>當 '$&alpha;$' 為真、'$&beta;$' 為假時，'$&alpha;&and;&beta;$' 為假；</li>
							<li>當 '$&alpha;$' 為假、'$&beta;$' 為真時，'$&alpha;&and;&beta;$' 為假；</li>
							<li>當 '$&alpha;$' 為假、'$&beta;$' 為假時，'$&alpha;&and;&beta;$' 為假。</li>
						</ul>
					如果把 '$&alpha;&and;&beta;$' 中的 '$&alpha;$' 和 '$&beta;$' 看成是可以輸入真假值的兩個位置，那麼 '$&alpha;&and;&beta;$' 就可以被看成是一個函數：只要在 '$&alpha;$' 和 '$&beta;$' 的位置分別填入真或假，那 '$&alpha;&and;&beta;$' 就會輸出一個真假值。比如說，在 '$&alpha;$' 的位置輸入「真」，在 '$&beta;$' 的位置輸入「真」，'$&alpha;&and;&beta;$' 就會輸出「真」；在 '$&alpha;$' 的位置輸入「假」，在 '$&beta;$' 的位置輸入「真」，'$&alpha;&and;&beta;$' 就會輸出假；……以此類推。
					</p>
					<p>
					由於每一個語句邏輯中的語句都只有「真」、「假」兩種可能性，因此我們可以把這兩種可能性蒐集進一個集合裡，
					</p>
				</div>
			</div>
		</div>
	</div>
	<script src="https://isaacstn.github.io/script/jquery-3.5.0.min.js"></script>
	<script src="https://isaacstn.github.io/script/jqmath-etc-0.4.6.min.js"></script>
	<script src="note.bubble.v1.1.js"></script>
</body>
