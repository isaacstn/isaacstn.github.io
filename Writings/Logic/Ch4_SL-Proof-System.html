<!DOCTYPE html>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xml:lang="en-US" lang="en-US">

<head>
	<meta charset="utf-8"/>
	
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
	<script src="https://isaacstn.github.io/script/jqmath-etc-0.4.6.min.js"></script>
	<script src="https://isaacstn.github.io/script/note.bubble.v1.js"></script>

	<!--fonts-->
	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/Computer-Modern/serif/cmun-serif.css"/><!--CMU Serif-->
	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/STIXGeneral/STIXGeneral.css"/><!--STIXGeneral-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/FelipaFraktur/FelipaFraktur.css"/><!--Felipa,Unifraktur-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/NotoSerifTC/NotoSerifTC.css"/><!--Noto Serif TC-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/AdobeTC/AdobeTC.css"/><!--Adobe TC-->
	
	<!--styles-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_pagestyle_v1.css"/><!--pagestyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_titlestyle_v1.css"/><!--titlestyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_docstyle_v1.3.css"/><!--docstyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_liststyle_v1.css"/><!--liststyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_tablestyle_v1.css"/><!--tablestyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/jqmath-0.4.3.css"/><!--jqmath-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/jqmath-0.4.3-math.css"/><!--jqmath-->

	<style>
	h1::before {
		counter-increment:chapter 4;
	}
	div#main {
		counter-reset:page 99;
	}
	</style>

	<title>Ch4_SL-Proof-System</title>
</head>

<body>
	<div id="main">
		<div class="chapter" id="Proof-System">
			<h1>語句邏輯的證明系統</h1>
			<p>
			在之前的兩個章節裡，我說明了在語句邏輯中的語意其實就是語句的真假：我講解了語句邏輯中的語句的真假要如何被決定；我也說明了，根據語句的真假，我們可以看出語句有哪些邏輯性質，也可以看出語句之間有什麼邏輯關係；最後，我也說明了如何利用歸謬法和語句間的邏輯關係與語句的邏輯特性來判斷一個論證是否有效。
			</p>
			<p>
			然而，光會判斷一個論證是否有效並不足夠，畢竟很多時候我們是要自己想辦法去證明一些什麼結論，為此，我們就必須去尋找一些可以支持該結論成立的理由（也就是前提）。根據前一章所教的歸謬法，我們只能在知道一個論證的<b>前提</b>和<b>結論</b>分別是什麼的情況下，去判斷那個論證是否有效，卻不能在只有結論的情況下，去找出能夠恰當支持結論的前提（也就是能夠有效地推論出結論的前提）。
			</p>
			<p>
			此外，即使在我們已經事先知道一個論證的前提和結論的情況下，可以利用歸謬法來判斷那些前提是否可以有效地推論出結論，我們所知道的也只是前提和結論之間的語意關係而已。或者說得更清楚些：我們透過歸謬法所知道的，就只是那些前提<b>確實</b>可以有效地推論出結論，但我們卻不知道那些前提<b>如何</b>可以有效地推論出結論。換言之，我們只是知其然不知其所以然。
			</p>
			<p>
			而本章所要介紹的證明系統，既可以幫助我們瞭解要如何從一些前提推論出另一些結論，當我們需要為某些主張提供論證支持時，這個證明系統也可以幫助我們去尋找能夠有效地推論出那些結論的前提。
			</p>
			
			<div class="section" id="4-1">
				<h2>證明系統的基本概念</h2>
				<p>
				邏輯這門學科被歸類在<b>形式科學 (formal science)</b> 這個學門領域之中，因為它所研究的對象就是各種形式語言。什麼是形式語言？簡單說，一個形式語言就是由各種符號所構成，並且包含了這些符號的各種操作規則。
				</p>
				<p>
				比如說，當我們在第一章學習語句邏輯的語言時，有學到語句邏輯中可以使用的符號有哪些，並且學到如何利用完構式的構成規則來將語句邏輯中的符號組合成合法的表達式，那些完構式的構成規則就是針對符號的操作規則。然而完構式的規則只是告訴我們可以如何從簡單的符號組合出複雜的表達式，卻不能告訴我們這些表達式之間可以怎麼互相轉換，而證明系統就提供了表達式之間的轉換規則。
				</p>
				
				<div class="subsection" id="4-1-1">
					<h3>有效推論的形式</h3>
					<p>
					為什麼這樣的語言會被稱作是一個<b>形式</b>語言？這是因為這些關於符號的操作規則在乎的就只是符號的長像，而不在乎這些符號究竟表達了什麼內容。舉例來說：
					</p>
					<ol class="prf">
						<li>如果嘉義在台南的南邊，則台南在嘉義的北邊。</li>
						<li>嘉義在台南的南邊。</li>
						<li>台南在嘉義的北邊。</li>
					</ol>
					<p>
					令 '$A$' 代表「嘉義在台南的南邊」，令 '$B$' 代表「台南在嘉義的北邊」，則這個論證可被翻譯至語句邏輯的語言中：
					</p>
					<ol class="prfp">
						<li>$A&rarr;B$</li>
						<li>$A$</li>
						<li>$B$</li>
					</ol>
					<p>
					我們再來看一個不一樣的論證：
					</p>
					<ol class="prf">
						<li>如果科科這學期 all pass，則豬會飛。</li>
						<li>科科這學期 all pass。</li>
						<li>豬會飛。</li>
					</ol>
					<p>
					令 '$C$' 代表「科科這學期 all pass」，令 '$D$' 代表「豬會飛」，則這個論證可被翻譯至語句邏輯的語言中：
					</p>
					<ol class="prfp">
						<li>$C&rarr;D$</li>
						<li>$C$</li>
						<li>$D$</li>
					</ol>
					<p>
					讓我們再來看最後一個例子：
					</p>
					<ol class="prf">
						<li>如果電腦的記憶體故障，則電腦不能啟動。</li>
						<li>電腦的記憶體故障。</li>
						<li>電腦不能啟動。</li>
					</ol>
					<p>
					令 '$E$' 代表「電腦的記憶體故障」，令 '$F$' 代表「電腦不能啟動」，則這個論證可被譯譯至語句邏輯的語言中：
					</p>
					<ol class="prfp">
						<li>$E&rarr;F$</li>
						<li>$E$</li>
						<li>$F$</li>
					</ol>
					<p>
					以上一共是三組不同的論證，<i>P1</i>、<i>P2</i> 到 <i>C1</i> 是在論證嘉義和台南這兩個地方的方位關係；<i>P3</i>、<i>P4</i> 到 <i>C2</i> 則是在論證科科這學期 all pass 和豬會不會飛之間的關係；<i>P5</i>、<i>P6</i> 到 <i>C3</i> 則是在論證有關電腦記憶體和開機之間的關係。
					</p>
					<p>
					然而無論這些論證到底在談論什麼不同的議題，當我們把這三組論證分別都翻譯至語句邏輯的語言中時，不難發現這三個論證幾乎長得一模一樣：都是以一個條件句，以及該條件句的前件作為論證的<b>前提</b>，並且以作為前提之一的條件句之後件作為結論。若光從<b>形式</b>上來看的話，這三個論證其實具有一模一樣的形式：
					</p>
					<ol class="pfs">
						<li>$&alpha;&rarr;&beta;$</li>
						<li>$&alpha;$</li>
						<li>$&beta;$</li>
					</ol>
					<p>
					我們可以進一步用歸謬法判斷看看這個推論形式是不是一個有效的推論形式：
					</p>
					<div class="tree2">
						<span>$&alpha;&rarr;&beta;$</span><br/>
						<span>$&alpha;$</span><br/>
						<span>$&not;&beta;$</span>
						<svg width="200px"><path d="M100 1 L50 23"/><path d="M100 1 L150 23"/></svg>
						<div>
							<svg class="back"><circle cx="50" cy="12" r="11"/></svg>
							<span>$&alpha;$</span><br/>
							<span>$&not;&beta;$</span><br/>
							<svg class="back"><ellipse cx="50" cy="12" rx="20" ry="11"/></svg>
							<span>$&not;&alpha;$</span><br/>
							<span>&cross;</span>
						</div>
						<div>
							<span>$&alpha;$</span><br/>
							<svg class="back"><ellipse cx="50" cy="12" rx="20" ry="11"/></svg>
							<span>$&not;&beta;$</span><br/>
							<svg class="back"><circle cx="50" cy="12" r="11"/></svg>
							<span>$&beta;$</span><br/>
							<span>&cross;</span>
						</div>
					</div>
					<p>
					由於所有分支都會產生矛盾，這表示歸謬假設不可能成立，也就是說，當論證的前提（'$&alpha;&rarr;&beta;$' 和 '$&alpha;$'）都為真時，結論（'$&beta;$'）不可能為假。因此這是有效的推論形式。
					</p>
					<p>
					證明這是一個有效的推論形式是一件非常重要的事情。比如說，如果我們今天只是檢查 <i>P1'</i>、<i>P2'</i> 到 <i>C1'</i> 這個推論是不是一個有效推論，並在最後發現它是一個有效推論。我們最多就是證明了，從 '$A&rarr;B$' 和 '$A$' 這兩個前提可以有效地推論出 '$B$' 而已，卻不能證明具有相同形式的論證 <i>P3'</i>、<i>P4'</i> 到 <i>C2'</i>，以及 <i>P5'</i>、<i>P6</i> 到 <i>C3'</i> 這些論證是否也是有效論證。
					</p>
					<p>
					然而，如果我們可以直接確定從 '$&alpha;&rarr;&beta;$' 和 '$&alpha;$' 這兩個前提到 '$&beta;$' 這個結論的<b>推論形式</b>是有效的，我們就能不只能肯定 <i>P1'</i>、<i>P2'</i> 到 <i>C1'</i> 是有效論證，也能肯定 <i>P3'</i>、<i>P4'</i> 到 <i>C2'</i>，以及 <i>P5'</i>、<i>P6</i> 到 <i>C3'</i> 這些論證也都是有效論證。不只如此，凡是只要同屬於這一形式的任何推論，都可以確定是一個有效論證。比如說：
					</p>
					<ol class="prfp">
						<li>$((A&rarr;B)&and;(A&rarr;(B&rarr;C)))&rarr;(A&rarr;C))$</li>
						<li>$(A&rarr;B)&and;(A&rarr;(B&rarr;C))$</li>
						<li>$A&rarr;C$</li>
					</ol>
					<p>
					這也會是一個有效論證，如果我們將 '$(A&rarr;B)&and;(A&rarr;(B&rarr;C))$ 看成是 '$&alpha;$'，再將 '$A&rarr;C$' 看成是 '$&beta;$'，那就不難看出來，這個論證其實與 '$&alpha;&rarr;&beta;$' 和 '$&alpha;$' 推論出 '$&beta;$' 的論具有相同的形式。
					</p>
					<p>
					換言之，一但我們發現一個有效的<b>推論形式</b>，那我們就能確定任何在形式上相同的推論一定也都是有效的，因此我們不必再理會這些推論所使用到的前提和結論究竟表達了什麼內容，也不必去問這些語句彼此之間的邏輯關係是什麼。只要是根據有效推論形式所規範的符號操作方法操作，一定都會是有效論證。而這些有效的推論形式，就是我們即將要學的證明規則。
					</p>
				</div><!--chap4 sect1 subsect1-->
				
				<div class="subsection" id="4-1-2">
					<h3>證明的定義</h3>
					<p>
					那麼何謂證明？在我們的日常生活中，證明一件事無非就是想辦法找各種道理和證據去支持那件事是成立的。不過在語句邏輯系統中，對證明有一個精準的定義。所謂<b>證明 (proof)</b>就是：
					</p>
					<ol class="numd">
						<li>一組有限數量的語句構成的序列。</li>
						<li>該序列的最後一個語句是這個證明的結論。</li>
						<li>證明中的每一個語句都是：
							<ol class="llt">
								<li>前提語句；或者，</li>
								<li>由位在前面的語句，根據有效推論規則推論出來的語句。</li>
							</ol></li>
					</ol>
					<p>
					也就是說，每一個語句邏輯的證明都會長得像下面這個樣子：
					</p>
					<table class="pfs">
						<tr><td></td><td>前提語句 1</td></tr>
						<tr><td></td><td>前提語句 2</td></tr>
						<tr><td></td><td>前提語句 3</td></tr>
						<tr class="ellip"><td></td><td></td></tr>
						<tr><td></td><td>語句</td></tr>
						<tr><td></td><td>語句</td></tr>
						<tr><td></td><td>語句</td></tr>
						<tr class="ellip"><td></td><td></td></tr>
						<tr><td></td><td>結論</td></tr>
					</table>
					<p>
					雖然依照習慣，我們都會把論證使用到的前提放在論證的最前面，但就定義上來說，只要不是最後一個語句，論證的前提可以被放在論證中的任何一個位置。
					</p>
					<p>
					不過要注意的是，因為根據前述證明的定義，論證中的所有語句都只有兩種來源：(a) 它本身是一個前提語句；(b) 它是由<b>位在它前面</b>的語句根據有效推論規則推論出來的語句。那麼，每個論證中的第一個語句前面不可能會有其它語句，因此它不可能是由位在它前面的語句根據有效推論規則推論出來的，因此論證的第一個語句就必須是前提語句。
					</p>
					<p>
					給定證明的定義，那麼結論的來源也只會有兩個：(a) 它本身前提是一個前提語句；(b) 它是由位在它前面的語句，根據有效推論規則推論出來的。如果一個證明的結論本身就是一個前提語句，那這個結論當然可以從前提有效地推論出來，因為任何語句都能夠有效地推論出自己。
					</p>
					<p>
					相對地，如果一個證明的結論是由位在它前面的語句根據有效推論規則推論出來的，那麼能夠有效地推論出結論的那些語句也只有兩種來源：它本身就是前提，或者也是由位在它前面的其它語句根據有效推論規則推論而來的。如果那些能夠有效推論出結論的語句本身是前提語句的話，那結論當然能夠從前提有效地推論出，如果那些語句本身不是前提語句，那就是從位在它前面的其它語句推論出來的……。
					</p>
					<p>
					然而根據定義，一個證明是能是由有限多個語句所構成的，因此結論的來源不可能無限後退，這表示，最後它一定是從一些能夠從前提本身有效地推論出來的語句所推論出來的。由於有效推論關係是有傳遞性的關係（也就是說，當一組語句 $\&Gamma;$ 可以推論出另一組語句 $\&Delta;$，而 $\&Delta;$ 這組語句又可以有效地推論出結論時，那 $\Gamma;$ 這組語句就可以推論出結論），所以對任何一個證明而言，其結論根據定義一定可以從前提有效地推論出來。
					</p>
				</div><!--chap4 sect1 subsect2-->
			</div><!--chap4 sect1-->
			
			<div class="section" id="4-2">
				<h2>證明可用的推論規則</h2>
				<p>
				既然重點在於<b>有效推論規則</b>，我們就開始介紹語句邏輯系統中的有效推論規則有哪些。我要介紹的推論規則一共有十八條，其中有八條規則屬於<b>蘊涵規則</b>，另外有十條規則是<b>等值規則</b>。最後，我還會介紹一條後設規則——<b>條件證法</b>。
				</p>
				<p>
				在介紹推論規則的時候我會用到 '$&vdash;$' 這個符號，用來表示「……可以證明……」。比如當我寫 '$A&rarr;B, A&vdash;B$' 的時候，我的意思就是指 '$A&rarr;B$' 和 '$A$' 這兩個語句可以共同證明 '$B$'。不過因為推論規則要呈現的是有效推論的<b>形式</b>，所以在寫規則時我不會直接用實際的語句去寫，而是用可以<b>代表任意語句</b>的符號如 '$&alpha;$'、'$&beta;$' 等。
				</p>
				<p>
				因此當我寫 '$&alpha;&rarr;&beta;,&alpha;&vdash;&beta;$' 時，我的意思是：任何具有 '$&alpha;&rarr;&beta;$' 和 '$&alpha;$' 這兩個形式的語句，都可以共同證明具有 '$&alpha;$' 這個形式的語句。也就是說，只要將規則當中的 '$&alpha;$'、'$&beta;$' 等符號都用一個實際的語句去代換，就可以得到一個有效的證明。
				</p>
				<p>
				不過要注意的是，在用實際的語句去代換推論規則中的 '$&alpha;$'、'$&beta;$' 等符號時，請一定要用一樣的語句來代換一樣的符號。比如說，當我用 '$A&and;B$' 來代換 '$&alpha;&rarr;&beta;$' 中的 '$&alpha;$'，並用 '$C$' 來代換 '$&alpha;&rarr;&beta;$' 中的 '$&beta;$' 時，我就必須同樣用 '$A&and;B$' 來代換逗號右邊的 '$&alpha;$'，並且用 '$C$' 來代換 '$&vdash;$' 右邊的 '$&beta;$'。
				</p>
				
				<div class="subsection" id="4-2-1">
					<h3>蘊涵規則（一）</h3>
					<p>
					顧名思義，蘊涵規則所包含的八條推論規則，都是利用語句之間的蘊涵關係建構出來的規則。第一條蘊涵規則是最常被使用到的規則，也是最普遍存在於不同的證明系統中的規則
					</p>
					<blockquote>
						<p>
						<b>肯定前件律 (<i>modus ponens</i>，簡寫為 MP)</b><br/>
						</p>
						<p>
						$&alpha;&rarr;&beta;,&alpha;&vdash;&beta;$
						</p>
					</blockquote>
					<p>
					根據肯定前件律，但凡我們有一個條件句，而且有條件句的前件時，我們就可以用這兩個語句有效地推論出條件句的後件。比如說：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;B$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>根據 1,2, MP</td></tr>
					</table>
					<p>
					在這個例子裡，我們是用 '$A$' 來代換規則中的 '$&alpha;$'，用 '$B$' 來代換規則中的 '$&beta;$'。我們再看下一個例子：
					</p>
					<table class="prf">
						<tr><td>$(A&and;C)&rarr;B$</td><td>前提</td></tr>
						<tr><td>$A&and;C$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>根據 1,2, MP</td></tr>
					</table>
					<p>
					在這個例子中，我們則是用 '$A&and;C$' 代換規則中的 '$&alpha;$'，用 '$C$' 代換規則中的 '$&beta;$'。
					</p>
					<table class="prf">
						<tr><td>$(A&or;B)&rarr;&not;(A&and;C)$</td><td>前提</td></tr>
						<tr><td>$A&or;B$</td><td>前提</td></tr>
						<tr><td>$&not;(A&and;C)$</td><td>根據 1,2, MP</td></tr>
					</table>
					<p>
					在第三個例子中，我們則是用 '$A&or;B$' 來代換規則中的 '$&alpha;$'，用 '$&not;(A&and;C)$' 代換規則中的 '$&beta;$'。
					</p>
					<p>
					在使用蘊涵規則時必須要注意的是，這些規則都<b>只能</b>適用在<b>完整的語句</b>之上，而不能應用在語句的一部分。比如說以下的推論就是對 MP 規則的<b>錯誤</b>應用：
					</p>
					<table class="prf">
						<tr><td>$(A&rarr;B)&or;C$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>根據 1,2, MP</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&rarr;(B&rarr;C)$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>前提</td></tr>
						<tr><td>$C$</td><td>根據 1,2, MP</td></tr>
					</table>
					<p>
					這些例子裡都只有把 MP 規則套用到語句中的一部分而已，這都是錯誤的用法。MP 規則必須用在<b>完整的條件句</b>上，以上面這兩個錯誤應用的範例來看，第一組的問題在於前提 (1) 根本不是條件句；第二組的問題在於，儘管前提 (1) 是條件句（其主要連接詞是 '$&rarr;$'），但前提 (2) 並不是前提 (1) 的<b>前件</b>。
					</p>
					<p>
					我們接著來看第二條蘊涵規則，這條蘊涵規則和 MP 經常會成對出現，這條規則的名稱叫做：
					</p>
					<blockquote>
						<p>
						<b>否定後件律 (<i>modus tollens</i>，簡寫為 MT)</b>
						</p>
						<p>
						$&alpha;&rarr;&beta;,&not;&beta;&vdash;&not;&alpha;$
						</p>
					</blockquote>
					<p>
					根據肯定後件律，但凡我們有一個條件句，同時有該條件句之後件的否定句，我們就可以用這兩個語句有效地推論出條件句之前件的否定句。舉例來說：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;B$</td><td>前提</td></tr>
						<tr><td>$&not;B$</td><td>前提</td></tr>
						<tr><td>$&not;A$</td><td>根據 1,2, MT</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$&not;C$</td><td>前提</td></tr>
						<tr><td>$&not;(A&and;B)$</td><td>根據 1,2, MT</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&rarr;(B&or;C)$</td><td>前提</td></tr>
						<tr><td>$&not;(B&or;C)$</td><td>前提</td></tr>
						<tr><td>$&not;A$</td><td>根據 1,2, MT</td></tr>
					</table>
					<p>
					在這三個例子裡，我們都是用一個條件句，以及該條件句後件的否定句，共同推論出條件句前件的否定。綜合 MP 和 MT 這兩條規則，我們可以知道，給定一個條件句，我們可以從條件句的<b>前件</b>推論出條件句的<b>後件</b> (MP)，也可以從條件句<b>後件的否定</b>推論出條件句<b>前件的否定</b>。要熟悉這兩條規則，可以記得以下兩句口訣：
					</p>
					<ul class="song">
						<li>肯定前件就能肯定後件。</li>
						<li>否定後件就能否定前件。</li>
					</ul>
					<p class="ind">
					要注意的是，條件句所允許的規則只有<b>肯定前件律</b>和<b>否定後件律</b>。也就是說，給定一個條件句的後件，我們不能有效地推論出條件句的後件，給定條件句前件的否定，我們也不能推論出條件句後件的否定。舉例來說，給定了以下這個條件句：
					</p>
					<ol class="lltd song">
						<li>如果嘉義市在台中市的北邊，則嘉義市在台南市的北邊。</li>
					</ol>
					<p>
					這個條件句當然是真的，畢竟台中市已經在台南市的北邊了，所以如果嘉義市比台中市還要更北邊，那嘉義市當然也會在台南市的北邊。可是我們知道事實上：
					</p>
					<ol class="lltd song">
						<li>嘉義市不在台中市的北邊。</li>
					</ol>
					<p>
					也就是說，a 這個條件的前件是假的。但這兩個語句並不能共同有效推論出：
					</p>
					<ol class="lltd song">
						<li>嘉義市不在台南市的北邊。</li>
					</ol>
					<p>
					畢竟我們知道，事實上嘉義市就在台南市的北邊。這個例子說明了，即使我們可以否定一個條件句的前件，我們也不能有效地推論出條件句後件的否定。
					</p>
					<p>
					如果不放心的話，我們可以把以上推論給形式化。令 '$A$' 代表「嘉義市在台中市的北邊」，令 '$B$' 代表「嘉義市在台南市的北邊」。則由語句 a、b 推論出 c 的論證如下：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;B$</td><td>前提 a</td></tr>
						<tr><td>$&not;A$</td><td>前提 b</td></tr>
						<tr><td>$&not;B$</td><td>根據 1,2, 規則？</td></tr>
					</table>
					<p>
					接下來，我們可以用歸謬法來檢查這是不是一個有效推論：
					</p>
					<div class="tree2">
						<span>$A&rarr;B$</span><br/>
						<span>$&not;A$</span><br/>
						<span>$B$</span><br/>
						<svg width="200px"><path d="M100 1 L50 23"/><path d="M100 1 L150 23"/></svg>
						<div>
							<span>$&not;A$</span><br/>
							<span>$B$</span><br/>
							<span>$&not;A$</span><br/>
							<span>&check;</span>
						</div>
						<div>
							<span>$&not;A$</span><br/>
							<span>$B$</span><br/>
							<span>$B$</span><br/>
							<span>&check;</span>
						</div>
					</div>
					<p>
					根據以上的分析，一共有兩個分支可以讓歸謬假設成立，而且這兩個分支都不會產生矛盾。這表示我們有兩種不同的方法可以讓論證的前提全都為真，但依然令論證的結論為假，所以這當然不是一個有效推論。
					</p>
					<p>
					同理，就算我們可以肯定條件句後件為真，也不能據此有效地推論出條件句的前件。繼續以 a 這個條件句為例，我們已經確認過 a 為真，此外我們也知道事實上：
					</p>
					<ol class="lltd song">
						<li>嘉義市在台南市的北邊。</li>
					</ol>
					<p>
					因此我們也肯定了條件句 a 的後件為真，但這兩個語句不能共同推論出：
					</p>
					<ol class="lltd song">
						<li>嘉義市在台中市的北邊。</li>
					</ol>
					<p>
					我們一樣可以先將這個推論形式化：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;B$</td><td>前提 a</td></tr>
						<tr><td>$B$</td><td>前提 d</td></tr>
						<tr><td>$A$</td><td>根據 1,2, 規則？</td></tr>
					</table>
					<p>
					然後再用歸謬法檢查這個推論是不是有效的：
					</p>
					<div class="tree2">
						<span>$A&rarr;B$</span><br/>
						<span>$B$</span><br/>
						<span>$&not;A$</span><br/>
						<svg width="200px"><path d="M100 1 L50 23"/><path d="M100 1 L150 23"/></svg>
						<div>
							<span>$B$</span><br/>
							<span>$&not;A$</span><br/>
							<span>$&not;A$</span><br/>
							<span>&check;</span>
						</div>
						<div>
							<span>$B$</span><br/>
							<span>$&not;A$</span><br/>
							<span>$B$</span><br/>
							<span>&check;</span>
						</div>
					</div>
					<p>
					很明顯這也不是一個有效推論，因為一樣有兩個分支可以不矛盾地令歸謬假設成立。這表示共有兩種不矛盾的方法可以令以上推論的前提全都為真，但仍然令結論為假。
					</p>
					<p>
					以上這兩種錯誤的推論方法其實分別都是有名的<b>形式謬誤</b>，其一為<b>否定前件的謬誤</b>，其二為<b>肯定後件的謬誤</b>。但因為這兩個詞誤和 MP 與 MT 規則十分相像，因此經常被混淆，請務必注意它們與 MP 和 MT 規則的差異！
					</p>
					<p>
					接下來要介紹的規則都是和連言句相關的規則，一個規則規定了可以從什麼語句有效地推論出一個連言句，另一個規則規定了可以從連言句有效地推論出什麼語句。它們分別是：
					</p>
					<blockquote>
						<p>
						<b>連言律 (Laws of Conjunction，簡寫為 Conj.)</b>
						</p>
						<ul class="list">
							<li>$&alpha;,&beta;&vdash;&alpha;&and;&beta;$</li>
							<li>$&alpha;,&beta;&vdash;&beta;&and;&alpha;$</li>
						</ul>
					</blockquote>
					<p>
					以及：
					</p>
					<blockquote>
						<p>
						<b>簡化律 (Laws of Simplification，簡寫為 Simp.)</b>
						</p>
						<ul class="list">
							<li>$&alpha;&and;&beta;&vdash;&alpha;$</li>
							<li>$&alpha;&and;&beta;&vdash;&beta;$</li>
						</ul>
					</blockquote>
					<p>
					根據連言律，每當我們有兩個任意的語句時，例如 '$&alpha;$' 和 '$&beta;$'，我們就可以從這兩個語句有效地推論出這兩個語句合成的連言句 '$&alpha;&and;&beta;$'，而且順序不拘。根據簡化律，每當我們有任意一個連言句 '$&alpha;&and;&beta;$' 的時候，我們都可以從這個連言句有效地推論出任意一個連言項，即 '$&alpha;$' 和 '$&beta;$'。以下是幾個使用<b>連言律</b>的例子：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>前提</td></tr>
						<tr><td>$A&and;B$</td><td>根據 1,2, Conj.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&rarr;C$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>前提</td></tr>
						<tr><td>$(A&rarr;C)&and;B$</td><td>根據 1,2, Conj.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&rarr;B$</td><td>前提</td></tr>
						<tr><td>$&not;(B&harr;(A&or;C))$</td><td>前提</td></tr>
						<tr><td>$(A&rarr;B)&and;&not;(B&harr;(A&or;C))$</td><td>根據 1,2, Conj.</td></tr>
					</table>
					<p>
					可以看到的是，無論兩個語句本身的結構如何複雜，只要是我們在推論的任何過程中所得到的兩個語句，都可以用連言律將兩者合成一個連言句。底下則是幾個使用簡化律規則的範例：
					</p>
					<table class="prf">
						<tr><td>$A&and;B$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>根據 1, Simp.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&and;B$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>根據 1, Simp.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&rarr;B)&and;&not;(B&harr;(A&or;C))$</td><td>前提</td></tr>
						<tr><td>$&not;(B&harr;(A&or;C))$</td><td>根據 1, Simp.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&rarr;B)&and;&not;(B&harr;(A&or;C))$</td><td>前提</td></tr>
						<tr><td>$A&rarr;B$</td><td>根據 1, Simp.</td></tr>
					</table>
					<p>
					從這幾個例子可以看出來，只要有一個連言句，就可以用簡化律有效地推論出連言句的任一個連言項。從 '$(A&rarr;B)&and;&not;(B&harr;(A&or;C))$' 可以推論出 '$A&rarr;B$' 也可以推論出 '$&not;(B&harr;(A&or;C))$'；從 '$A&and;B$' 可以推論出 '$A$' 也可以推論出 '$B$'。
					</p>
					<p>
					接下來要介紹的推論規則是和選言句有關的推論規則，這個推論規則叫做<b>添加律 (Laws of Addition)</b>：
					</p>
					<blockquote>
						<p>
						<b>添加律 (Laws of Addition，簡寫為 Add.)</b>
						</p>
						<ul class="list">
							<li>$&alpha;&vdash;&alpha;&or;&beta;$</li>
							<li>$&beta;&vdash;&alpha;&or;&beta;$</li>
						</ul>
					</blockquote>
					<p>
					根據添加律，只要在證明的過程中得到任何一個語句，我們都可以有效地推論出一個包含了該語句的選言句，無論該語句是被放在選言句的左項還是右項都可以。底下來看一些添加律實際被使用的範例：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$A&or;B$</td><td>根據 1, Add.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$B&or;A$</td><td>根據 1, Add.</td></tr>
					</table>
					<p>
					從這兩個例子可以看到，同樣是給定語句 '$A$'，我們不但可以有效地推論出 '$A&or;B$'，也可以有效地推論出 '$B&or;A$'。這意味著當我們要用添加律從任何語句推論出一個選言句時，用來推論的那個語句無論放在選言句的左邊還是右邊都可以。
					</p>
					<p>
					此外，添加律還有一個很有特色，而且非常重要的特性，就是被添加上去的語句可以是<b>任何</b>語句，包括結構十分複雜的語句也行。比如：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$A&or;(B&and;C)$</td><td>根據 1, Add.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$A&or;(B&and;&not;(C&rarr;A))$</td><td>根據 1, Add.</td></tr>
					</table>
					<p>
					因為添加律可以在前提之上添加<b>任何</b>語句，所以當然也可以添加前提本身，例如：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$A&or;A$</td><td>根據 1, Add.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$((A&and;B)&rarr;C)&or;((A&and;B)&rarr;C)$</td><td>根據 1, Add.</td></tr>
					</table>
					<p>
					我們當然也可以將前提的否定句添加上去，如：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$A&or;&not;A$</td><td>根據 1, Add.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$((A&and;B)&rarr;C)&or;&not;((A&and;B)&rarr;C)$</td><td>根據 1, Add.</td></tr>
					</table>
					<p>
					因為添加律可以在前提之上添加任何語句，搭配上我們之後要學到的其它與選言語句有關的規則，就會變得非常有用，不過這先留待以後再說。目前已經學到了五個蘊涵規則，我們就先用這五個蘊涵規則來練習如何建構證明，以下示範幾個證明的建構：
					</p>
					<div class="quiz">
						<ol class="pfq">
							<li>$A&or;B$</li>
							<li>$(A&or;B)&rarr;C$</li>
							<li>$C&rarr;&not;A$</li>
							<li>$&not;A$</li>
						</ol>
						<ol class="pfq">
							<li>$A&rarr;(C&and;D)$</li>
							<li>$(C&or;B)&rarr;F$</li>
							<li>$A$</li>
							<li>$F$</li>
						</ol>
						<ol class="pfq">
							<li>$A&and;B$</li>
							<li>$B&rarr;(C&and;&not;D)$</li>
							<li>$A&rarr;D$</li>
							<li>$&not;A$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$&not;&not;A$</li>
							<li>$B&rarr;&not;A$</li>
							<li>$D$</li>
							<li>$(&not;B&or;C)&and;D$</li>
						</ol>
						<ol class="pfq">
							<li>$&not;A&rarr;C$</li>
							<li>$&not;&not;A&rarr;(B&and;D)$</li>
							<li>$A&and;&not;C$</li>
							<li>$B&or;((D&rarr;E)&or;&not;F)$</li>
						</ol>
					</div>
					<p>
					以上幾個例題中的 <i>P1</i>、<i>P2</i>、<i>P3</i> 等，就是題目提供的前提，而 <i>C</i> 則是我們必須試圖用前提證明出來的結論。所有的前提語句都可以直接拿來做推論，但我們也只能用這些前提語句做推論。因此，建構證明的技巧就是從這些前提語句和結論語句之間的關係，去推斷要用什麼前提和推論規則來得到結論。以下先示範例題 (1) 的證明：
					</p>
					<table class="prf">
						<tr><td>$A&or;B$</td><td>前提</td></tr>
						<tr><td>$(A&or;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$C&rarr;&not;A$</td><td>前提</td></tr>
						<tr><td>$C$</td><td>根據 1,2, MP</td></tr>
						<tr><td>$&not;A$</td><td>根據 3,4, MP</td></tr>
					</table>
					<p>
					例題 (1) 要我們用前提論證出來的結論是 '$&not;A$'。'$&not;A$' 顯然和前提 <i>P3</i> 有關，因為它直接出現在 <i>P3</i> 這個條件句的後件當中。有沒有什麼規則是可以讓我們用條件句推論出它的後件的？有，就是 MP 規則。但若要用 MP 規則從 <i>P3</i> 推論出 '$&not;A$'，我們需要 '$C$'，所以接下來看看 '$C$' 有沒有出現在什麼前提中。
					</p>
					<p>
					同樣的，'$C$' 剛好是前提 <i>P2</i> 這個條件句的後件，因此，只要我們可以得到 <i>P2</i> 的前件，我們一樣可以用 MP 規則推論出 '$C$'，很巧地，<i>P2</i> 的前件剛好就是 <i>P1</i>。所以我們可以先用 MP 規則從 <i>P1</i> 和 <i>P2</i> 推論出 <i>P3</i> 的前件，也就是 '$C$'；再用 MP 規則從剛剛推論出來的 '$C$' 和 <i>P3</i> 推論出結論 '$&not;A$'，如此就完成了這個證明的建構。
					</p>
					<p>
					我們接著看看要如何建構出第二個例題要我們做的證明。首先，結論 '$F$' 只有出現在 <i>P2</i> 這個條件句的後件，所以我們只能試著用 MP 從 <i>P2</i> 推論出結論，因此我們需要 <i>P2</i> 的前件 '$C&or;B$'。但是 '$C&or;B$' 本身沒有出現在前提中，所以我們很可能要想辦法先得到 '$C$' 或者得到 '$B$'，再利用 Add. 推論出 '$C&or;B$'。
					</p>
					<p>
					由於 '$B$' 沒有出現在 <i>P2</i> 以外的任何前提中，所以我們只能想辦推論出 '$C$'。'$C$' 剛好是 <i>P1</i> 這個條件句的後件的其中一個連言項，而我們知道，只要有一個連言句，我們就可以利用 Simp. 規則推論出它的任意一個連言項。因此，只要我們可以利用 MP 規則推論出 <i>P1</i> 的後件，就可以進一步用 Simp. 推論出 '$C$'。
					</p>
					<p>
					為了用 MP 規則推論出 <i>P1</i> 的後件，我們必須先得到 <i>P1</i> 的前件 '$A$'，而 <i>P1</i> 的前件剛好就是題目所提供的前提 <i>P3</i>，因此一條從前提通往結論的康莊大道便昭然若揭了，我們便按照剛才的推理將證明建構出來吧：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;(C&and;D)$</td><td>前提</td></tr>
						<tr><td>$(C&or;B)&rarr;F$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$C&and;D$</td><td>根據 1,3, MP</td></tr>
						<tr><td>$C$</td><td>根據 4, Simp.</td></tr>
						<tr><td>$C&or;B$</td><td>根據 5, Add.</td></tr>
						<tr><td>$F$</td><td>根據 2,6, MP</td></tr>
					</table>
					<p>
					接著看第三題，題目要求我們證明的結論是 '$&not;A$'，但 '$&not;A$' 並沒有出現在前提之中，反而是 '$A$' 分別出現在 <i>P1</i> 和 <i>P3</i> 之中。<i>P1</i> 是一個連言句，用 Simp. 只能得到 '$A$' 而非 '$&not;A$'，所以至少目前沒有幫助。而 '$A$' 在 <i>P3</i> 裡是一個條件句的前件，因此只要我們有 <i>P3</i> 後件的否定句，就可以用 MT 規則推論出 '$&not;A$'。
					</p>
					<p>
					<i>P3</i> 的後件是 '$D$'，否定就是 '$&not;D$'，而 '$&not;D$' 剛好是 <i>P2</i> 這一條件句後件的其中一個連言項。因此，只要可以得到 <i>P2</i> 的前件，就可以用 MP 規則推論出 <i>P2</i> 的後件，然後就可以用 Simp. 規則推論出 '$&not;D$'。所以 <i>P2</i> 的前件 '$B$' 就是我們的目標。而 '$B$' 剛好就是 <i>P1</i> 的其中一個連言項，因此只要對 <i>P1</i> 使用 Simp. 規則，就能得到 '$B$'，然後一路推論出結論。所以 (3) 的證明如下：
					</p>
					<table class="prf">
						<tr><td>$A&and;B$</td><td>前提</td></tr>
						<tr><td>$B&rarr;(C&and;&not;D)$</td><td>前提</td></tr>
						<tr><td>$A&rarr;D$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>根據 1, Simp.</td></tr>
						<tr><td>$C&and;&not;D$</td><td>根據 2,4, MP</td></tr>
						<tr><td>$&not;D$</td><td>根據 5, Simp.</td></tr>
						<tr><td>$&not;A$</td><td>根據 3,6, MT</td></tr>
					</table>
					<p>
					剩下的 (4) 和 (5) 兩個例題，就留給各位嘗試自行建構出證明。如果在嘗試建構證明的時候遇到一些困難不知道該怎麼辦時，可以參考我接下來給的提示。如果你想要自己突破難關，那就請略過下一段。
					</p>
					
					<div class="portion def">
						<h5>提示</h5>
						<p>
						例題 (4) 要證明的結論是 '$(&not;B&or;C)&and;D$'，所以要先證明出 '$&not;B&or;C$' 以及 '$D$' 這兩個語句，然後再用 Conj. 將兩者合組成連言句。但 '$&not;B&or;C$' 中的 '$C$' 在前提裡根本沒有出現過，因此可以推測，此處應該是要先試著證明出 '$&not;B$'，再利用 Add. 規則來證明 '$&not;B&or;C$'。
						</p>
						<p>
						例題 (5) 要證明的結論看起來非常複雜，特別是其中的 '$E$' 和 '$F$' 根本就沒有在前提中出現過，不過注意到結論本身是一個選言句，而且選言句的左項是一個簡單的 '$B$'。因此，只要能證明出 '$B$，就可以利用 Add. 把選言句右項給添加進去。記得嗎？添加律可以讓你在已證得的語句旁邊用 '$&or;$' 添加<b>任何</b>語句，所以不要擔心，大膽地加上去吧！
						</p>
					</div>
				</div><!--chap4 sect2 subsect1-->
				
				<div class="subsection" id="4-2-2">
					<h3>蘊涵規則（二）</h3>
					<p>
					最後要介紹的三個規則分別是<b>選言三段論 (Disjunctive Syllogism)</b>、假言三段論 (Hypothetical Syllogism)</b> 和<b>建構式兩難 (Constructive Dilemma)</b>。
					</p>
					<blockquote>
						<p>
						<b>選言三段論 (Disjunctive Syllogism，簡寫為 DS)</b>
						</p>
						<ul class="list">
							<li>$&alpha;&or;&beta;,&not;&alpha;&vdash;&beta;$</li>
							<li>$&alpha;&or;&beta;,&not;&beta;&vdash;&alpha;$</li>
						</ul>
					</blockquote>
					<p>
					根據選言三段論規則，只要我們有一個選言句，以及選言句中其中一項的否定，我們就能有效地推論出選言句中的另一項。舉例來說：
					</p>
					<table class="prf">
						<tr><td>$A&or;B$</td><td>前提</td></tr>
						<tr><td>$&not;B$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>根據 1,2, DS</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$&not;A&or;(B&rarr;C)$</td><td>前提</td></tr>
						<tr><td>$&not;&not;A$</td><td>前提</td></tr>
						<tr><td>$B&rarr;C$</td><td>根據 1,2, DS</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$((A&and;C)&rarr;B)&or;(D&rarr;C)$</td><td>前提</td></tr>
						<tr><td>$&not;(D&rarr;C)$</td><td>前提</td></tr>
						<tr><td>$(A&and;C)&rarr;B$</td><td>根據 1,2, DS</td></tr>
					</table>
					<p>
					其實選言三段論規則的道理很容易明白，當我們宣稱一個選言句為真時，我們就是在宣稱選言句中的兩個子句至少有一個是真的。既然至少有一個是真的，一但我們可以確定其中一個是假的，那剩下那個當然就必須是真的。
					</p>
					<p>
					舉例來說，你知道你的鑰匙就在書桌的抽屜裡，只是你不確定在哪一個抽屜。由於書桌總共只有左右兩個抽屜，所以你可以知道：
					</p>
					<ol class="lltd song">
						<li>鑰匙在書桌左邊的抽屜，或者鑰匙在書桌右邊的抽屜。</li>
					</ol>
					<p>
					你打開書桌左邊的抽屜翻了個底朝天，你發現鑰匙不在裡面，所以你知道：
					</p>
					<ol class="lltd song">
						<li>鑰匙不在書桌左邊的抽屜。</li>
					</ol>
					<p>
					只要你確實知道 f 和 g 都是真的，你其實根本不用打開書桌右邊的抽屜，你就可以知道鑰匙肯定會在書桌右邊的抽屜裡。這就是選言三段論規則的作用。
					</p>
					<p>
					要特別注意的是，語句邏輯的推論系統中因為有選言三段論規則和添加律規則的關係，所以有一個非常特別的特性是：從彼此矛盾的語句可以推論出任何語句。舉例來說：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$&not;A$</td><td>前提</td></tr>
						<tr><td>$A&or;G$</td><td>根據 1, Add.</td></tr>
						<tr><td>$G$</td><td>根據 2,3, DS</td></tr>
					</table>
					<p>
					或者像以下推論：
					</p>
					<table class="prf">
						<tr><td>$A&and;B$</td><td>前提</td></tr>
						<tr><td>$&not;B$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>根據 1, Simp.</td></tr>
						<tr><td>$B&or;(C&rarr;(D&and;F))$</td><td>根據 3, Add.</td></tr>
						<tr><td>$C&rarr;(D&and;F)$</td><td>根據 4, DS</td></tr>
					</table>
					<p>
					在前一個推論中，前提就包括了彼此矛盾的兩個語句。因為 '$A$' 和 '$&not;A$' 剛好是彼此的否定句，所以既不能同真也不能同假，故彼此矛盾。我們只要對其中一個用添加律加上任意的語句形成一個選言句，再用另一個和剛剛形成的選言句使用 DS 規則，就能把剛才用添加律加上去的任意語句保留下來成為結論。
					</p>
					<p>
					而在第二個推論當中，雖然兩個前提並不彼此矛盾，只是彼此衝突（當 '$B$' 為真時，兩個前提皆為假，因此兩個前提不可同真但可同假，故衝突但不矛盾）。可是我們可以用有效的推論規則從彼此衝突的前提推論出彼此矛盾的語句，那麼就可以重複上一段提到的程序，用添加律添加任意語句後，再用 DS 將添加的任意語句保留下來成為結論。
					</p>
					<p>
					雖然這是一個很特別的性性，不過這個特性在日常生活的推論當中很少被用到，在形式證明上的作用比較大。此外，雖然「彼此矛盾的語句可以推論出任何語句」聽起來好像很厲害，畢竟可以推論出任何語句。可是要注意的是，有效推論的定義是：當前提<b>全部</b>為真時，結論也會為真。然而，前提如果有彼此矛盾的語句（或者可以推論出彼此矛盾的語句），那就表示前提不可能全部為真。因此即使可以推論出彼此矛盾的語句，因此可以推論出任何語句，這樣的推論也不能保證結論是真的。
					</p>
					<p>
					接下來要介紹的規則是<b>假言三段論</b>。這也是一個很容易理解的規則，而且在日常生活中的推理也經常用到：
					</p>
					<blockquote>
						<p>
						<b>假言三段論 (Hypothetical Syllogism，簡寫為 HS)</b>
						</p>
						<p>
						$&alpha;&rarr;&beta;,&beta;&rarr;&gamma;&vdash;&alpha;&rarr;&gamma;$
						</p>
					</blockquote>
					<p>
					根據假言三段論規則，只要我們有兩個條件句，而且其中一個的後件是另一個的前件，我們就能推論出由前一個條件句之前件，和後一個條件句之後件所組成的條件句。換言之，根據假言三段論規則，語句邏輯中的條件句關係（也就是實質蘊涵關係）有<b>傳遞性 (transitivity)</b>。
					</p>
					<p>
					什麼是<b>傳遞性</b>？傳遞性是一種關係的性質。事物和事物之間可以有各種關係，而關係可以有許多不同的性質，傳遞性是其中一種。以「……在……的左邊」這個性質來說，如果我們知道以下兩件事：
					</p>
					<ol class="lltd song">
						<li>科科在安安的左邊。</li>
						<li>安安在蔞雷的左邊。</li>
					</ol>
					<p>
					那我們就可以知道：
					</p>
					<ol class="lltd song">
						<li>科科在蔞雷的左邊。</li>
					</ol>
					<p>
					這是因為「……在……左邊」這個關係有傳遞性。
					</p>
					<p>
					再來看另外一個例子，以「……比……還要高」這個關係為例，如果我們已經知道以下兩件事：
					</p>
					<ol class="lltd song">
						<li>科科比安安還要高。</li>
						<li>安安比蔞雷還要高。</li>
					</ol>
					<p>
					我們就可以知道：
					</p>
					<ol class="lltd song">
						<li>科科比蔞雷還要高。</li>
					</ol>
					<p>
					這也是因為「……比……還要高」這個關係具有傳遞性。
					</p>
					<p>
					而假言三段論告訴我們的就是，兩個語句之間的實質蘊涵關係（也就是 '$&rarr;$' 這個語句連接詞所表達的關係）也是有傳遞性的關係：對任三個語句 '$&alpha;$'、'$&beta;$'、'$&gamma;$' 來說，只要 '$&alpha;$' 實質蘊涵 '$&beta;$'，而 '$&beta;$' 實質蘊涵 '$&gamma;$'，那麼 '$&alpha;$' 就會實質蘊涵 '$&gamma;$'。
					</p>
					<p>
					日常生活裡我們其實也經常會用到假言三段論的規則。比如說，給定我知道以下兩件事：
					</p>
					<ol class="lltd song">
						<li>如果我考試當天睡過頭，則我會被扣考。</li>
						<li>如果我被扣考，則我會被當。</li>
					</ol>
					<p>
					我就可以推論出：
					</p>
					<ol class="lltd song">
						<li>如果我考試當天睡過頭，則我會被當。</li>
					</ol>
					<p>
					既然會知道 p，那麼，既然我一點也不想被當，根據 MT 規則，我就知道我考試當天絕對不可以睡過頭。
					</p>
					<p>
					我們可以看一些在證明中利用假言三段論規則進行推論的例子：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;B$</td><td>前提</td></tr>
						<tr><td>$B&rarr;C$</td><td>前提</td></tr>
						<tr><td>$A&rarr;C$</td><td>根據 1,2, HS</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&rarr;(B&and;C)$</td><td>前提</td></tr>
						<tr><td>$(B&and;C)&rarr;(&not;A&or;D)$</td><td>前提</td></tr>
						<tr><td>$A&rarr;(&not;A&or;D)$</td><td>根據 1,2, HS</td></tr>
					</table>
					<p class="ind">
					最後要介紹的蘊涵規則是<b>建構式兩難</b>，這個規則比較複雜一點，但也是我們在日常生活裡經常用到的。我們先來看規則的內容：
					</p>
					<blockquote>
						<p>
						<b>建構式兩難 (Constructive Dilemma，簡寫為 CD)</b>
						</p>
						<p>
						$&alpha;&rarr;&beta;,&gamma;&rarr;&delta;,&alpha;&or;&gamma;&vdash;&beta;&or;&delta;$
						</p>
					</blockquote>
					<p>
					這個規則需要用到的前提一共有三個，其中兩個是任意的兩個條件句，而第三個前提則是前述兩個條件句的<b>前件</b>所構成的選言句。一但掌握了這三個前提後，我們就能用<b>建構式兩難</b>規則推論出兩個條件句的<b>後件</b>所構成的選言句。舉例來說：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;B$</td><td>前提</td></tr>
						<tr><td>$C&rarr;D$</td><td>前提</td></tr>
						<tr><td>$A&or;C$</td><td>前提</td></tr>
						<tr><td>$B&rarr;D$</td><td>根據 1,2,3, CD</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&and;B)&rarr;B$</td><td>前提</td></tr>
						<tr><td>$(C&rarr;D)&rarr;(&not;D&rarr;&not;C)$</td><td>前提</td></tr>
						<tr><td>$(A&and;B)&or;(C&rarr;D)$</td><td>前提</td></tr>
						<tr><td>$B&or;(&not;D&rarr;&not;C)$</td><td>根據 1,2,3, CD</td></tr>
					</table>
					<p class="ind">
					如果要用實際的例子來說明建構式兩難規則的意義，可以考慮在電視或小說情節裡出現強盜搶劫的情景時，強盜經常會問的問題：「要錢還是要命？」這個問題其實就是對建構式兩難規則的應用。因為強盜實際上想說的是：
					</p>
					<ol class="lltd song">
						<li>如果你要留著命，你就把錢交出來。</li>
						<li>如果你要留著錢，我就要你的小命。</li>
					</ol>
					<p>
					由於強盜只給被打劫的人兩個選項：
					</p>
					<ol class="lltd song">
						<li>要錢（留著你的錢）或者要命（留著你的命）</li>
					</ol>
					<p>
					所以你會知道，被打劫的人也只會有兩種結果：
					</p>
					<ol class="lltd song">
						<li>把錢交給強盜，或者把命交給強盜。</li>
					</ol>
					<p>
					兩相權衡之下，你會知道命比錢還重要，所以與其把錢留下卻把命交給強盜，還不如把錢交出去。
					</p>
					<p>
					介紹完所有的蘊涵規則之後，一樣提供一些例題讓大家練習這些規則的應用：
					</p>
					<div class="quiz">
						<ol class="pfq">
							<li>$A&rarr;B$</li>
							<li>$&not;C&and;&not;&not;D$</li>
							<li>$C&or;(B&rarr;&not;D)$</li>
							<li>$&not;A&and;&not;B$</li>
						</ol>
						<ol class="pfq">
							<li>$&not;A&and;(A&or;D)$</li>
							<li>$(C&or;A)&rarr;L$</li>
							<li>$(D&or;U)&rarr;C$</li>
							<li>$L$</li>
						</ol>
						<ol class="pfq">
							<li>$(&not;A&or;D)&and;E$</li>
							<li>$&not;A&rarr;B$</li>
							<li>$D&rarr;(F&or;G)$</li>
							<li>$B&or;(F&or;G)$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$(A&or;C)&and;&not;B$</li>
							<li>$A&rarr;D$</li>
							<li>$C&rarr;B$</li>
							<li>$D$</li>
						</ol>
						<ol class="pfq">
							<li>$(R&and;A)&or;E$</li>
							<li>$(R&and;A)&rarr;D$</li>
							<li>$&not;D$</li>
							<li>$E&and;&not;D$</li>
						</ol>
						<ol class="pfq">
							<li>$C&rarr;A$</li>
							<li>$A&rarr;(B&and;D)$</li>
							<li>$C$</li>
							<li>$B&or;E$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$&not;A&and;(D&rarr;E)$</li>
							<li>$&not;A&rarr;(C&or;D)$</li>
							<li>$A&or;(C&rarr;B)$</li>
							<li>$B&or;E$</li>
						</ol>
						<ol class="pfq">
							<li>$E&or;(A&rarr;C)$</li>
							<li>$C&rarr;(D&and;&not;E)$</li>
							<li>$C&and;D$</li>
							<li>$A&rarr;(D&and;&not;E)$</li>
						</ol>
						<ol class="pfq">
							<li>$(F&rarr;G)&or;H$</li>
							<li>$(C&and;D)&rarr;F$</li>
							<li>$&not;G&and;&not;H$</li>
							<li>$&not;F$</li>
						</ol>
					</div>
				</div><!--chap4 sect2 subsect2-->
				
				<div class="subsection" id="4-2-3">
					<h3>等值規則（一）</h3>
					<p>
					既然蘊涵規則是來自於語句間的蘊涵關係，等值規則自然就是來自於語句間的等值關係。在上一章介紹等值關係時我有提過，給定任意兩個語句 '$&alpha;$' 和 '$&beta;$'，只要這兩個語句彼此是等值的，就表示這兩個語句在所有語意模型之下的真值都相同，也就是說這兩個語句的<b>意義相同</b>。
					</p>
					<p>
					由於兩個彼此等值的語句就是意義相同的語句，因此，當其中一個語句，比如說 '$&alpha;$'，出現在另一個更複雜的語句中，比如說 '$&delta;&rarr;(&phi;&or;&alpha;)$'，作為該語句的一部分時，我們可以用 '$&beta;$' 來替換其中的 '$&alpha;$'，並且可以保證替換過後的語句 '$&delta;&rarr;(&phi;&or;&beta;)$' 和原本的語句也是等值的，因此是意義相同的。
					</p>
					<p>
					基於等值規則的這個特性，因此等值規則與蘊涵規則其中一個不同的地方就是：儘管蘊涵規則必須適用於一個整語句，不能只應用在語句的部分，但是等值規則沒有這個限制。<b>等值規則既可以用於語句的整體，也可以用於語句的部分。</b>
					</p>
					<p>
					另外，因為蘊涵規則依賴在蘊涵關係之上，而蘊涵關係本身只是一種單向的關係，因此蘊涵規則所允許的推論也都只有單向的。也就是說，在使用蘊涵規則時，我們總是只能從 '$&vdash;$' 左邊的語句推論出 '$&vdash;$' 右邊的語句，反之則不然。
					</p>
					<p>
					但相反地，因為等值規則是依賴在等值關係之上，而等值關係又是一種雙向關係（當 '$&alpha;$' 與 '$&beta;$' 等值時，'$&beta;$' 也會與 '$&alpha;$' 等值），因此<b>在使用等值規則時，我們不只可以從左邊的語句推論到右邊的語句，也可以從右邊的語句推論到左邊的語句。</b>這是等值規則與蘊涵規則之間第二個重要的差異。
					</p>
					<p>
					在介紹等值規則的時候，我引入了 '$&vdash;$' 這個符號來表示「證明」的概念。但證明是單向的，而等值卻是雙向的，所以我們需要一個新的符號來表示等值關係，就是 '$&equiv;$' 這個符號。當我寫 '$&alpha;&equiv;&beta;$' 時，意思就是 '$&alpha;$' 和 '$&beta;$' 這兩個語句是邏輯等值的。
					</p>
					<p>
					等值規則總共有十條，我們一樣分成兩階段來介紹，首先要介紹的是六個等值規則，這些等值規則都和連言句、選言句與否定句相關。以下先介紹第一條規則：
					</p>
					<blockquote>
					<b>雙重否定律 (Double Negation，簡寫為 DN)</b>
						<p>
						$&alpha;&equiv;&not;&not;&alpha;$
						</p>
					</blockquote>
					<p>
					雙重否定律是眾多推論規則當中最常被使用到的推論規則之一（包括一開始提到的 MP 和 MT 規則也是最常被使用的規則之一）。雙重否定律告訴我們，任何語句只要被否定兩次，都會和該語句自己等值。也就是說，任何語句只要被否定兩次，其意義就會和該語句本身相同。
					</p>
					<p>
					這個道理和數學中的負負得正有點類似，在日常生活中其實也常常會被用到。比如說，考慮以下的例子：
					</p>
					<blockquote>
					開始放暑假以後，科科連續約安安唱歌好幾次都被拒絕。科科覺得奇怪，因為安安明明是最愛唱歌的人，所以科科決定問個清楚。
						<p>
						科科：為什麼我找你唱歌你都不答應？你不喜歡唱歌了嗎？<br/>
						安安：我不是不喜歡唱歌，只是報告還沒寫完，我沒時間去唱歌。
						</p>
					</blockquote>
					<p>
					科科懷疑「安安不喜歡唱歌」了，這其實就是對「安安喜歡唱歌」的否定。而安安解釋說自己「不是不喜歡唱歌」，就是把科科的否定句再否定一次。當然，「不是不喜歡唱歌」其實就是「喜歡唱歌」的意思。所以這個例子很好地示範了雙重否定律在日常生活中的應用。
					</p>
					<p>
					我們來看看在語句邏輯的論證當中，要如何使用雙重否定律來進行推論。前面說過，等值規則可以用在完整的語句之上，也可以用在語句的一部分，所以我會分別都舉幾個例子：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$&not;&not;A$</td><td>根據 1, DN</td></tr>
					</table>
					<p>
					因為等值關係是雙向關係，所以將前提和結論對調過來的推論也是有效的：
					</p>
					<table class="prf">
						<tr><td>$&not;&not;A$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>根據 1, DN</td></tr>
					</table>
					除了原子語句以外，DN 規則當然也可以用在複雜語句之上：
					<table class="prf">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$&not;&not;((A&and;B)&rarr;C)$</td><td>根據 1, DN</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$&not;&not;((A&and;B)&rarr;C)$</td><td>前提</td></tr>
						<tr><td>$(A&and;B)&rarr;C$</td><td>根據 1, DN</td></tr>
					</table>
					<p>
					我們也可以把 DN 規則用在語句的其中一部分上，例如：
					</p>
					<table class="prf">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$(A&and;&not;&not;B)&rarr;C$</td><td>根據 1, DN</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&and;&not;&not;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$(A&and;B)&rarr;C$</td><td>根據 1, DN</td></tr>
					</table>
					<p>
					注意到了嗎？在上面這兩個例子當中，我只有把 '$(A&and;B)&rarr;C)$' 當中的語句 '$B$' 替換成  '$&not;&not;B$'（或者倒過來，把 '$(A&and;&not;&not;B)&rarr;C$' 中的 '$&not;&not;B$' 替換成 '$B$'）而已。
					</p>
					<p>
					雙重否定律是一條很重要的規則，因為它有許多很方便的應用方式。看看以下幾個例子，就可以知道雙重否定律的方便之處：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;&not;B$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>前提</td></tr>
						<tr><td>$&not;&not;B$</td><td>根據 2, DN</td></tr>
						<tr><td>$&not;A$</td><td>根據 1,3, MT</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&or;&not;B$</td><td>前提</td></tr>
						<tr><td>$B$</td><td>前提</td></tr>
						<tr><td>$&not;&not;B$</td><td>根據 2, DN</td></tr>
						<tr><td>$A$</td><td>根據 1,3 DS</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&rarr;&not;&not;B$</td><td>前提</td></tr>
						<tr><td>$B&rarr;&not;C$</td><td>前提</td></tr>
						<tr><td>$A&rarr;B$</td><td>根據 1, DN</td></tr>
						<tr><td>$A&rarr;&not;C$</td><td>根據 2,3 HS</td></tr>
					</table>
					<p>
					以上這三個推論除了 DN 之外都只用到我們已經學過的蘊涵規則。但是只要稍微注意就會發現，如果沒有 DN 規則的幫助，這三個推論都無法只用蘊涵規則做出來。
					</p>
					<p>
					在前兩個推論當中，使用到的蘊涵規則分別是 MT 規則和 DS 規則。這兩個規則有個相同的特色，就是要透過否定一個語句中的一部分來推論出語句中的另一部分（或其否定）：MT 規則要藉由否定條件句的後件來推論出條件句前件的否定，而 DS 規則是透過否定選言句的任一項來推論出選言句的另外一項。
					</p>
					<p>
					在這兩個例子當中，要被否定的語句本身就是一個否定句，因此若要否定它的話，就需要有雙重否定句。然而，前提卻只有給我們該語句的肯定句。雖然從語意上我們可以知道，任何語句和它自己的否定句其實是互為否定的，可是因為在語法上沒有 DN 規則的時候，我們就是無法從任何語句推論出自己的雙重否定，因此這些推論都做不出來。
					</p>
					<p>
					這個問題在第三個推論當中更明顯，為了要用 HS 規則從前提 (1) 和前提 (2) 推論出 '$A&rarr;&not;C$'，我們就需要有一個中介規則告訴我們，'$B$' 和 '$&not;&not;B$' 是等值的，可以相互替換的。因此，DN 規則就扮演了其中關鍵的中介角色。
					</p>
					<p>
					DN 規則在後面許多和否定有關的推論規則，都可以作為關鍵的中介角色，讓原本做不出來的推論變成做得出來的推論。比如說，DN 規則和下一個要介紹的規則就經常搭配在一起使用：
					</p>
					<blockquote>
					<b>笛摩根定律 (De Morgan's Laws，簡寫為 DeM)</b>
						<ul class="list">
							<li>$&not;(&alpha;&and;&beta;)&equiv;&not;&alpha;&or;&not;&beta;$</li>
							<li>$&not;(&alpha;&or;&beta;)&equiv;&not;&alpha;&and;&not;&beta;$</li>
						</ul>
					</blockquote>
					<p>
					根據笛摩根定律，任何連言句的否定句，都會等值於兩個連言項的否定句組成的選言句；而任何選言句的否定句，則都會等值於兩個選言項的否定句組成的連言句。
					</p>
					<p>
					這件事情在語意上很容易理解：'$&not;(&alpha;&and;&beta;)$' 就是在說「'$&alpha;$' 和 '$&beta;$' 這兩個語句都為真」是假的，也就是說，「'$&alpha;$ 和 '$&beta;$' 這兩個語句並非都是真的」。既然並非都是真的，就表示其中至少有一個是假的，因此可以推論出「'$&alpha;$' 是假的，或者 '$&beta;$' 是假的」，也就是 '$&not;&alpha;&or;&not;&beta;$'。
					</p>
					<p>
					反過來說，'$&not;&alpha;&or;&not;&beta;$' 就是在說「'$&alpha;$ 和 '$&beta;$' 這兩個語句至少有一個是假的」，也就是說，「'$&alpha;$' 和 '$&beta;$' 這兩個語句並非都是真的」。既然這兩個語句並非都是真的，就表示「'$&alpha;$' 和 '$&beta;$' 這兩個語句都為真」會是假的，因此可以推論出 '$&not;(&alpha;&and;&beta;)$'。
					</p>
					<p>
					以上就是用語意的方式來說明（以及證明）'$&not;(&alpha;&and;&beta;)$' 和 '$&not;&alpha;&or;&not;&beta;$' 這兩個語句在邏輯上是等值的。如果各位有興趣的話，也可以試著自己用語意的方式來說明（以及證明）'$&not;(&alpha;&or;&beta;)$' 和 '$&not;&alpha;&and;&not;&beta;$' 這兩個語句也是邏輯上等值的。
					</p>
					<p>
					至於從語法上來看的話，
					</p>
					<p>
					以下介紹一些笛摩根定律在推論中的使用方式：
					</p>
					<table class="prf">
						<tr><td>$&not;A&and;&not;B$</td><td>前提</td></tr>
						<tr><td>$&not;(A&or;B)$</td><td>根據 1, DeM</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$&not;(A&and;B)$</td><td>前提</td></tr>
						<tr><td>$&not;A&or;&not;B$</td><td>根據 1, DeM</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$&not;((A&and;B)&and;(C&or;D))$</td><td>前提</td></tr>
						<tr><td>$&not;(A&and;B)&or;&not;(C&or;D)$</td><td>根據 1, DeM</td></tr>
						<tr><td>$(&not;A&or;&not;B)&or;&not;(C&or;D)$</td><td>根據 2, DeM</td></tr>
						<tr><td>$(&not;A&or;&not;B)&or;(&not;C&and;&not;D)$</td><td>根據 2, DeM</td></tr>
					</table>
					<p>
					比較特別的是第三個推論，在第三個推論當中，我們在同一個語句上連續使用了三次 DeM 規則。在第一次使用時，我們是將 DeM 規則套用在整個語句之上，此時，我們是將 '$&not;((A&and;B)&and;(C&or;D))$' 看成是 '$&not;(&alpha;&and;&beta;)$' 的形式，其中的 '$&alpha;$' 代表的是原語句中的 '$A&and;B$'，而 '$&beta;$' 則代表原語句中的 '$C&or;D$'。
					</p>
					<p>
					因此，在套用了 DeM 規則之後，我們得到的是具有 '$&not;&alpha;&or;&not;&beta;$' 這個形式的語句，也就是 '$&not;(A&and;B)&or;&not;(C&or;D)$'。
					</p>
					<p>
					在第二次使用 DeM 規則時，我們只有將此規則用在 '$&not(A&and;B)&or;&not;(C&or;D)$' 的前半句上，也就是 '$&not;(A&and;B)$'，並推論出 '$(&not;A&or;&not;B)&or;&not;(C&or;D)$'。最後，在第三次使用 DeM 規則時，則是將這個規則套用在後半句的 '$&not;(C&or;D)$' 上，並且推論出 '$(&not;A&or;&not;D)&or;(&not;C&and;&not;D)$' 這個結論。
					</p>
					<p>
					從以上的例子應該不難看得出來，由於等值規則既可以應用在完整的語句上，也可以只應用在語句的部分之上，因此規則使用起來的變化性就增加不少。另外，在介紹 DeM 規則之前，我有提到 DN 規則經常和 DeM 搭配使用，以下就是兩個例子：
					</p>
					<table class="prf">
						<tr><td>$&not;(&not;A&and;B)$</td><td>前提</td></tr>
						<tr><td>$&not;&not;A&or;&not;B$</td><td>根據 1, DeM</td></tr>
						<tr><td>$A&or;&not;B$</td><td>根據 2, DN</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&and;B$</td><td>前提</td></tr>
						<tr><td>$&not;&not;A&and;&not;&not;B$</td><td>根據 1, DN</td></tr>
						<tr><td>$&not;(&not;A&or;&not;B)$</td><td>根據 2, DeM</td></tr>
					</table>
					<p>
					第一個例子應該很好理解，就是利用 DeM 規則將外面的 '$&not;$' 分別配給裡面的 '$&not;A$' 和 '$B$'，然後再用 DN 規則將 '$&not;&not;A$' 改成 '$A$' 就完成了。
					</p>
					<p>
					第二個例子可能就需要稍微說明一下才會清楚在做什麼事。我說過，DeM 規則是一個等值規則，所以我們可以從 '$&equiv;$' 左邊的語句推論出右邊的語句，也可以從 '$&equiv;$' 右邊的語句推論出左邊的語句。
					</p>
					<p>
					根據 DeM 規則，從左邊到右邊的推論是這樣的：當我們要否定一個連言句或選言句時，可以把外面的否定號移到裡面分別配給兩個連言項或否定項，然後把主要連接詞從連言改成選言（或從選言改成連言）。
					</p>
					<p>
					但是從右邊到左邊的推論就比較麻煩些，因為從右邊推到左邊，是要把一個連言句或選言句的左項和右項都各減少一個 '$&not;$'，然後把主要連接詞的連言改成選言（或把選言改成連言），最後再於最外面加上一個否定號。
					</p>
					<p>
					既然是要滅少掉 '$&not;$'，如果我們擁有的連言句或選言句的左右項沒有否定號的話，那就不能做 DeM 規則了。所以這時候才會需要用到 DN 規則，因為 DN 是唯一可以幫我們給任意語句增加 '$&not;$' 的規則。其實不只是 DeM 規則，我們在後面也會學到其它需要減少 '$&not;$' 的規則，DN 規則和這些規則也都可以有很好的搭配。
					</p>
					<p>
					接下來要一次介紹三個規則，這三個規則也都是常見的規則，而且不只在邏輯中會出現，在數學裡也經常出現。這三條規則分別是：
					</p>
					<blockquote>
					<b>交換律 (Commutative Law，簡寫為 Comm.)</b>
						<ul class="list">
							<li>$&alpha;&and;&beta;&equiv;&beta;&and;&alpha;$</li>
							<li>$&alpha;&or;&beta;&equiv;&beta;&or;&alpha;$</li>
						</ul>
					</blockquote>
					<blockquote>
					<b>結合律 (Associatve Law，簡寫為 Assoc.)</b>
						<ul class="list">
							<li>$&alpha;&and;(&beta;&and;&gamma;)&equiv;(&alpha;&and;&beta;)&and;&gamma;$</li>
							<li>$&alpha;&or;(&beta;&or;&gamma;)&equiv;(&alpha;&or;&beta;)&or;&gamma;$</li>
						</ul>
					</blockquote>
					<blockquote>
					<b>分配律 (Distributive Law，簡寫為 Dist.)</b>
						<ul class="list">
							<li>$&alpha;&and;(&beta;&or;&gamma;)&equiv;(&alpha;&and;&beta;)&or;(&alpha;&and;&gamma;)$</li>
							<li>$&alpha;&or;(&beta;&and;&gamma;)&equiv;(&alpha;&or;&beta;)&and;(&alpha;&or;&gamma;)$</li>
						</ul>
					</blockquote>
					<p>
					這三條規則和以前在學四則運算時學到的交換律、結合律、分配律差不多就是一樣的東西。根據交換律，選言句和連言句的左右兩項可以任意的交換位置而不會改變意義。根據結合律，當你要把三個語句<b>全部</b>用連言符號（'$&and;$'）或選言符號（'$&or;$'）連接在一起的時候，括號的位置不會改變語句的意義。
					</p>
					<p>
					至於分配律，則是告訴你，當你要將一個語句和一個選言句連言在一起（或者將一個語句和一個連言句選言在一起），你應該要如何分配這些語句之間的關係。
					</p>
					<p>
					交換律和結合律在語意上應該都很好理解，連言句只是要宣稱兩個語句皆為真，因此兩個語句的排列順序根本無關緊要；而選言句則是宣稱兩個語句至少有一個為真，所以兩個語句的排列順序一樣也不會影響語句的意思，因此交換律在連言句和選言句上都成立。
					</p>
					<p>
					而根據結合律，如果要把三個語句全部用連言符號連接在一起，基於連言符號是一個<b>二元</b>連接詞，所以每一個連言符號都必須連接兩個語句，因此我們不能將語句寫成 '$&alpha;&and;&beta;&and;&gamma;$' 這個形式。因為如果第一個連言符號連接了 '$&alpha;$' 和 '$&beta;$' 兩個語句，那第二個連言符號就只有 '$&gamma;$' 一個語句可以連接了，這樣不符合連言符號作為二元連接詞的使用規則。
					</p>
					<p>
					因此，若要用第一個連言符號連接 '$&alpha;$' 和 '$&beta;$' 兩個語句，就必須先用括號將它們包起來，然後再用第二個連言符號連接 '$(&alpha;&and;&beta;)$' 和 '$&gamma;$' 兩個語句，如此，語句中的兩個連言符號才能都連接兩個語句。相反，若要先用第二個連言符號連接 '$&beta;$' 與 '$&gamma;$' 這兩個語句，一樣要用括號將它們包起來，再用第一個連言符號連接 '$&alpha;$' 和 '$(&beta;&and;&gamma;)$' 才會使句中的兩個連言符號都連接兩個語句。
					</p>
					<p>
					然而無論是先連接前兩個語句，還是先連接後兩個語句，最後寫出來的語句意思都是相同的，都只是要宣稱這三個語句全部為真而已。同理，當我們要將三個語句全部用選言符號連接在一起時，也會因為選言符號是二元連接詞的關係，而必須先連接前兩個語句，或先連接後兩個語句，但無論如何選擇，最後寫出來的語句意思都是相同的，都只是要宣稱這三個語句中至少有一個為真而已。
					</p>
					<p>
					所以，從語意上來看，結合律在連言句和選言句上都成立。只不過要特別注意的事情是，結合律只會在<b>都是用連言符號</b>或者<b>都是用選言符號</b>的語句上才會成立。比如說 '$&alpha;&and;(&beta;&and;&gamma;)$' 和 '$(&alpha;&and;&beta;)&and;&gamma;$' 是等值的，'$&alpha;&or;(&beta;&or;&gamma;)$' 與 '$(&alpha;&or;&beta;)&or;&gamma;$' 也是等值的。但 '$&alpha;&and;(&beta;&or;&gamma;)$' 與 '$(&alpha;&and;&beta;)&or;&gamma;$' 之間就不等值，除此以外 '$&alpha;&or;(&beta;&and;&gamma;)$' 和 '$(&alpha;&or;&beta;)&and;&gamma;$' 之間也不等值。
					</p>
					<p>
					至於後兩組語句為什麼是不等值的，從語意上來說明不見得容易說得清楚，但用歸謬法可以很快判斷出來：
					</p>
					<div class="tree2" style="margin-left:-25px">
						<span>$&not;((&alpha;&and;(&beta;&or;&gamma;))&harr;((&alpha;&and;&beta;)&or;&gamma;))$</span>
						<svg width="500px"><path d="M250 1 L125 23"/><path d="M250 1 L375 23"/></svg>
						<div>
							<span>$&alpha;&and;(&beta;&or;&gamma;)$</span><br/>
							<span>$&not;((&alpha;&and;&beta;)&or;&gamma;)$</span>
							<svg width="250px"><path d="M125 0 L125 24"/></svg>
						</div>
						<div>
							<span>$&not;(&alpha;&and;(&beta;&or;&gamma;))$</span><br/>
							<span>$(&alpha;&and;&beta;)&or;&gamma;$</span>
							<svg width="250px"><path d="M125 1 L62.5 23"/><path d="M125 1 L187.5 23"/></svg>
							<div>
								<span>$&not;&alpha;$</span><br/>
								<span>$(&alpha;&and;&beta;)&or;&gamma;$</span>
								<svg width="125px"><path d="M62.5 0 L31.25 24"/><path d="M62.5 0 L93.75 24"/></svg>
								<div>
									<span>$&not;&alpha;$</span><br/>
									<span>$&alpha;&and;&beta;$</span>
									<svg width="62.5px"><path d="M31.25 0 L31.25 24"/></svg>
								</div>
								<div>
									<span>$&not;&alpha;$</span><br/>
									<span>$&gamma;$</span><br/>
									<span>&check;</span>
								</div>
							</div>
							<div>
								<span>$&not;(&beta;&or;&gamma;)$</span><br/>
								<span>$(&alpha;&and;&beta;)&or;&gamma;$</span>
								<svg width="125px"><path d="M62.5 0 L62.5 24"/></svg>
							</div>
						</div>
					</div>
					<p>
					從上圖可以看到，已經發現有一個分支可以在不矛盾的情況下讓 '$&alpha;&and;(&beta;&or;&gamma;)$' 為假，而且讓 '$(&alpha;&and;(&beta;&or;&gamma;)$' 為真，既然可以一直一假，就表示這兩個語句不等值。至於另外一組，如果讀者有興趣的話也可以自己用歸謬法把樹枝圖畫出來看看。
					</p>
					<p>
					分配律在語意上其實也很容易理解，以 '$&alpha;&and;(&beta;&or;&gamma;)$' 來說，因為它是連言句，所以它是在宣稱：'$&alpha;$' 為真，'$&beta;&or;&gamma;$' 也為真。也就是說，'$&alpha;$' 是真的，至於 '$&beta;$' 和 '$&gamma;$' 當中至少會有一個是真的。如果是 '$&beta;$' 為真，那就表示 '$&alpha;&and;&beta;$' 為真；如果是 '$&gamma;$' 為真，那就表示 '$&alpha;&and;&gamma;$' 為真。所以 '$&alpha;&and;&beta;$' 和 '$&alpha;&and;&gamma;$' 之間也至少有一個為真，因此，'$(&alpha;&and;&beta;)&or;(&alpha;&and;&gamma;)$' 為真。
					</p>
					<p>
					反過來說，當 '$(&alpha;&and;&beta;)&or;(&alpha;&and;&gamma;)$' 為真時，就表示 '$&alpha;&and;&beta;$' 和 '$&alpha;&and;&gamma;$' 之間至少有一個為真。無論是哪一個為真，可以確定的是 '$&alpha;$' 一定為真，那麼剩下來的就是 '$&beta;$' 和 '$&gamma;$' 之間至少有一個會為真。因此，'$&alpha;$' 為真，而且 '$&beta;&or;&gamma;$' 為真。也就是說，'$&alpha;&and;(&beta;&or;&gamma;)$' 為真。
					</p>
					<p>以上是說明用連言符號將一個語句連接上一個選言句時分配律為何成立。至於用選言符號將一個語句連接上一個連言句時分配律為何會成立，讀者可以自行試著用類似的方法思考看看，應該不難想通。如果真的想不通，也可以試著用歸謬樹枝法來檢查，那樣便足以證明分配律是成立的。</p>
					<p>
					從語意的觀點說明完這三條等值規則為什麼成立之後，我們可以用幾個例子來看看這些規則實際上要如何使用：
					</p>
					<table class="prf">
						<tr><td>$A&and;B$</td><td>前提</td></tr>
						<tr><td>$B&and;A$</td><td>根據 1, Comm.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&or;&not;B$</td><td>前提</td></tr>
						<tr><td>$&not;B&or;A$</td><td>根據 1, Comm.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&rarr;B)&and;(C&or;D)$</td><td>前提</td></tr>
						<tr><td>$(C&or;D)&and;(A&rarr;B)$</td><td>根據 1, Comm.</td></tr>
						<tr><td>$(D&or;C)&and;(A&rarr;B)$</td><td>根據 1, Comm.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&and;(B&and;C)$</td><td>前提</td></tr>
						<tr><td>$(A&and;B)&and;C$</td><td>根據 1, Assoc.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&or;B)&or;C$</td><td>前提</td></tr>
						<tr><td>$A&or;(B&or;C)$</td><td>根據 1, Assoc.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$((A&rarr;B)&and;(C&or;D))&and;(E&harr;F)$</td><td>前提</td></tr>
						<tr><td>$(A&rarr;B)&and;((C&or;D)&and;(E&harr;F))$</td><td>根據 1, Assoc.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(((A&or;B)&or;C)&and;E)&and;(F&rarr;D)$</td><td>前提</td></tr>
						<tr><td>$((A&or;B)&or;C)&and;(E&and;(F&rarr;D))$</td><td>根據 1, Assoc.</td></tr>
						<tr><td>$(A&or;(B&or;C))&and;(E&and;(F&rarr;D))$</td><td>根據 1, Assoc.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&and;(B&or;C)$</td><td>前提</td></tr>
						<tr><td>$(A&and;B)&or;(A&and;C)$</td><td>根據 1, Dist.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A&or;(B&and;(C&rarr;D))$</td><td>前提</td></tr>
						<tr><td>$(A&or;B)&and;(A&or;(C&rarr;D))$</td><td>根據 1, Dist.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$(A&or;B)&and;(C&or;D)$</td><td>前提</td></tr>
						<tr><td>$((A&or;B)&and;C)&or;((A&or;B)&and;D)$</td><td>根據 1, Dist.</td></tr>
						<tr><td>$(C&and;(A&or;B))&or;((A&or;B)&and;D)$</td><td>根據 1, Comm.</td></tr>
						<tr><td>$(C&and;(A&or;B))&or;(D&and;(A&or;B))$</td><td>根據 1, Comm.</td></tr>
						<tr><td>$((C&and;A)&or;(C&and;B))&or;(D&and;(A&or;B))$</td><td>根據 1, Comm.</td></tr>
						<tr><td>$((C&and;A)&or;(C&and;B))&or;((D&and;A)&or;(D&and;B))$</td><td>根據 1, Dist.</td></tr>
					</table>
					<p>
					這些應用當中比較需要注意的，首先是第三個推論，其中的第 2 個語句是對第一個語句的一整句使用交換律，將 '$A&rarr;B$' 和 '$C&or;D$' 的位置交換，而第三個語句則是針對第二個語句的左半邊，也就是 '$C&or;D$' 使用交換律，交換了 '$C$' 和 '$D$' 的位置。
					</p>
					<p>
					第二個要注意的地方，是第五個推論。我在介紹結合律時有提醒各位，結合律只能使用在<b>都是連言符號</b>或<b>都是選言符號</b>的語句上，但第五個推論中的語句 1 既有連言符號，又有選言符號，還有單條件句還雙條件句，為什麼還能對它使用結合律呢？
					</p>
					<p>
					仔細觀察的話可以發現，雖然其中除了否定號之外，其它四個連接詞都用上了，但我們在對語句 1 使用結合律時，並沒有更動 '$A&rarr;B$'、'$C&or;D$' 和 '$E&harr;F$' 這三個語句的<b>內部結構</b>。只要固定這三個語句的內部結構不變，我們其實可以將它們分別視為 '$&alpha;$'、'$&beta;$' 和 '$&gamma;$' 三個語句，那麼語句 1 其實就是 '$(&alpha;&and;&beta;)&and;&gamma;$' 的語句形式，而這個語句形式確實只有用到連言符號，所以結合律依然適用。
					</p>
					<p>
					接著在第六個推論當中，我也是先將 '$(A&or;B)&or;C$'、'$E$' 和 '$F&rarr;D$' 這三個語句分別看成一個獨立的語句，因此語句 1 就成為 '$(&alpha;&and;&beta;)&and;&gamma;$' 的形式，然後對它使用結合後，得到 '$&alpha;&and;(&beta;&and;&gamma;)$。接著，我再針對語句 2 中的 '$(A&or;B)&or;C$' 又做了一次結合律，改成 '$A&or;(B&or;C)$'，因此才得到結論。
					</p>
					<p>
					最後要注意的是第九個推論，也就是最後一個推論。在這個推論中，我是先用分配律，將 '$A&or;B$' 分配給 '$C&or;D$' 中的 '$C$' 和 '$D$'，得到語句 2。再對語句 2 中的 '$(A&or;B)&and;C$' 和 '$(A&or;B)&and;D$' 分別做一次交換律，然後再對語句 4 中的 '$C&and;(A&or;B)$' 和 '$D&and;(A&or;B)$' 各做一次分配律，最後才得到結論。
					</p>
					<p>
					另外還有一件要注意的事，就是交換律的使用時機看起來好像很少，但那其實是因為我在前面介紹許多和選言句與連言句有關的蘊涵規則時，都已經偷偷把交換律放在裡面了。舉例來說，我在介紹簡化律時，我說從 '$&alpha;&and;&beta;$' 可以有效地推論出 '$&alpha;$'，也可以有效地推論出 '$&beta;$'。但原本的簡化律其實只允許我們從 '$&alpha;&and;&beta;$' 有效地推論出 '$&alpha;$' 而已，要推論出 '$&beta;$' 還必須搭配交換律，例如：
					</p>
					<table class="prf">
						<tr><td>$A&and;B$</td><td>前提</td></tr>
						<tr><td>$B&and;A$</td><td>根據 1, Comm.</td></tr>
						<tr><td>$B$</td><td>根據 2, Simp.</td></tr>
					</table>
					<p>
					只是如果每次要用簡化律從連言句推論出右邊的連言項，都要先動用交換律的話，實在太浪費時間了，所以我在介紹規則時就直接把交換律的效果也放進去了。除了簡化律之外，連言律、添加律、選言三段論等規則，其實也都被我預先放進了交換律的效果了。當然，因為我在前面已經把交換律的效果放進那幾條規則之中，所以各位在做推論時可以直接使用，不必再多此一舉地使用交換律。
					</p>
					<p>
					最後要介紹的是前六條等值規則中的第六條，這也是一個不會很常用到，但用到的時候卻常常會有最關鍵的效果的一條規則：
					</p>
					<blockquote>
					<b>恆真律 (Laws of Tautology，簡寫為 Taut.)</b>
						<ul class="list">
							<li>$&alpha;&equiv;&alpha;&and;&alpha;$</li>
							<li>$&alpha;&equiv;&alpha;&or;&alpha;$</li>
						</ul>
					</blockquote>
					<p>
					恆真律是一個為了方便起見而設立的規則，因為恆真律的兩條原則其實都可以用我們已經學過的推論規則證明出來。此外，要用語意來理解恆真律也很容易。
					</p>
					<p>
					首先說明恆真律的連言句那一條在語意上為什麼成立。先說明從左邊到右邊為何成立：當我們可以確定 '$&alpha;$' 為真的時候，'$&alpha;$' 和 '$&alpha;$' 當然都為真，畢竟它們是同一個語句，所以 '$&alpha;&and;&alpha;$' 為真。接著說明從右邊到左邊為何成立：當我們確定 '$&alpha;&and;&alpha;$' 為真時，就表示 '$&alpha;$' 和 '$&alpha;$' 都為真，那 '$&alpha;$' 當然也為真。
					</p>
					<p>
					再來說明選言句的恆真律為什麼會成立，一樣先從左邊到右邊的推論開始說明：當 '$&alpha;$' 為真時，'$&alpha;$' 和 '$&alpha;$' 之間當然至少會有一個為真，所以 '$&alpha;&or;&alpha;$' 為真。再說明從右邊到左邊的推論：當 '$&alpha;&or;&alpha;$' 為真的時候，表示 '$&alpha;$' 和 '$&alpha;$' 之間至少有一個為真，但無論是哪一個為真，其實都是 '$&alpha;$' 為真，所以 '$&alpha;$' 為真。
					</p>
					<p>接下來，我示範如何用我們目前已經學過的其它規則，來證明這兩條分別關於連言句與選言句的恆真律：<span class="note"><span class="box">要注意的是，以下的證明其實不是在語句邏輯中的證明，因為我不會用到語句邏輯中的語句。我會用的是 '$&alpha;$'、'$&beta;$' 這些用來代表語句邏輯中的語句的符號。因此這些證明其實是看起來像是語句邏輯證明，但實際上是後設證明的證明：</span></span>
					</p>
					<table class="prf">
						<tr><td>$&alpha;$</td><td>前提</td></tr>
						<tr><td>$&alpha;$</td><td>前提</td></tr>
						<tr><td>$&alpha;&and;&alpha;$</td><td>根據 1,2, Conj.</td></tr>
					</table>
					<p>
					這是證明連言句的恆真律從左邊到右邊的推論。從左邊到右邊的推論要以語句 '$&alpha;$' 為前提，因此證明中的語句 1 就是提取了 '$&alpha;$' 這個前提。至於語句 2，其實就是把同一個前提語句再提取一次而已<span class="note"><span class="box">記得嗎？在一個證明當中，每一個語句都只能有兩個來源，一個是前提語句，另一個就是要從位在它前面的語句用有效的推論規則推論出來。這個規定並沒有限制一個前提語句可以被使用幾次，因此，只要一個語句是論證可以使用的前提，那麼在證明中，我們可以不限次數地將這個前提語句提取出來。</span></span>，這是為了用連言律而做的準備。既然我們在證明中得到了兩個 '$&alpha;$'，自然就可以用連言律得到 '$&alpha;&and;&alpha;$'。接下來是從右邊到左邊的證明：
					</p>
					<table class="prf">
						<tr><td>$&alpha;&and;&alpha;$</td><td>前提</td></tr>
						<tr><td>$&alpha;$</td><td>根據 1, Simp.</td></tr>
					</table>
					<p>
					連言句的恆真律從右邊到左邊的證明更簡單，只要對前提使用一次簡化律就完成了。接著是選言句的恆真律的證明：
					</p>
					<table class="prf">
						<tr><td>$&alpha;$</td><td>前提</td></tr>
						<tr><td>$&alpha;&or;&alpha;$</td><td>根據 1, Add.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$&alpha;&or;&alpha;$</td><td>前提</td></tr>
						<tr><td>$&not;(&not;&alpha;&and;&not;&alpha;)$</td><td>根據 1, DeM</td></tr>
						<tr><td>$&not;(&not;&alpha;)$</td><td>根據 1, Taut.</td></tr>
						<tr><td>$&alpha;$</td><td>根據 1, DN</td></tr>
					</table>
					<p>
					要證明選言句的恆真律從左邊到右邊的推論也很簡單，只要對前提做一次添加律即可。要證明從右邊到左邊的推論比較麻煩，在上面這個證明中，我先用笛摩根定律將 '$&alpha;&or;&alpha;$' 變成 '$&not;(&not;&alpha;&and;&alpha;)$'，然後用連言句的恆真律將其中的 '$&not;&alpha;&and;&alpha;$' 變成 '$&not;&alpha;$'，最後才用雙重否定律將得到的 '$&not;&not;&alpha;$' 變成 '$&alpha;$'。
					</p>
					<p>
					在這個證明中有兩件要特別注意的事，首先，有些讀者可能會懷疑，為什麼要用連言句的恆真律將 '$&not;(&not;&alpha;&and;&not;&alpha;)$' 變成 '$&not;(&not;&alpha;)$'，而不直接用簡化律？這是因為簡化律是一條蘊涵規則，它必須用在完整的語句上，不能只被用在語句的一部分上面。而 '$&not;&alpha;&and;&not;&alpha;$' 只是 '$&not;(&not;&alpha;&and;&not;&alpha;)$' 這個語句的一部分而已，因此不能用簡化律。相對地，連言句的恆真律是一條等值規則，所以可以用在語句的一部分。
					</p>
					<p>
					第二件要注意的事情是，有些讀者覺得困惑，我明明說過要用恆真律以外的規則來證明恆真律，為什麼我最後在證明選言句的恆真律從右邊到左邊的推論時，仍然用了恆真律？首先，我在最後一個推論中用的並不是完整的恆真律，而只是關於連言句的恆真律，而且這個恆真律我們剛才已經用恆真律以外的規則證明過了，因此在這裡用並不會影響證明的效力。其次，如果真的要完全不用到恆真律（無論是連言句的還是選言句的），我們就要使用到尚未學到的推論規則，因此這邊暫時先做如此處置。
					</p>
					<p>
					恆真律往往都是要搭配其它規則一起使用才會得到最大的用處，它獨自來說無法做什麼有意義的推論。其中尤以搭配建構式兩難規則所做的推論，是最常被使用到的一種推論方式。我用我的老師在打屁閒聊時最喜歡說的論證來當例子：
					</p>
					<ol class="prf song" style="counter-reset:prf 8 pfc 4">
						<li>如果抽菸會讓我早死，則抽菸比不抽菸好，因為抽菸會爽。</li>
						<li>如果抽菸不會讓我早死，則抽菸比不抽菸好，因為抽菸會爽。</li>
						<li>我會早死，或者我不會早死。</li>
						<li>抽菸比不抽菸更好，因為抽菸會爽。</li>
					</ol>
					<p>
					為了要檢查這個論證的有效性，我們先把這個論證翻譯至語句邏輯的語言，為此我們要先指定原子語句的語句符號。令 '$G$' 代表「我會早死」，令 '$H$' 代表「抽菸比不抽菸好，因為抽菸會爽」<span class="note"><span class="box">嚴格說起來，「抽菸比不抽菸好，因為抽菸會爽」其實不是一個原子語句，但一方面因為語句邏輯中沒有因果關係的連接詞，所以無法準確翻譯這個語句（最多就是用單條件句把它翻譯成「如果抽菸會爽，則抽菸比較好」）；另一方面，因為這個語句的內部結構其實沒有在這個論證中被使用到，所以姑且把它當成原子語句也不會影響推論的有效性。所以此處就偷懶地這樣設定了。</span></span>。那麼整個論證可以被翻譯如下：
					</p>
					<ol class="prfp song">
						<li>$G&rarr;H$</li>
						<li>$&not;G&rarr;H$</li>
						<li>$G&or;&not;G$</li>
						<li>$H$</li>
					</ol>
					<p>
					因為這個論證的前提中有兩個是條件句，此外還有一個選言句，而且選言句的兩個選言項剛好分別是兩個條件句的前件，因此很明顯是要用建構式兩難規則來證明：
					</p>
					<table class="prf">
						<tr><td>$G&rarr;H$</td><td>前提</td></tr>
						<tr><td>$&not;G&rarr;H$</td><td>前提</td></tr>
						<tr><td>$G&or;&not;G$</td><td>前提</td></tr>
						<tr><td>$H&or;H$</td><td>根據 1,2,3, CD</td></tr>
						<tr style="display:none"><td>$H&or;H$</td><td>根據 1,2,3, CD</td></tr>
					</table>
					<p>
					做到此處顯然還差一步才能證明出 '$H$'，而所差的關鍵一步其實就是恆真律：
					</p>
					<table class="prf">
						<tr><td>$G&rarr;H$</td><td>前提</td></tr>
						<tr><td>$&not;G&rarr;H$</td><td>前提</td></tr>
						<tr><td>$G&or;&not;G$</td><td>前提</td></tr>
						<tr><td>$H&or;H$</td><td>根據 1,2,3, CD</td></tr>
						<tr><td>$H$</td><td>根據 4, Taut.</td></tr>
					</table>
					<p>
					這個形式的證明其實非常廣泛地被應用在日常生活當中，特別是在必須做決策的脈絡下最常被用到。比如說，科科在期末考前的最後一天考慮要不要熬夜讀書，他可以這樣思考：如果熬夜讀書會精神不濟，考試就會考不好；如果不熬夜讀書就變成裸考，考試也會考不好；既然熬不熬夜都會考不好，那就乾脆不熬夜了。
					</p>
					<p>
					總之，所有類似「做什麼或不做什麼都會有怎樣的後果，所以我還是做（或不做）什麼比較好」的日常推論，基本上全部都是利用建構式兩難搭配選言句的恆真律所做的推論。這是一種很常見也很好用的推論方式。
					</p>
					<p>
					依慣例，介紹完六條等值規則以後，也是先來做一些練習題，熟悉一下這些規則的使用方式。（注意：以下的題目不只需要用到這六條等值規則，還需要用到前面學過的八條蘊涵規則）：
					</p>
					<div class="quiz">
						<ol class="pfq">
							<li>$&not;A&or;(B&and;&not;C)$</li>
							<li>$D&or;(&not;E&and;&not;C)$</li>
							<li>$C$</li>
							<li>$&not;A&and;D$</li>
						</ol>
						<ol class="pfq">
							<li>$&not;F&rarr;G$</li>
							<li>$&not;H&rarr;I$</li>
							<li>$&not;(F&or;H)$</li>
							<li>$G&and;I$</li>
						</ol>
						<ol class="pfq">
							<li>$&not;N&rarr;&not;O$</li>
							<li>$&not;(&not;P&and;&not;O)$</li>
							<li>$&not;P$</li>
							<li>$N$</li>
						</ol>
					</div><!--quiz-->
					<div class="quiz">
						<ol class="pfq">
							<li>$L&rarr;(&not;S&and;R)$</li>
							<li>$&not;M&rarr;R$</li>
							<li>$&not;(&not;L&and;M)$</li>
							<li>$R$</li>
						</ol>
						<ol class="pfq">
							<li>$(M&or;N)&or;P$</li>
							<li>$&not;(P&or;N)$</li>
							<li>$O&rarr;&not;M$</li>
							<li>$&not;O&and;M$</li>
						</ol>
						<ol class="pfq">
							<li>$&not;J&or;K$</li>
							<li>$J&or;(L&and;M)$</li>
							<li>$&not;K&or;M$</li>
							<li>$M$</li>
						</ol>
					</div><!--quiz-->
				</div><!--chap4 sect2 subsect3-->
				
				<div class="subsection" id="4-2-4">
					<h3>等值規則（二）</h3>
					<p>
					接下來要介紹的是剩下的四條等值規則，這四條等值規則都是和條件句或雙條件句有關的等值規則。以下是第一條規則：
					</p>
					<blockquote>
					<b>異值位換律 (Law of Contraposition，簡寫為 Contra.)</b>
						<p>
						$&alpha;&rarr;&beta;&equiv;&not;&beta;&rarr;&not;&alpha;$
						</p>
					</blockquote>
					<p>
					異值位換律告訴我們的是，任何一個條件句只要把前後件都加上否定號，再調換前後件的位置，就會得到一個和原本的條件句等值的條件句。
					</p>
					<p>
					我們可以用 MP 和 MT 這兩條規則來理解異值位換律為什麼成立。首先，在給定了 '$&alpha;&rarr;&beta;$' 的情況下，我們可以利用 MP 規則從 '$&alpha;$' 推論出 '$&beta;$'，也可以用 MT 規則從 '$&not;&beta;$' 推論出 '$&not;&alpha;$'；反過來說，在給定了 '$&not;&beta;&rarr;&not;&alpha;$' 的情況下，我們也可以用 MP 規則從 '$&not;&beta;$' 推論出 '$&not;&alpha;$'，以及用 MT 規則從 '$&alpha;$' 推論出 '$&beta;$'（因為根據 DN 規則，'$&alpha;$' 等值於 '$&not;&not;&alpha;$' 而 '$&beta;$' 也等值於 '$&not;&not;&beta;$'）。
					</p>
					<p>
					既然這兩個條件句可以用 MP 和 MT 規則做的推論是一模一樣的，而條件句又只允許 MP 和 MT 這兩個方向的推論，這表示 '$&alpha;&rarr;&beta;$' 和 '$&not;&beta;&rarr;&not;&alpha;$' 是等值的。
					</p>
					<p>
					異值位換律是一個很方便的規則，事實上，只要有了異值位換律，MP 和 MT 這兩條規則其實就只需要保留其中一條了。比如說，當我們只有 MP 規則，卻需要證明出以下推論：
					</p>
					<ol class="prfp">
						<li>$A&rarr;B$</li>
						<li>$&not;B$</li>
						<li>$&not;A$</li>
					</ol>
					<p>
					因為沒有 MT 規則，所以就不能直接透過否定後件律來推論出前件的否定，此時我們可以用異值位換律：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;B$</td><td>前提</td></tr>
						<tr><td>$&not;B&rarr;&not;A$</td><td>根據 1, Contra.</td></tr>
						<tr><td>$&not;B$</td><td>前提</td></tr>
						<tr><td>$&not;A$</td><td>MP</td></tr>
					</table>
					<p>
					除此以外，當我們要用假言三段論來合併條件句時，異值位換律也經常扮演關鍵的角色，例如當我們要證明以下推論為有效時：
					</p>
					<ol class="prfp">
						<li>$C&rarr;D$</li>
						<li>$E&rarr;&not;D$</li>
						<li>$C&rarr;&not;E$</li>
					</ol>
					<p>
					因為作為前提的兩個條件句並不符合使用假言三段論規則的條件，所以不能直接用假言三段論規則推出結論。但只要我們先對其中一個條件句做異值位換律之後，就能滿足使用假言三段論規則的條件：
					</p>
					<table class="prf">
						<tr><td>$C&rarr;D$</td><td>前提</td></tr>
						<tr><td>$E&rarr;&not;D$</td><td>前提</td></tr>
						<tr><td>$D&rarr;&not;E$</td><td>根據 2, Contra.</td></tr>
						<tr><td>$C&rarr;&not;E$</td><td>根據 1,3, HS</td></tr>
					</table>
					<p class="ind">
					接下來要介紹的規則雖然不是經常會被用到的規則，但也是一個方便的規則，而且只要稍微想一下，其實也很好理解為什麼會成立。這個規則就是：
					</p>
					<blockquote>
					<b>移出律 (Law of Exportation，簡寫為 Exp.)</b>
						<p>
						$(&alpha;&and;&beta;)&rarr;&gamma;&equiv;&alpha;&rarr;(&beta;&rarr;&gamma;)$
						</p>
					</blockquote>
					<p class="ind">
					先說明移出律從左邊到右邊的推論：當 '$(&alpha;&and;&beta;)&rarr;&gamma;$' 為真時，意思就是：當 '$&alpha;$' 和 '$&beta;$' 皆為真時，'$&gamma;$' 就會是真的。因此，當 '$&alpha;$' 為真的時候，我們就可以推論出，只要 '$&beta;$' 為真，'$&gamma;$' 就會是真的。也就是說，當 '$&alpha;$' 為真的時候，'$&beta;&rarr;&gamma;$' 就會是真的。因此 '$&alpha;&rarr;(&beta;&rarr;&gamma;)$' 為真。
					</p>
					<p>
					再說明移出律從右邊到左邊的推論：當 '$&alpha;&rarr;(&beta;&rarr;&gamma;)$' 為真時，意思就是：只要 '$&alpha;$' 為真，則 '$&beta;&rarr;&gamma;$' 就會是真的，而 '$&beta;&rarr;&gammap;$' 為真的意思是，只要 '$&beta;$' 為真，則 '$&gamma;$' 就會是真的。將兩者合併，則 '$&alpha;&rarr;(&beta;&rarr;&gamma;)$' 的意思就是：只要 '$&alpha;$' 為真，然後再讓 '$&beta;$' 也為真，則 '$&gamma;$' 就會是真的。換言之，只要 '$&alpha;$' 和 '$&beta;$' 皆為真，'$&gamma;$' 就會為真。因此 '$(&alpha;&and;&beta;)&rarr;&gamma;$' 為真。
					</p>
					<p>
					移出律在證明當中會被用到的時機其實不多，但有些特殊的情況下還是會用到它。比如以下論證，在沒有移出律的情況下，無法以我們目前學過的規則推論出來：
					</p>
					<ol class="prfp">
						<li>$(A&and;B)&rarr;C$</li>
						<li>$A$</li>
						<li>$B&rarr;C$</li>
					</ol>
					<p>
					這個論證所提供的兩個前提無法做出任何推論，除非我們有移出律：
					</p>
					<table class="prf">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$A&rarr;(B&rarr;C)$</td><td>根據 1, Exp.</td></tr>
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$B&rarr;C$</td><td>根據 1,3, MP</td></tr>
					</table>
					<p>
					一但我們有移出律可以使用，就可以把作為前提的語句 1 變化成語句 2，然後就能利用 '$A$' 和 MP 規則導出結論。
					</p>
					<p>
					除此以外，像是以下這個論證，在沒有移出律規則可以使用的情況下，也無法利用我們目前已經學過的推論規則推論出來：
					</p>
					<ol class="prfp">
						<li>$A&rarr;(B&rarr;C)$</li>
						<li>$&not;C$</li>
						<li>$&not;A&or;&not;B$</li>
					</ol>
					<p>
					一樣，這個論證提供的兩個前提也無法做任何的推論，除非有移出律：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;(B&rarr;C)$</td><td>前提</td></tr>
						<tr><td>$(A&and;B)&rarr;C$</td><td>根據 1, Exp.</td></tr>
						<tr><td>$&not;C$</td><td>前提</td></tr>
						<tr><td>$&not;(A&and;B)$</td><td>根據 1,3, MP</td></tr>
						<tr><td>$&not;A&or;&not;B$</td><td>根據 4, DeM</td></tr>
					</table>
					<p>
					根據我們目前學過的規則，必須要用移出律將作為前提的語句 1 變化為語句 2，然後才能用 MT 規則推論出 '$&not;(A&and;B)$'，最後才能用 DeM 推論出結論。
					</p>
					<p>
					不過要注意的是，我前面說的是在沒有移出律的情況下，我們不能用<b>目前已經學過的規則</b>推論出結論。之所以加上這個但書，是因為我等一下要介紹的規則就可以讓我們在沒有移出律的情況下推論出上述兩個推論。甚至是移出律本身，都可以用我等一下要介紹的規則證明出來：
					</p>
					<blockquote>
					<b>實質蘊涵律 (Law of Material Implication，簡寫為 Impl.)</b>
						<p>$&alpha;&rarr;&beta;&equiv;&not;&alpha;&or;&beta;$</p>
					</blockquote>
					<p>
					我在前面說過，語句邏輯中的條件句的全名叫做<b>實質條件句</b>，因為語句邏輯中的條件句要表達的就兩個語句之間的<b>實質蘊涵關係</b>。而實質蘊涵律基本上就是在說明實質蘊涵關係是一個怎樣的關係。
					</p>
					<p>
					在上一章定義真值函數時，其中的第五條規則就定義了實質蘊涵關係為真的條件：'$&alpha;&rarr;&beta;$' 為真，當且僅當，'$&alpha;$' 為假，或者 '$&beta;$' 為真。因此，僅僅從判斷實質條件句真假的方法，就可以看出實質蘊涵律為什麼成立了。因為：只要 '$&alpha;&rarr;&beta;$' 為真，就表示 '$&not;&alpha;$' 和 '$&beta;$' 之中至少有一個為真；反過來說，只要 '$&not;&alpha;$' 和 '$&beta;$' 之中至少有一個為真，則 '$&alpha;&rarr;&beta;$' 就會是真的。
					</p>
					<p>
					實質蘊涵律是一個經常被使用到的規則，也可以算是十八條規則中最常被使用到的規則之一，使用的時機非常廣泛。只要看到有條年句，但沒辦法直接做 MP 或 MT 或 HS 的時候，都可以用實質蘊涵律將條件句轉換成選言句，再看看可以做什麼操作。比如在介紹移出律時使用的那兩個例子，其實都可以用實質蘊涵律來推論：
					</p>
					<table class="prf">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$&not;(A&and;B)&or;C$</td><td>根據 1, Impl.</td></tr>
						<tr><td>$(&not;A&or;&not;B)&or;C$</td><td>根據 3, DeM</td></tr>
						<tr><td>$&not;A&or;(&not;B&or;C)$</td><td>根據 4, Assoc.</td></tr>
						<tr><td>$&not;A&or;(B&rarr;C)$</td><td>根據 5, Impl.</td></tr>
						<tr><td>$&not;&not;A$</td><td>根據 2, DN</td></tr>
						<tr><td>$B&rarr;C$</td><td>根據 6,7, DS</td></tr>
					</table>
					<p>
					在上述證明中，我先在第三步用實質蘊涵律將第一個前提轉換成語句 3，再用笛摩根定律將語句 3 的前半轉換成選言句，然後用結合律改變語句 4 的括號的位置，再將實質蘊涵律套用在語句 5 的右半部，最後用雙重否定將前提 '$A$' 變化成 '$&not;&not;A$'，然後就可以用選言三段論得到結論。
					</p>
					<p>
					但其實在倒數第二步的時候，我也可以不要用雙重否定將 '$A$' 變成 '$&not;&not;A$'，我可以再用一次實質蘊涵律，就能把語句 6 變化成一個條件句，然後直接用 MP 規則推出結論：
					</p>
					<table class="prf">
						<tr><td>$(A&and;B)&rarr;C$</td><td>前提</td></tr>
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$&not;(A&and;B)&or;C$</td><td>根據 1, Impl.</td></tr>
						<tr><td>$(&not;A&or;&not;B)&or;C$</td><td>根據 3, DeM</td></tr>
						<tr><td>$&not;A&or;(&not;B&or;C)$</td><td>根據 4, Assoc.</td></tr>
						<tr><td>$&not;A&or;(B&rarr;C)$</td><td>根據 5, Impl.</td></tr>
						<tr><td>$A&rarr;(B&rarr;C)$</td><td>根據 6, Impl.</td></tr>
						<tr><td>$B&rarr;C$</td><td>根據 2,7, MP</td></tr>
					</table>
					<p>
					這個步驟的改變其實說明了三件重要的事：一、證明的方法可以不只有一種，所以可以多做各種嘗試；二、在後面這一種證明的方法中，語句 1、3、4、5、6、7 其實就是用實質蘊涵律、笛摩根定律以及結合律這三個規則，證明了移出律從左邊到右邊的推論的有效性；三、另外，在此證明中的 2、6、7 到 C，就實就是用實質蘊涵律以及 MP 規則取代了選言三段論的證明。
					</p>
					<p>
					同樣的，第二個移出律的證明也可以用實質蘊涵律來證明：
					</p>
					<table class="prf">
						<tr><td>$A&rarr;(B&rarr;C)$</td><td>前提</td></tr>
						<tr><td>$&not;C$</td><td>前提</td></tr>
						<tr><td>$&not;A&or;(B&rarr;C)$</td><td>根據 1, Impl.</td></tr>
						<tr><td>$&not;A&or;(&not;B&or;C)$</td><td>根據 3, Impl.</td></tr>
						<tr><td>$(&not;A&or;&not;B)&or;C$</td><td>根據 4, Assoc.</td></tr>
						<tr><td>$&not;A&or;&not;B$</td><td>根據 2,5, DS</td></tr>
					</table>
					<p>
					在這個證明中，我們一樣可以從語句 5 繼續用實質蘊涵律和笛摩根定律（再加上雙重否定律）推論下去：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
						<tr><td>$(&not;A&or;&not;B)&or;C$</td><td>根據 4, Impl.</td></tr>
						<tr><td>$&not;(&not;A&or;&not;B)&rarr;C$</td><td>根據 5, Impl.</td></tr>
						<tr><td>$(&not;&not;A&and;&not;&not;B)&rarr;C$</td><td>根據 6, DeM</td></tr>
						<tr><td>$(A&and;B)&rarr;C$</td><td>根據 7, DN</td></tr>
						<tr class="noshow"><td>$&not;A&or;&not;B$</td><td>根據 2,5, DS</td></tr>
					</table>
					<p>
					如此一來，從語句 1 到語句 8（略過語句 2），就是用實質蘊涵律、結合律、笛摩根定律和雙重否定律，證明了移出律從右邊到左邊的推論的有效性。接續語句 8，我們可以用 MT 規則和笛摩根定律證明出結論：
					</p>
					<table class="prf" style="counter-reset:tprf 7">
						<tr><td>$(A&and;B)&rarr;C$</td><td>根據 7, DN</td></tr>
						<tr><td>$&not;(A&and;B)$</td><td>根據 2,8, MT</td></tr>
						<tr><td>$&not;A&or;&not;B$</td><td>根據 9, DeM</td></tr>
					</table>
					<p>
					另外，如果我們從語句 5 繼續往下做原本的證明，其實還有兩種不同的方法可以有效地推論出結論：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
						<tr><td>$(&not;A&or;&not;B)&or;C$</td><td>根據 4, Impl.</td></tr>
						<tr><td>$&not;(&not;A&or;&not;B)&rarr;C$</td><td>根據 5, Impl.</td></tr>
						<tr><td>$&not;&not;(&not;A&or;&not;B)$</td><td>根據 2,6, MT</td></tr>
						<tr><td>$&not;A&or;&not;B$</td><td>根據 7, DN</td></tr>
					</table>
					<p>
					或者：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
						<tr><td>$(&not;A&or;&not;B)&or;C$</td><td>根據 4, Impl.</td></tr>
						<tr><td>$&not;(&not;A&or;&not;B)&rarr;C$</td><td>根據 5, Impl.</td></tr>
						<tr><td>$&not;C&rarr;&not;&not;(&not;A&or;&not;B)$</td><td>根據 6, Contra.</td></tr>
						<tr><td>$&not;C&rarr;(&not;A&or;&not;B)$</td><td>根據 7, DN</td></tr>
						<tr><td>$&not;A&or;&not;B$</td><td>根據 2,8, MP</td></tr>
					</table>
					<p>
					以上的第一種證明方法證明了：用實質蘊涵律和 MT 規則（再加上雙重否定律）就可以取代選言三段論；而第二種證明方法則證明了：用異值位換律和 MP 規則（也是加上雙重否定律），那 MT 規則也可以被取代。
					</p>
					<p>
					從以上幾個例子可以看得出來，這十八條規則之間並不見得是彼此獨立的，意思是，有些規則其實可以用另外一些規則證明出來。換言之，就算我們剔除掉一些規則，原本可以證明出來的東西並不會變成證明不出來。
					</p>
					<p>
					那麼，有些讀者可能會因此產生以下疑惑：既然不需要那麼多規則也能證明出一樣多的東西，為什麼我們還需要十八條規則？其實沒錯，如果目的只是要證明出一樣多的東西的話，十八條規則確實是不必要的。但從上面幾個證明可以看得出來，當我們要省略某些規則的時候，證明往往會變得更複雜。
					</p>
					<p>
					比如說，在有移出律可用的情況下，從 <i>P18'</i> 和 <i>P19'</i> 要推論出 <i>C9'</i>，總共只需要五個步驟，但為了省略移出律，我們需要六個步驟才能完成證明。如果我們還要進一步用 MT 來取代 DS，就變成要用到八個步驟。如果還要進一步用 MP 和 Contra. 來取代 MT，則需要九個步驟。
					</p>
					<p>
					既然當我們有較多規則可以使用時，在系統中要做證明的時候就會變得比較容易些，那麼即使有些規則可以被其它規則來取代，保留下來也不見得是件壞事。但讀者到此可能又會產生另一個疑惑：既然愈多規則可以讓證明愈簡單，那是不是規則愈多愈好呢？這也不盡然是如此。
					</p>
					<p>
					一方面，當規則太多時，我們要在證明中使用時反而容易困惑，不知道該用什麼規則才好，因此有鑑於人類思考能力的侷限，規則也不是愈多愈好。此外，當我們要對這個證明系統做一些後設性質的證明（也就是要證明這個系統本身有哪些特性）的時候，太多的規則就會讓我們的後設證明變得更複雜。
					</p>
					<p>
					比如說，我在本章的最後一節將會介紹這個證明系統的健全性與完備性。這兩個性質都是關於這個證明系統的後設性質，健全性說的是：這個證明系統（也就是所有的推論規則）可以做出來的證明都是有效的證明；而完備性則是說，所有有效的證明都可以用這個證明系統做出來。當我們要證明這個系統具有這兩個性質的時候，就需要一條一條規則去檢查，此時當規則愈多的時候，我們需要檢查的項目就會變多。因此從這個角度來看，一個證明系統的規則反而是愈精簡愈好。
					</p>
					<p>
					稍微離題以後，我們回到實質蘊涵規則的使用時機。除了上述兩個原本可以用移出律來做的證明之外，還有另一些證明是必須用實質蘊涵律才能證明出來。例如：
					</p>
					<ol class="prfp">
						<li>$&not;A&or;B$</li>
						<li>$&not;B&or;C$</li>
						<li>$&not;A&or;C$</li>
					</ol>
					<p>
					我們必須用實質蘊涵律將兩個前提都變成條件句，再用假言三段論合併兩個條件句，最後再用實質蘊涵律將合併後的條件句改寫成選言句：
					</p>
					<table class="prf">
						<tr><td>$&not;A&or;B$</td><td>前提</td></tr>
						<tr><td>$&not;B&or;C$</td><td>前提</td></tr>
						<tr><td>$A&rarr;B$</td><td>根據 1, Impl.</td></tr>
						<tr><td>$B&rarr;C$</td><td>根據 2, Impl.</td></tr>
						<tr><td>$A&rarr;C$</td><td>根據 3,4, HS</td></tr>
						<tr><td>$&not;A&or;C$</td><td>根據 5, Impl.</td></tr>
					</table>
					<p>
					或者像以下這個論證，也需要用到實質蘊涵律才能證明：
					</p>
					<ol class="prfp">
						<li>$&not;A&or;B$</li>
						<li>$&not;C&or;D$</li>
						<li>$A&or;C$</li>
						<li>$B&or;D$</li>
					</ol>
					<p>
					我們一樣是先把前面兩個選言句用實質蘊涵律改寫成條件句，然後就可以用建構式兩難規則推論出結論：
					</p>
					<table class="prf">
						<tr><td>$&not;A&or;B$</td><td>前提</td></tr>
						<tr><td>$&not;C&or;D$</td><td>前提</td></tr>
						<tr><td>$A&or;C$</td><td>前提</td></tr>
						<tr><td>$A&rarr;B$</td><td>根據 1, Impl.</td></tr>
						<tr><td>$C&rarr;D$</td><td>根據 2, Impl.</td></tr>
						<tr><td>$B&or;D$</td><td>根據 3,4,5, CD</td></tr>
					</table>
					<p>
					而且最後一步的建構式兩難，其實也可以用實質蘊涵律加上異值位換律和假言三段論來取代：
					</p>
					<table class="prf" style="counter-reset:tprf 2">
						<tr><td>$A&or;C$</td><td>前提</td></tr>
						<tr><td>$A&rarr;B$</td><td>根據 1, Impl.</td></tr>
						<tr><td>$C&rarr;D$</td><td>根據 2, Impl.</td></tr>
						<tr><td>$&not;A&rarr;C$</td><td>根據 3, Impl.</td></tr>
						<tr><td>$&not;A&rarr;D$</td><td>根據 5,6, HS</td></tr>
						<tr><td>$&not;B&rarr;&not;A$</td><td>根據 4, Contra.</td></tr>
						<tr><td>$&not;B&rarr;D$</td><td>根據 7,8, HS</td></tr>
						<tr><td>$&not;&not;B&or;D$</td><td>根據 9, Impl.</td></tr>
						<tr><td>$B&or;D$</td><td>根據 10, DN</td></tr>
					</table>
					<p>
					此外，當我們要從一個語句求得由該語句作為後件的條件句，或者求得以該語句之否定句作為前件的條件句時，也必須用到實質蘊涵律，例如：
					</p>
					<table class="prf">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$&not;B&or;A$</td><td>根據 1, Add.</td></tr>
						<tr><td>$B&rarr;A$</td><td>根據 2, Impl.</td></tr>
					</table>
					<table class="prf follow">
						<tr><td>$A$</td><td>前提</td></tr>
						<tr><td>$A&or;B$</td><td>根據 1, Add.</td></tr>
						<tr><td>$&not;A&rarr;B$</td><td>根據 2, Impl.</td></tr>
					</table>
					<p>
					這兩個技巧在做證明時也非常有幫助，因為添加律可以添加任何語句，所以用這兩個技巧，你就可以在關鍵的時候製造出需要的條件句。
					</p>
					<p>
					接下來要介紹的，就是十八條規則中的最後一條規則，也是唯一一條和雙條件句有關的規則：
					</p>
					<blockquote>
					<b>實質等值律 (Law of Material Equivalence，簡寫為 Equiv.)</b>
						<ul class="list">
							<li>$&alpha;&harr;&beta;&equiv;(&alpha;&rarr;&beta;)&and;(&beta;&rarr;&alpha;)$</li>
							<li>$&alpha;&harr;&beta;&equiv;(&alpha;&and;&beta;)&or;(&not;&alpha;&and;&not;&beta;)$</li>
						</ul>
					</blockquote>
					<p>
					實質等值律在語意上也很好理解，之前在介紹實質雙條件句時就已經說過了，其實雙條件句就是兩個單條件句的縮寫。也就是說，'$&alpha;&harr;&beta;$' 的意思就是：'$&alpha;&rarr;&beta;$' 為真，而且 '$&beta;&rarr;&alpha;$' 為真。所以將後面這兩個單條件句用連言符號連接起來所形成的連言句，自然會和雙條件句等值。
					</p>
					<p>
					至於實質等值律的第二條，其實可以用第一條和實質蘊涵律，以及其它輔助的推論規則來證明：
					</p>
					<table class="prf bracket">
						<tr><td>$&alpha;&harr;&beta;$</td><td>前提</td></tr>
						<tr><td>$(&alpha;&rarr;&beta;)&and;(&beta;&rarr;&alpha;)$</td><td>1, Equiv.</td></tr>
						<tr><td>$(&not;&alpha;&or;&beta;)&and;(&not;&beta;&or;&alpha;)$</td><td>2, Impl.</td></tr>
						<tr><td>$((&not;&alpha;&or;&beta;)&and;&not;&beta;)&or;((&not;&alpha;&or;&beta;)&and;&alpha;)$</td><td>3, Dist.</td></tr>
						<tr><td>$(&not;&beta;&and;(&not;&alpha;&or;&beta;))&or;(&alpha;&and;(&not;&alpha;&or;&beta;))$</td><td>4, Comm.</td></tr>
						<tr><td>$((&not;&beta;&and;&not;&alpha;)&or;(&not;&beta;&and;&beta;))&or;((&alpha;&and;&not;&alpha;)&or;(&alpha;&and;&beta;))$</td><td>5, Dist.</td></tr>
						<tr><td>$(&not;&beta;&and;&not;&alpha;)&or;((&not;&beta;&and;&beta;)&or;((&alpha;&and;&not;&alpha;)&or;(&alpha;&and;&beta;)))$</td><td>6, Assoc.</td></tr>
						<tr><td>$(&not;&beta;&and;&not;&alpha;)&or;(((&not;&beta;&and;&beta;)&or;(&alpha;&and;&not;&alpha;))&or;(&alpha;&and;&beta;))$</td><td>7, Assoc.</td></tr>
						<tr><td>$(&not;&beta;&and;&not;&alpha;)&or;((&alpha;&and;&beta;)&or;((&not;&beta;&and;&beta;)&or;(&alpha;&and;&not;&alpha;)))$</td><td>8, Comm.</td></tr>
						<tr><td>$((&not;&beta;&and;&not;&alpha;)&or;(&alpha;&and;&beta;))&or;((&not;&beta;&and;&beta;)&or;(&alpha;&and;&not;&alpha;))$</td><td>9, Assoc.</td></tr>
						<tr><td>$((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;((&not;&beta;&and;&beta;)&or;(&alpha;&and;&not;&alpha;))$</td><td>10, Comm.</td></tr>
						<tr><td>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&or;(&alpha;&and;&not;&alpha;)$</td><td>11, Assoc.</td></tr>
						<tr><td>$((((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&or;&alpha;)&and;$<br/>$((((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&or;&not;&alpha;)$</td><td>12, Dist.</td></tr>
						<tr><td>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&or;&alpha;$</td><td>13, Simp.</td></tr>
						<tr><td>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&or;&not;&alpha;$</td><td>13, Simp.</td></tr>
						<tr><td>$&not;&alpha;&or;(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))$</td><td>15, Comm.</td></tr>
						<tr><td>$&not;(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&rarr;&alpha;$</td><td>14, Impl.</td></tr>
						<tr><td>$&alpha;&rarr;(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))$</td><td>16, Impl.</td></tr>
						<tr><td>$&not;(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&rarr;$<br/>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))$</td><td>17,18 HS</td></tr>
						<tr><td>$&not;&not;(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&or;$<br/>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))$</td><td>19 Impl.</td></tr>
						<tr><td>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))&or;$<br/>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;))$</td><td>20 DN</td></tr>
						<tr><td>$((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;(&not;&beta;&and;&beta;)$</td><td>21 Taut.</td></tr>
						<tr><td>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;&not;&beta;)&and;$<br/>$(((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;&beta;)$</td><td>22 Dist.</td></tr>
						<tr><td>$((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;&not;&beta;$</td><td>23 Simp.</td></tr>
						<tr><td>$((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;&beta;$</td><td>23 Simp.</td></tr>
						<tr><td>$&not;&beta;&or;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))$</td><td>24 Comm.</td></tr>
						<tr><td>$&not;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&rarr;&beta;$</td><td>25 Impl.</td></tr>
						<tr><td>$&beta;&rarr;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))$</td><td>26 Impl.</td></tr>
						<tr><td>$&not;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&rarr;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))$</td><td>27,28, HS</td></tr>
						<tr><td>$&not;&not;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))$</td><td>29, Impl.</td></tr>
						<tr><td>$((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))&or;((&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;))$</td><td>30, DN</td></tr>
						<tr><td>$(&alpha;&and;&beta;)&or;(&not;&beta;&and;&not;&alpha;)$</td><td>31, Taut.</td></tr>
						<tr><td>$(&alpha;&and;&beta;)&or;(&not;&alpha;&and;&not;&beta;)$</td><td>32, Comm.</td></tr>
					</table>
					<p class="ind">
					上面這個證明看起來很長很可怕，但其實很多步驟都是很瑣碎的步驟。我們可以把這個證明分成幾個不同的部分來看，這樣可以比較清楚看出來這個證明在做什麼。
					</p>
					<p>
					首先，步驟 1 到 6 是先用實質等值律的第一條，將一個雙條件句改寫成兩個條件句的連言，然後再用實質蘊涵律將兩個條件句分別都改寫成選言句，最後再用分配律（並在必要時用交換律來調整一下語句之間的相對位置），將兩個選言句的連言改寫成 '$&alpha;&and;&beta;$'、'$&not;&alpha;&and;&not;&beta;$'、'$&alpha;&and;&not;&alpha;$' 和 '$&beta;&and;&not;&beta;$' 等四個連言句的選言。
					</p>
					<p>
					其中特別值得注意的是，在四個選言項中，'$&alpha;&and;&not;&alpha;$' 和 '$&beta;&and;&not;&beta;$' 分別都是自相矛盾的語句，也就是說它們一定是假的。既然已知它們為假，那麼當它們出現在選言句中時，照理說可以用選言三段論將為假的選言項剔除，只保留另外一個選言項。
					</p>
					<p>
					但是要注意，我們目前沒有學到任何規則可以讓我們在證明中提取一個矛盾句的否定句，也沒有任何規則可以讓我們在不依賴任何前提的情況下就證明矛盾句的否定句。因此無法直接用選言亖段論將矛盾句從選言句當中剔除，所以需要用比較迂迴的方式來剔除它們。為了做到這件事，我在步驟 7 到 12 利用結合律和交換律，想辦法把那兩個矛盾句都調到選言句的最後面。然後在步驟 13 到 22，以及步驟 23 到 32 當中，分別將這兩個矛盾句從選言句當中剔除。
					</p>
					<p>
					為了更清楚地說明我在這兩個部分當中所做的事情，我將論證簡化如下。假設我們有一個選言句，而且這個選言句的其中一項是一個矛盾句，我們要證明在這個選言句中矛盾句以外的那一項為真，我們可以這樣證明：
					</p>
					<table class="prf">
						<tr><td>$&alpha;&or;(&beta;&and;&not;&beta;)$</td><td>前提</td></tr>
						<tr><td>$(&alpha;&or;&beta;)&and;(&alpha;&or;&not;&beta;)$</td><td>根據 1, Dist.</td></tr>
						<tr class="noshow"><td>$&alpha;&or;&beta;$</td><td>根據 2, Simp.</td></tr>
					</table>
					<p>
					先用分配律將 '$&alpha;$' 分配進 '$&beta;&and;&not;&beta;$' 之中，接著用簡化律將得到的連言句拆成兩個選言句：
					</p>
					<table class="prf" style="counter-reset:tprf 2">
						<tr><td>$&alpha;&or;&beta;$</td><td>根據 2, Simp.</td></tr>
						<tr><td>$&alpha;&or;&not;&beta;$</td><td>根據 2, Simp.</td></tr>
						<tr class="noshow"><td>$&not;&alpha;&rarr;&beta;$</td><td>根據 3, Impl.</td></tr>
					</table>
					<p>
					接著用實質蘊涵律將兩個選言句改寫成條件句，然後再用異值位換律改寫其中一個條件句：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
						<tr><td>$&not;&alpha;&rarr;&beta;$</td><td>根據 3, Impl.</td></tr>
						<tr><td>$&not;&alpha;&rarr;&not;&beta;$</td><td>根據 4, Impl.</td></tr>
						<tr><td>$&beta;&rarr;&alpha;$</td><td>根據 6, Contra.</td></tr>
						<tr class="noshow"><td>$&not;&beta;&rarr;&alpha;$</td><td>根據 4, Impl.</td></tr>
					</table>
					<p>
					最後就是用假言三段論來合併其中兩個條件句，然後再用實質蘊涵律將合併後的條件句改寫回選言句，最後就能用恆真律推論出結論：
					</p>
					<table class="prf" style="counter-reset:tprf 7">
						<tr><td>$&not;&alpha;&rarr;&alpha;$</td><td>根據 5,7, HS</td></tr>
						<tr><td>$&not;&not;&alpha;&or;&alpha;$</td><td>根據 8, Impl.</td></tr>
						<tr><td>$&alpha;&or;&alpha;$</td><td>根據 9, DN</td></tr>
						<tr><td>$&alpha;$</td><td>根據 10, Taut.</td></tr>
					</table>
					<p>
					在我們只有十八條規則可以用的情況下，這是把矛盾句從選言句當中剔除的證明中，最簡單也最有效率的方法了，可以的話請多揣摩熟悉這個證明方法的技巧。
					</p>
					<p>
					以上就是這個證明系統中所有可用的推論規則，一共十八條。其中有八條是蘊涵規則，這些規則必須使用在完整的語句上，不能只用在語句的一部分；另外十條則是等值規則，這些規則不只可以用在完整的語句上，也可以只用在語句的部分。為了讓各位能夠熟悉這十八條規則的使用，我一樣提供一些題目給大家練習：
					</p>
					<div class="quiz">
						<ol class="pfq">
							<li>$A&rarr;B$</li>
							<li>$&not;(B&and;&not;C)$</li>
							<li>$A&rarr;C$</li>
						</ol>
						<ol class="pfq">
							<li>$&not;M&or;N$</li>
							<li>$&not;R&rarr;&not;N$</li>
							<li>$M&rarr;R$</li>
						</ol>
						<ol class="pfq">
							<li>$A&and;(B&rarr;C)$</li>
							<li>$&not;(C&and;A)$</li>
							<li>$&not;B$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$A$</li>
							<li>$(&not;B&or;&not;C)&or;D$</li>
							<li>$&not;(C&and;B)&rarr;&not;A$</li>
							<li>$D$</li>
						</ol>
						<ol class="pfq">
							<li>$E&rarr;(&not;F&rarr;G)$</li>
							<li>$&not;F$</li>
							<li>$&not;G$</li>
							<li>$&not;E$</li>
						</ol>
						<ol class="pfq">
							<li>$H&harr;(I&and;J)$</li>
							<li>$&not;H&rarr;I$</li>
							<li>$J&or;H$</li>
							<li>$H$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$H&rarr;K$</li>
							<li>$C&harr;D$</li>
							<li>$&not;C&rarr;&not;K$</li>
							<li>$H&rarr;D$</li>
						</ol>
						<ol class="pfq">
							<li>$D&or;&not;A$</li>
							<li>$&not;(A&and;&not;B)&rarr;&not;C$</li>
							<li>$&not;D$</li>
							<li>$&not;C$</li>
						</ol>
						<ol class="pfq">
							<li>$(A&and;B)&rarr;R$</li>
							<li>$A$</li>
							<li>$C&rarr;&not;R$</li>
							<li>$&not;(C&and;B)$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$&not;A$</li>
							<li>$(A&or;B)&harr;C$</li>
							<li>$&not;B$</li>
							<li>$&not;(C&and;D)$</li>
						</ol>
						<ol class="pfq">
							<li>$W&harr;Y$</li>
							<li>$&not;W&or;&not;Y$</li>
							<li>$X&rarr;(Y&and;Z)$</li>
							<li>$&not;X$</li>
						</ol>
						<ol class="pfq">
							<li>$&not;(D&or;C)$</li>
							<li>$&not;C&rarr;(A&rarr;&not;B)$</li>
							<li>$A&rarr;B$</li>
							<li>$&not;A$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$&not;H$</li>
							<li>$H&or;K$</li>
							<li>$L&rarr;H$</li>
							<li>$&not;(K&and;&not;L)&or;(&not;L&and;M)$</li>
							<li>$M$</li>
						</ol>
						<ol class="pfq">
							<li>$(H&or;K)&rarr;(A&rarr;B)$</li>
							<li>$(H&or;M)&rarr;(C&rarr;D)$</li>
							<li>$(H&or;N)&rarr;(A&or;C)$</li>
							<li>$L&and;H$</li>
							<li>$B&or;D$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$R&rarr;(&not;A&and;T)$</li>
							<li>$B&or;&not;S$</li>
							<li>$R&or;S$</li>
							<li>$A&rarr;B$</li>
						</ol>
						<ol class="pfq">
							<li>$A&or;B$</li>
							<li>$C$</li>
							<li>$(A&and;C)&rarr;D$</li>
							<li>$D&or;B$</li>
						</ol>
						<ol class="pfq">
							<li>$(D&or;E)&harr;F$</li>
							<li>$&not;(D&or;G)$</li>
							<li>$&not;(&not;E&rarr;G)$</li>
							<li>$&not;(F&and;&not;D)$</li>
						</ol>
					</div>
					<div class="quiz">
						<ol class="pfq">
							<li>$(W&harr;T)&harr;&not;T$</li>
							<li>$&not;T&and;S$</li>
							<li>$R&rarr;&not;S$</li>
							<li>$&not;R&and;&not;W$</li>
						</ol>
						<ol class="pfq">
							<li>$(L&or;M)&or;N$</li>
							<li>$(L&or;N)&rarr;&not;O$</li>
							<li>$&not;M$</li>
							<li>$&not;(M&or;O)$</li>
						</ol>
						<ol class="pfq">
							<li>$(W&and;R)&rarr;P$</li>
							<li>$T&rarr;&not;P$</li>
							<li>$W$</li>
							<li>$&not;(T&and;R)$</li>
						</ol>
					</div>
				</div><!--chap4 sect2 subsect4-->
			</div><!--chap4 sect2-->
			
			<div class="section" id="4-3">
				<h2>條件證法</h2>
				<p>
				最後要跟大家介紹的是一個證明方法，你也可以把它看成是這個證明系統中的第十九條規則。但嚴格說起來，它其實不是一個推論規則，而是這個證明系統的一個後設規則。以下是對這個規則的描述：
				</p>
				<blockquote>
				<b>條件證法 (Conditional Proof，簡寫為 CP)</b>
					<p>
					令 '$\&Gamma;$' 為任意一組語句的集合：<br/>
					當 $\&Gamma;,&alpha;&vdash;&beta;$，則 $\&Gamma;&vdash;&alpha;&rarr;&beta;$
					</p>
				</blockquote>
				<p class="ind">
				根據條件證法，如果我們可以用一組語句（不論有多少個語句）作為前提，並根據有效的推論規則推論出一個結論。例如：
				</p>
				<ol class="cpfs">
					<li>前提語句 $1$</li>
					<li>前提語句 $2$</li>
					<li>前提語句 $3$</li>
					<li class="ellip">&vellip;</li>
					<li>前提語句 $m$</li>
					<li>前提語句 $m+1$</li>
					<li>前提語句 $m+2$</li>
					<li class="ellip">&vellip;</li>
					<li>前提語句 $n$</li>
					<li>結論語句</li>
				</ol>
				<p>
				那麼，如果我們把任意一個前提語句從前提中拿掉，然後以拿掉的前提語句為前件，並以結論語句為後件，寫成一個條件句。則，剩下來的前提語句也可以有效地推論出那個條件句。也就是說，如果我們把上面那個論證改成：
				</p>
				<ol class="cpfs gai">
					<li>前提語句 $1$</li>
					<li>前提語句 $2$</li>
					<li>前提語句 $3$</li>
					<li class="ellip">&vellip;</li>
					<li>前提語句 $m+1$</li>
					<li>前提語句 $m+2$</li>
					<li>前提語句 $m+3$</li>
					<li class="ellip">&vellip;</li>
					<li>前提語句 $n$</li>
					<li>前提語句 $m&rarr;結論語句$</li>
				</ol>
				<p>
				這個改過的論證也會是一個有效論證，新論證的前提也可以有效地推論出新結論。
				</p>
				<p>
				仔細比較上下兩個論證的差異：首先，下面這個論證的結論和上面那個論證的結論不同。下面這個論證的結論是一個條件句，而且條件句的前件是上面那個論證的第 $n$ 個前提，也就是「前提語句 $n$」，而條件句的後件則是上面那個論證的結論，也就是「結論語句」。
				</p>
				<p>
				除此以外，下面這個論證使用的前提語句也比上面那個論證少一個，而且少掉的那個前提剛好就是拿到結論被當成條件句前件的「前提語句 $n$」，至於其它的前提語句則全部都保持不變。
				</p>
				<p>
				而條件證法說的就是：只要上面那個論證是一個有效論證，則下面這個論證也會是一個有效論證。
				</p>
				<p>
				如果這個說明依然太過抽象，你仍然不清楚條件證法究竟在說什麼，我們就用實際的例子來看看條件證法允許我們做怎樣的證明。例如：
				</p>
				<ol class="prfp">
					<li>$A&rarr;B$</li>
					<li>$A&rarr;(A&and;B)$</li>
				</ol>
				<p>
				要用 <i>P25'</i> 這個前提有效地推論出 <i>C12'</i> 這個結論，以我們之前所學的十八條規則其實辦不到這件事。但是如果用歸謬樹枝法來檢查，不難發現這也是一個有效的推論：
				</p>
				<div class="tree2">
					<span>$A&rarr;B$</span><br/>
					<span>$&not;(A&rarr;(A&and;B)$</span>
					<svg width="300px"><path d="M150 0 L150 24"/></svg>
					<span>$A&rarr;B$</span><br/>
					<span>$A$</span><br/>
					<span>$&not;(A&and;B)$</span>
					<svg width="300px"><path d="M150 1 L75 23"/><path d="M150 1 L225 23"/></svg>
					<div>
						<span>$A&rarr;B$</span><br/>
						<svg class="back"><circle cx="75" cy="12" r="11"/></svg>
						<span>$A$</span><br/>
						<svg class="back"><ellipse cx="75" cy="12" rx="20" ry="11"/></svg>
						<span>$&not;A$</span><br/>
						<span>&cross;</span>
					</div>
					<div>
						<span>$A&rarr;B$</span><br/>
						<span>$A$</span><br/>
						<span>$&not;B$</span><br/>
						<svg width="150px"><path d="M75 1 L37.5 23"/><path d="M75 1 L112.5 23"/></svg>
						<div>
							<svg class="back"><ellipse cx="37.5" cy="12" rx="20" ry="11"/></svg>
							<span>$&not;A$</span><br/>
							<svg class="back"><circle cx="37.5" cy="12" r="11"/></svg>
							<span>$A$</span><br/>
							<span>$&not;B$</span><br/>
							<span>&cross;</span>
						</div>
						<div>
							<svg class="back"><circle cx="37.5" cy="12" r="11"/></svg>
							<span>$B$</span><br/>
							<span>$A$</span><br/>
							<svg class="back"><ellipse cx="37.5" cy="12" rx="20" ry="11"/></svg>
							<span>$&not;B$</span><br/>
							<span>&cross;</span>
						</div>
					</div>
				</div><!--tree2-->
				<p>
				根據歸謬樹枝法的檢查，這果然是一個有效論證，但我們目前所學過的十八條規則卻無法證明這個推論是有效的，這表示由先前介紹的那十八條規則所構成的證明系統尚有不足之處。為了補上這個不足之處，我們需要條件證法。
				</p>
				<p>
				條件證法要如何使用呢？我們就以上面那個論證為例，試著用條件證法來證明該論證確實有效：
				</p>
				<table class="prf">
					<tr><td>$A&rarr;B$</td><td>前提</td></tr>
					<tr><td>$A$</td><td>假設</td></tr>
					<tr><td>$B$</td><td>根據 1,2, MP</td></tr>
					<tr><td>$A&and;B$</td><td>根據 2,3, Conj.</td></tr>
					<tr><td>$A&rarr;(A&and;B)$</td><td>根據 2,4, CP</td></tr>
				</table>
				<p>
				在這個證明中，第 2 步是其中之一的關鍵，我們在第 2 步時引入了一個既不是前提語句，也不是由位在它前面的語句用有效的推論規則推論出來的，第 2 步中引入的語句是我們為了使用條件證法而<b>暫時假設</b>的一個前提。
				</p>
				<p>
				當我們暫時假設了 '$A$' 也是可以使用的前提之後，我們就可以利用原本被題目給定的前提 '$A&rarr;B$'，以及我們自己假設的前提 '$A$'，有效地推論出 '$A&and;B$'。而這就表示：'$A&rarr;B$' 和 '$A$' 會共同蘊涵 '$A&and;B$'。也就是說，只要 '$A&rarr;B$' 和 '$A$' 都為真，那麼 '$A&and;B$' 就會為真。
				</p>
				<p>
				可是題目所提供的前提只有 '$A&rarr;B$'，沒有 '$A$'，因此我們需要想辦法把 '$A$' 這個前提給取消掉，我們需要知道：在沒有假設前提的幫助之下，'$A&rarr;B$' 這個前提本身可以推論出什麼。
				</p>
				<p>
				這時候，剛剛藉由原本的前提和假設前提供同推論出來的結論就很有幫助了。我們說，因為 '$A&rarr;B$' 和 '$A$' 可以共同有效地推論出 '$A&and;B$'，而這意味著當 '$A&rarr;B$' 和 '$A$' 都為真時，'$A&and;B$' 也會為真。因此我們可以知道：當 '$A&rarr;B$' 為真時，只要 '$A$' 為真，則 '$A&and;B$' 就會為真。
				</p>
				<p>
				「只要 '$A$' 為真，則 '$A&and;B$' 就會為真」的意思，其實就是：'$A&rarr;(A&and;B)$' 為真。因此，從以上的討論我們可以知道，只要 '$A&rarr;B$' 和 '$A$' 可以共同有效地推論出 '$A&and;B$'，那麼 '$A&rarr;B$' 本身就可以推論出 '$A&rarr;(A&and;B)$'。
				</p>
				<p>
				因此，上面那個證明的第 5 步就是條件證法的第二個關鍵步驟：在我們利用假設前提推論出某個結論之後，我們就把假設的那個前提移到結論之中作為條件句的前件，並將原本推論出來的結論當成條件句的後件。這樣我們就可以把假設出來的前提取消，並證明：從原本的前提可以有效地推論出那個以假設前提為前件，並以假設前提可以推論出來的結論為後件的條件句。
				</p>
				<p>
				由於條件證法的最後一個步驟是要把假設的前提移到結論的前件，得到一個條件句，因此條件證法多半是在我們需要求得的結論是條件句時使用。我們可以先假設要證明的條件句的前件為真，然後試著推論出我們要證明的條件句的後件，最後再透過取消假設前提的方式，將假設的前提移到剛才證明出來的結論的前件位置，就能證得我們真正要證明的條件句。
				</p>
				<p>
				不過條件證法也不是只能用來證明條件句的結論，事實上，只要在證明結論的過程當中需要用到某個條件句，而我們不容易直接證明該條件句時，這種情況下也可以用條件證法來證明。比如說：
				</p>
				<ol class="prfp">
					<li>$D&rarr;(E&and;F)$</li>
					<li>$A&rarr;(C&and;&not;B)$</li>
					<li>$A&or;D$</li>
					<li>$E&or;&not;B$</li>
				</ol>
				<p>
				這個論證的結論是一選言句，但我們知道透過實質蘊涵律，我們可以將條件句 '$&not;E&rarr;&not;B$' 改寫成論證要求的結論。因此這時候我們就可以先假設 '$&not;E$'，然後證明出 '$&not;B$'，再用條件證法將假設的前提取消並置入結論的前件，以求得 '$&not;E&rarr;&not;B$'，最後就能用實質蘊涵律求得結論：
				</p>
				<table class="prf">
					<tr><td>$D&rarr;(E&and;F)$</td><td>前提</td></tr>
					<tr><td>$A&rarr;(C&and;&not;B)$</td><td>前提</td></tr>
					<tr><td>$A&or;D$</td><td>前提</td></tr>
					<tr><td>$&not;E$</td><td>假設</td></tr>
					<tr><td>$&not;E&or;&not;F$</td><td>根據 4, Add.</td></tr>
					<tr><td>$&not;(E&and;F)$</td><td>根據 5, DeM</td></tr>
					<tr><td>$&not;D$</td><td>根據 1,6, MT</td></tr>
					<tr><td>$A$</td><td>根據 3,7, DS</td></tr>
					<tr><td>$C&and;&not;B$</td><td>根據 2,8, MP</td></tr>
					<tr><td>$&not;B$</td><td>根據 9, Simp.</td></tr>
					<tr><td>$&not;E&rarr;&not;B$</td><td>根據 4,10, CP</td></tr>
					<tr><td>$&not;&not;E&or;&not;B$</td><td>根據 11, Impl.</td></tr>
					<tr><td>$E&or;&not;B$</td><td>根據 12, DN</td></tr>
				</table>
				<p>
				這個論證其實也可以用十八條規則直接證明出來，但證明的過程比較繁瑣，如果我們用條件證法來證明的話，則可以大幅降低證明的複雜程度。我們來看看只用十八條規則的話要如何證明：
				</p>
				<table class="prf">
					<tr><td>$D&rarr;(E&and;F)$</td><td>前提</td></tr>
					<tr><td>$A&rarr;(C&and;&not;B)$</td><td>前提</td></tr>
					<tr><td>$A&or;D$</td><td>前提</td></tr>
					<tr><td>$&not;A&rarr;D$</td><td>根據 3, Impl.</td></tr>
					<tr><td>$&not;A&rarr;(E&and;F)$</td><td>根據 1,4, HS</td></tr>
					<tr><td>$&not;(C&and;&not;B)&rarr;&not;A$</td><td>根據 2, Contra.</td></tr>
					<tr><td>$&not;(C&and;&not;B)&rarr;(E&and;F)$</td><td>根據 5,6, HS</td></tr>
					<tr><td>$&not;&not;(C&and;&not;B)&or;(E&and;F)$</td><td>根據 7, Impl.</td></tr>
					<tr><td>$(C&and;&not;B)&or;(E&and;F)$</td><td>根據 8, DN</td></tr>
					<tr><td>$((C&and;&not;B)&or;E)&and;((C&and;&not;B)&or;F)$</td><td>根據 9, Dist.</td></tr>
					<tr><td>$(C&and;&not;B)&or;E$</td><td>根據 10, Simp.</td></tr>
					<tr><td>$E&or;(C&and;&not;B)$</td><td>根據 11, Assoc.</td></tr>
					<tr><td>$(E&or;C)&and;(E&or;&not;B)$</td><td>根據 12, Dist.</td></tr>
					<tr><td>$E&or;&not;B$</td><td>根據 12, Dist.</td></tr>
				</table>
				<p>
				雖然這兩個證明的長度其實差不多，使用條件證法時只縮短了一個步驟。但從證明的每個步驟必須處理的語句長度和複雜度來看，顯然使用條件證法時，每個步驟的語句長度都明顯比只有十八條規則時來得短得多，這就能降低我們在處理每個步驟的語句時候難度。
				</p>
				<p>
				我們再來看另外一個例子：
				</p>
				<ol class="prfp">
					<li>$(M&or;N)&rarr;O$</li>
					<li>$S&rarr;(P&rarr;N)$</li>
					<li>$S&rarr;(P&rarr;O)$</li>
				</ol>
				<p>
				我們這次先嘗試直接用十八條規則來證明看看：
				</p>
				<table class="prf">
					<tr><td>$(M&or;N)&rarr;O$</td><td>前提</td></tr>
					<tr><td>$S&rarr;(P&rarr;N)$</td><td>前提</td></tr>
					<tr><td>$(S&and;P)&rarr;N$</td><td>根據 2, Exp.</td></tr>
					<tr><td>$&not;(M&or;N)&or;O$</td><td>根據 1, Impl.</td></tr>
					<tr><td>$(&not;M&and;&not;N)&or;O$</td><td>根據 4, DeM</td></tr>
					<tr><td>$O&or;(&not;M&and;&not;N)$</td><td>根據 5, Comm.</td></tr>
					<tr><td>$(O&or;&not;M)&and;(O&or;&not;N)$</td><td>根據 6, Dist.</td></tr>
					<tr><td>$O&or;&not;N$</td><td>根據 7, Simp.</td></tr>
					<tr><td>$&not;N&or;O$</td><td>根據 8, Comm.</td></tr>
					<tr><td>$N&rarr;O$</td><td>根據 9, Impl.</td></tr>
					<tr><td>$(S&and;P)&rarr;O$</td><td>根據 3,10, HS</td></tr>
					<tr><td>$S&rarr;(P&rarr;O)$</td><td>根據 11, Exp.</td></tr>
				</table>
				<p>
				我們接著再用條件證法來證明看看：
				</p>
				<table class="prf">
					<tr><td>$(M&or;N)&rarr;O$</td><td>前提</td></tr>
					<tr><td>$S&rarr;(P&rarr;N)$</td><td>前提</td></tr>
					<tr><td>$S$</td><td>假設</td></tr>
					<tr><td>$P$</td><td>假設</td></tr>
					<tr><td>$P&rarr;N$</td><td>根據 2,3, MP</td></tr>
					<tr><td>$N$</td><td>根據 4,5, MP</td></tr>
					<tr><td>$M&or;N$</td><td>根據 6, Add.</td></tr>
					<tr><td>$O$</td><td>根據 1,7, MP</td></tr>
					<tr><td>$(P&rarr;O)$</td><td>根據 4,8, CP</td></tr>
					<tr><td>$S&rarr;(P&rarr;O)$</td><td>根據 3,9, CP</td></tr>
				</table>
				<p>
				一樣，雖然用條件證法只讓證明的長度少了兩個步驟，但可以明顯看出來的是，每一個步驟的語句結構都簡單很多，而且每一步需要做什麼或可以做什麼都非常的清楚，不太需要試誤。因此多了條件證法之後，不但有些原本證明不出來的有效論證變得可以證明了，而且原本可以直接用十八條規則證明出來的有效論證，也可以用條件證法來降低證明的難度。
				</p>
				<p>
				但是為了要使用條件證法，我們必須先假設本來沒有的前提，並且需要在得到結論之前將假設的前提取消，否則就不能證明這個結論真的可以用原本的前提有效地推論出來。因此，注意自己最後得到的結論是否真的沒有依賴在假設的前提之上就是很關鍵的問題。因此我們需要新的記號方式，來幫助我們確認在做證明的時候，每一個步驟到底都依賴在哪些前提之上。我們就以上面那個證明作為示範：
				</p>
				<table class="cprf">
					<tr><td>{1}</td><td>$(M&or;N)&rarr;O$</td><td>前提</td></tr>
					<tr><td>{2}</td><td>$S&rarr;(P&rarr;N)$</td><td>前提</td></tr>
					<tr><td>{3}</td><td>$S$</td><td>假設</td></tr>
					<tr><td>{4}</td><td>$P$</td><td>假設</td></tr>
					<tr><td>{2,3}</td><td>$P&rarr;N$</td><td>根據 2,3, MP</td></tr>
					<tr><td>{2,3,4}</td><td>$N$</td><td>根據 4,5, MP</td></tr>
					<tr><td>{2,3,4}</td><td>$M&or;N$</td><td>根據 6, Add.</td></tr>
					<tr><td>{1,2,3,4}</td><td>$O$</td><td>根據 1,7, MP</td></tr>
					<tr><td>{1,2,3}</td><td>$(P&rarr;O)$</td><td>根據 4,8, CP</td></tr>
					<tr><td>{1,2}</td><td>$S&rarr;(P&rarr;O)$</td><td>根據 3,9, CP</td></tr>
				</table>
				<p>
				要注意的是，在這個新的寫法中，每一個步驟的最前面都多了一組大括號 '{}'，這組大括號是用來標示說，這個步驟所得到的語句是依賴在哪些前提之上。
				</p>
				<p>
				以前四個步驟為例，因為這四個語句全部都是前提（或者被假設的前提），所以它們都只依賴在自己之上，所以它們前面的大括號中就只有代表著它們自己的號碼。而第 5 個步驟的語句是用語句 2 和 3 共同推論出來的，而語句 2 和 3 分別都是前提，因此語句 5 前面的大括號中就標示了這個語句依賴在 2、3 這兩個前提之上。
				</p>
				<p>
				接下來的語句 6 則是用語句 4 和 5 共同推論出來的，因此 6 就會依賴在語句 4 和 5 之上。但語句 5 本身並不是前提，而是從語句 2 和 3 這兩個前提推論出來的，因此我們就要用語句 5 所依賴的語句來取代 5 本身，所以語句 6 實際上是依賴在 2、3、4 這三個前提之上。
				</p>
				<p>
				接下來的步驟就以此類推，直到第 9 步驟開始，就是我們要取消前提的時候了。在步驟 8 的時候，我們利用了 1、2、3、4 這四個前提推論出了 '$O$'。因此在步驟 9 的時候，我們要將其中的假設前提 4 取消，因此將假設前提 4 的 '$P$' 從大括號裡移出來，然後把它當成語句 8 的前件寫成一個條件句 '$P&rarr;O$'，這樣就成功地取消了假設前提 4。
				</p>
				<p>
				取消了假設前提 4 以後，我們就能確定在步驟 9 得到的 '$P&rarr;O$' 只有依賴在前提 1、2、3 之上。但其中的前提 3 也是一個假設前提，所以為了取消它，我們再次把這個假設前提從大括號中拿出來，並且讓它成為語句 9 的前件，寫成一個新的條件句：'$S&rarr;(P&rarr;O)$'。這樣就成功地取消了假設前提 3。
				</p>
				<p>
				在成功地取消了假設前提 4，並且也成功地取消了假設前提 3 之後，我們就能確定最後得到的 '$S&rarr;(P&rarr;O)$' 只會依賴在前提 1 和 2 之上。而前提 1 和 2 本來就是我們可以使用的前提，所以我們就成功地用條件證法證明了：從前提 <i>P29'</i> 和 <i>P30'</i> 可以有效地推論出結論 <i>C14'</i>。
				</p>
				<p>
				條件證法固然可以幫助我們降低許多論證的難度，但之所以要引入條件證法這個規則，最主要的理由還是為了我們一開始所提到的：有些有效的論證無法直接用十八條規則證明出來，因此需要條件證法來幫助我們證明這些論證的有效性。
				</p>
				<p>
				前提舉過一個必須用條件證法才能證明出來的有效論證，就是要用前提 <i>P25'</i> 推論出結論 <i>C12'</i> 的那個論證。不過條件證法最主要的功能其實是要證明恆真句。
				</p>
				<p>
				前提在說明條件證法的使用時，我提到的<b>依賴</b>這個概念。我說，當我們用一些前提有效地推論出某個結論時，我們其實是在證明「結論語句」的真，是依賴在那些被使用到的前提語句之上的。換言之，證明一個推論是有效的，其實就是在證明：給定前提語句都為真，則可以保證結論為真。
				</p>
				<p>
				然而恆真句是一種很特別的語句，恆真句在所有語意模型底下皆為真，也就是說，我們找不到任何情況可以使恆真句為假。意思就是，恆真句的真其實不依賴在任何前提之上，恆真句自己就為真。既然恆真句的真不依賴在任何前提之上，這表示，我們不需要任何前提就可以有效地推論出任何恆真句。
				</p>
				<p>
				可是我們在上一節中所學到的十八條規則，沒有任何一條允許我們在沒有前提的情況下做推論。每一條規則都只告訴我們，當我們有什麼前提的時候，可以推論出什麼結論。因此，僅僅依賴十八條規則，沒有辦法證明恆真句。
				</p>
				<p>
				然而條件證法允許我們在沒有任何前提的情況下自行假設一個暫時的前提，並且在得到結論之前將這個前提取消。所以給定條件證法，我們就可以在沒有前提的情況下做證明，並且可以證明出不依賴在任何前提之上的恆真句。底下就來試著證明幾個恆真句：
				</p>
				<ol class="urm">
					<li>
					$A&rarr;(B&rarr;A)$
						<table class="cprf">
							<tr><td>{1}</td><td>$A$</td><td>假設</td></tr>
							<tr><td>{1}</td><td>$&not;B&or;A$</td><td>根據 1, Add.</td></tr>
							<tr><td>{1}</td><td>$B&rarr;A$</td><td>根據 2, Impl.</td></tr>
							<tr><td>{}</td><td>$A&rarr;(B&rarr;A)$</td><td>根據 1,3, CP</td></tr>
						</table>
					</li>
				</ol>
				<p>
				因為要證明恆真句的時候不能使用任何前提，所以我們在第 1 步只好自己先假設一個前提，然後從這個前提一步一步往後推論，直到第 4 步時，我們將自己假設的那個前提取消，置於步驟 3 所得到的那個語句的前件，形成一個條件句。而得到的條件句正好就是我們要證明的恆真句，故得證。接著來看更多例子：
				</p>
				<ol class="urm">
					<li>$A&or;&not;A$
						<table class="cprf">
							<tr><td>{1}</td><td>$&not;A$</td><td>假設</td></tr>
							<tr><td>{}</td><td>$&not;A&rarr;&not;A$</td><td>根據 1, CP</td></tr>
							<tr><td>{}</td><td>$A&or;&not;A$</td><td>根據 2, Impl.</td></tr>
						</table>
					</li>
					<li>$A&rarr;(A&or;B)
						<table class="cprf">
							<tr><td>{1}</td><td>$A$</td><td>假設</td></tr>
							<tr><td>{1}</td><td>$A&or;B$</td><td>根據 1, Add.</td></tr>
							<tr><td>{}</td><td>$A&rarr;(A&or;B)$</td><td>根據 1,2, CP</td></tr>
						</table>
					</li>
					<li>(A&rarr;(B&rarr;C))&rarr;((A&rarr;B)&rarr;(A&rarr;C))
						<table class="cprf bracket">
							<tr><td>{1}</td><td>$A&rarr;(B&rarr;C)$</td><td>假設</td></tr>
							<tr><td>{2}</td><td>$A&rarr;B$</td><td>假設</td></tr>
							<tr><td>{1}</td><td>$(A&and;B)&rarr;C$</td><td>根據 1, Exp.</td></tr>
							<tr><td>{1}</td><td>$(B&and;A)&rarr;C$</td><td>根據 3, Comm.</td></tr>
							<tr><td>{1}</td><td>$B&rarr;(A&rarr;C)$</td><td>根據 4, Exp.</td></tr>
							<tr><td>{1,2}</td><td>$A&rarr;(A&rarr;C)$</td><td>根據 2,5, HS</td></tr>
							<tr><td>{1,2}</td><td>$(A&and;A)&rarr;C$</td><td>根據 6, Exp.</td></tr>
							<tr><td>{1,2}</td><td>$A&rarr;C$</td><td>根據 7, Taut.</td></tr>
							<tr><td>{1}</td><td>$(A&rarr;B)&rarr;(A&rarr;C)$</td><td>根據 2,8, CP</td></tr>
							<tr><td>{}</td><td>$(A&rarr;(B&rarr;C))&rarr;((A&rarr;B)&rarr;(A&rarr;C))$</td><td>根據 1,9, CP</td></tr>
						</table>
					</li>
					<li>$(A&harr;B)&harr;(&not;A&harr;&not;B)$
						<table class="cprf">
							<tr><td>{1}</td><td>$A&harr;B$</td><td>假設</td></tr>
							<tr><td>{1}</td><td>$(A&rarr;B)&and;(B&rarr;A)$</td><td>根據 1, Equiv.</td></tr>
							<tr><td>{1}</td><td>$A&rarr;B$</td><td>根據 2, Simp.</td></tr>
							<tr><td>{1}</td><td>$B&rarr;A$</td><td>根據 2, Simp.</td></tr>
							<tr><td>{1}</td><td>$&not;B&rarr;&not;A$</td><td>根據 3, Contra.</td></tr>
							<tr><td>{1}</td><td>$&not;A&rarr;&not;B$</td><td>根據 4, Contra.</td></tr>
							<tr><td>{1}</td><td>$(&not;A&rarr;&not;B)&and;(&not;B&rarr;&not;A)$</td><td>根據 5,6, Conj.</td></tr>
							<tr><td>{1}</td><td>$&not;A&harr;&not;B$</td><td>根據 7, Equiv.</td></tr>
							<tr><td>{}</td><td>$(A&harr;B)&rarr;(&not;A&harr;&not;B)$</td><td>根據 1,8, CP</td></tr>
							<tr><td>{10}</td><td>$(&not;A&harr;&not;B)$</td><td>假設</td></tr>
							<tr><td>{10}</td><td>$(&not;A&rarr;&not;B)&and;(&not;B&rarr;&not;A)$</td><td>根據 10, Equiv.</td></tr>
							<tr><td>{10}</td><td>$&not;A&rarr;&not;B$</td><td>根據 11, Simp.</td></tr>
							<tr><td>{10}</td><td>$&not;B&rarr;&not;A$</td><td>根據 11, Simp.</td></tr>
							<tr><td>{10}</td><td>$B&rarr;A$</td><td>根據 12, Contra.</td></tr>
							<tr><td>{10}</td><td>$A&rarr;B$</td><td>根據 13, Contra.</td></tr>
							<tr><td>{10}</td><td>$(A&rarr;B)&and;(B&rarr;A)$</td><td>根據 14,15, Conj.</td></tr>
							<tr><td>{10}</td><td>$A&harr;B$</td><td>根據 16, Equiv.</td></tr>
							<tr><td>{}</td><td>$(&not;A&harr;&not;B)&rarr;(A&harr;B)$</td><td>根據 10,17, CP</td></tr>
							<tr><td>{}</td><td>$(A&harr;B)&rarr;(&not;A&harr;&not;B)&and;$<br/>$(&not;A&harr;&not;B)&rarr;(A&harr;B)$</td><td>根據 9,18, Conj.</td></tr>
							<tr><td>{}</td><td>$(A&harr;B)&harr;(&not;A&harr;&not;B)$</td><td>根據 19, Equiv.</td></tr>
						</table>
					</li>
				</ol>
			</div><!--chap4 sect3-->
		</div><!--chapter 4-->
	</div><!--main-->
</body>
