<!DOCTYPE html>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xml:lang="en-US" lang="en-US">

<head>
	<meta charset="utf-8"/>
	
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
	<script src="https://isaacstn.github.io/script/jqmath-etc-0.4.6.min.js"></script>
	<script src="https://isaacstn.github.io/script/note.bubble.v1.js"></script>

	<!--fonts-->
	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/Computer-Modern/serif/cmun-serif.css"/><!--CMU Serif-->
	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/STIXGeneral/STIXGeneral.css"/><!--STIXGeneral-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/FelipaFraktur/FelipaFraktur.css"/><!--Felipa,Unifraktur-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/NotoSerifTC/NotoSerifTC.css"/><!--Noto Serif TC-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/AdobeTC/AdobeTC.css"/><!--Adobe TC-->
	
	<!--styles-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_pagestyle_v1.css"/><!--pagestyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_titlestyle_v1.css"/><!--titlestyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_docstyle_v1.3.css"/><!--docstyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_liststyle_v1.css"/><!--liststyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/Logic/logic_tablestyle_v1.css"/><!--tablestyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/jqmath-0.4.3.css"/><!--jqmath-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/jqmath-0.4.3-math.css"/><!--jqmath-->

	<style>
	h1::before {
		counter-increment:chapter 3;
	}
	div#main {
		counter-reset:page 49;
	}
	</style>

	<title>Ch3_SL-Semantics-2</title>
</head>

<body>
	<div id="main">
		<div class="chapter">
			<h1>語句邏輯的語意（二）</h1>
						
			<div class="section">
				<h2>真值函數</h2>
				<p>
				前一章關於真值表和語意模型的討論，其實都是建立在相同的基礎之上：語句邏輯中的每一個語句都是由一個語句連接詞作為主要連接詞，並連接相應數量的語句來形成的；而要判斷每一個語句的真假，一定都是用該語句之主要連接詞所連接的語句之真假來判斷。因此，每一個語句邏輯中的語句都是一個<b>真值函數 (truth function)</b>。
				</p>
				<p>
				為了說明真值函數是什麼，以及說明真值函數與真值表和語意模型之間的關係，我必須先簡單地介紹一下<b>函數 (function)</b> 這個概念。不過因為函數是一個<b>集合論 (set theory)</b> 的概念，它是用來描述兩個集合的成員之間的特殊對應關係，所以為了說明函數的概念，我也必須先介紹一些基礎的集合論觀念。
				</p>
				
				<div class="subsection">
					<h3>集合</h3>
					<p>
					什麼是<b>集合 (set)</b>？簡單地說，只要我們任意地蒐集一堆東西，就可以形成一個集合。我們通常用 '$\{\}$' 來表示一個集合，並將所有被蒐集進某一個集合內的東西寫在 '$\{\}$' 之中，然後用 '$,$' 將個別的東西分隔開來。比如說，$\{1,2,3,4,5\}$就是一個蒐集了 1-5 這五個阿拉伯數字的集合，而 $\{(A&rarr;B), (C&and;(D&or;B)), (&not;B), (A)\}$ 則是一個蒐集了 '$A&rarr;B$'、'$C&and;(D&or;B)$'、'$&not;B$'、'$A$' 這四個語句的集合。
					</p>
					<p>
					集合能夠蒐集的東西沒有任何限制，無論是抽象的或具體的事物，都可以被蒐集到某個集合之中，集合之中甚至可以蒐集其它的集合。因為集合可以聚集任意數量的任何東西，所以當我們要談論一堆東西的時候，集合就是一個很方便的概念工具。比如說，當我們要談所有自然數（所有 $&ge;0$ 的整數）的時候，因為自然數有無限多個，我們不可能一一指出來談，但有了集合之後，我們就可以直接談論自然數的集合。
					</p>
					<p>
					既然集合是在蒐集了任意一堆東西後所形成的，我們就說那些被一個集合蒐集起來的東西是那個集合的<b>成員 (member)</b>。比如說，'$1$'、'$2$'、'$3$'、'$4$'、'$5$' 都是 $\{1,2,3,4,5\}$ 這個集合的成員。讓我們用大寫的希臘字母（如 '$\&Gamma;$'、'$\&Delta;$'、'$\&Theta;$' 等）來表示一個集合（必要時可加上數字下標），並且令 $\{1,2,3,4,5\}=\&Gamma;$，我們就可以用 '$1&isin;\&Gamma;$' 來表示 $1$ 是 $\&Gamma;$ 這個集合的成員，我們將它讀作「$1$ 屬於 $\&Gamma;$」。
					</p>
					
					<div class="portion">
						<h5>集合的寫法</h5>
						<p>
						前面介紹過一個集合的寫法，就是用左右大括號 '{'、'}' 來包住所有的集合成員，這是所有集合最基本的寫法。這種寫法用來應付成員不多的集合不會有什麼問題，可是如果一個集合的成員很多的話，這種寫法就太浪費時間和空間。為了節省成本，對某些成員很多，但卻可以找到某種規律的集合，我們就用定義的方式來寫它。
						</p>
						<p>
						比如說，如果我們要寫一個蒐集了 $1$ 和 $100$（包括 $1$ 和 $100$）之間所有正整數的集合，照基本的寫法，我們就必須把這一百個數字全部寫下來。為了節省時間和空間，我們可以用定義的方式把這個集合寫成：$\{x|x&isin;&#x2115;,1&le;x&le;100\}$。這種寫法的意思是：這個集合蒐集了所有滿足 '$|$' 這個符號右邊所列條件的 '$x$'。也就是說，這個集合蒐集了所有「屬於自然數」，而且「大於等於 $1$ 並且小於等於 $100$」的 '$x$'。
						</p>
						<p>
						這樣一來，我們不必把那一百個數字全部都列出來，也能把蒐集了所有介於 1 和 100（包括 1 和 100）之間的自然數的集合寫出來。
						</p>
					</div>
					
					<div class="portion">
						<h5>集合的同一性</h5>
						<p>
						每個集合都是由它所包含的成員來決定的，只要擁有相同的成員，就會是同一個集合，無論成員的排列順序如何，也就是說，$\{1,2,3,4,5\}$ 和 $\{5,4,3,2,1\}$ 是同一個集合。除此以外，集合的成員不會有重複的，重複的成員也都會是同一個，因此 $\{1,2,3,4,5\}$ 和 $\{1,1,2,3,3,3,4,4,5,5,5,5\}$ 也是同一個集合。
						</p>
					</div>
					
					<div class="portion">
						<h5>集合的大小</h5>
						<p>
						集合和集合之間也可以比大小，一個集合的大小是由它擁有的成員的個數來決定的。比如說，$\{1,2,3,4,5\}$ 這個集合有五個成員，所以它的大小就是五；而 $\{6,7,8,9\}$ 這個集合只有四個成員，因此它的大小就是四。因為五大於四，所以 $\{1,2,3,4,5\}$ 這個集合就比 $\{6,7,8,9\}$ 這個集合還要大。而當兩個集合擁有的成員個數一樣多時，這兩個集合就一樣大。
						</p>
						<p>
						要注意的是，相同的集合，其大小一定是相等的，但兩個大小相等的集合，卻不一定會是同一個集合。比如說，$\{1,2,3,4,5\}$ 和 $\{1,1,2,3,3,3,4,4,5,5,5,5\}$ 是同一個集合，因此兩個集合的大小是相等的，它們的大小都是五（記得嗎？集合中重複的成員只能算成一個）；但 $\{1,2,3,4,5\}$ 和 $\{6,7,8,9,10\}$ 的大小雖然相等，都是有五個成員的集合，這兩個集合卻不是同一個集合，因為兩個集合各自的成員並不相同。
						</p>
					</div>
					
					<div class="portion">
						<h5>子集合與超集合</h5>
						<p>
						集合和集合之間除了可以判斷是否相等和比大小之外，也可以判斷兩個集合之間是否有<b>包含</b>的關係：對於任意兩個集合 $\&Gamma;$ 和 $\&Delta;$ 而言，如果 $\&Delta;$ 的所有成員也都是 $\&Gamma;$ 的成員，那麼 $\&Gamma;$ 就包含了 $\&Delta;$。這時候，我們稱 $\&Delta;$ 是 $\&Gamma;$ 的<b>子集合 (subset)</b>。我們用 '$&sube;$' 的記號來表示「……是……的子集合」這個關係，因此，
						</p>
						<blockquote>
							$\&Delta;$ 是 $\&Gamma;$ 的子集合
						</blockquote>
						<p>
						就可以被寫成：
						</p>
						<blockquote>
							$\&Delta;&sube;\&Gamma;$
						</blockquote>
						<p>
						同時，因為 $\&Delta;$ 是 $\&Gamma;$ 的子集合，所以 $\&Gamma;$ 是 $\&Delta;$ 的<b>超集合 (superset)</b>（由於 'subset' 在中文裡被譯成「子集合」的關係，也有人將 'superset' 的中文譯為「父集合」）。我們用 '$&supe;$' 這個記號來表示「……是……的超集合」這個關係，因此，
						</p>
						<blockquote>
							$\&Gamma;$ 是 $\&Delta;$ 的超集合
						</blockquote>
						<p>
						也可以被寫成：
						</p>
						<blockquote>
						$\&Gamma;&supe;\&Delta;$
						</blockquote>
						<p>
						簡單來說，子集合和超集合之間的關係是這樣的：對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$ 而言，只要 $\&Delta;$ 是 $\&Gamma;$ 的子集合，那 $\&Gamma;$ 就會是 $\&Delta;$ 的超集合。（參考【圖一】）
						</p>
						<svg height="200px">
							<circle cx="100" cy="100" r="99" />
							<circle class="lgrey" cx="83" cy="118" r="70" />
							<text class="bold" x="140" y="50">&Gamma;</text>
							<text class="bold" x="72" y="127">&Delta;</text>
							<text x="250" y="100">&Delta; 是 &Gamma; 的子集合</text>
							<text x="250" y="120">&Gamma; 是 &Delta; 的超集合</text>
							<text x="400" y="199">【圖一】</text>
						</svg>
						<p>
						要注意的是，當 $\&Delta;$ 的所有成員也都是 $\&Gamma;$ 的成員時，$\&Gamma;$ 並不一定就擁有比 $\&Delta;$ 更多的成員，它們有可能剛好擁有一模一樣的成員（也就是說，當 $\&Delta;$ 和 $\&Gamma;$ 有可能是同一個集合）。因此，當 $\&Delta;$ 是 $\&Gamma;$ 的子集合時，$\&Gamma;$ 也可能是 $\&Delta;$ 的子集合，不過這種情況只會發生在 $\&Delta;$ 和 $\&Gamma;$ 是同一個集合的情況下。因此：<b>$\&Delta;&sube;\&Gamma;$ 而且 $\&Gamma;&sube;\&Delta;$，當且僅當 $\&Delta;&equals;\&Gamma;$。</b>也就是說：當 $\&Delta;&sube;\&Gamma;$ 而且 $\&Gamma;&sube;\&Delta;$ 時，$\&Delta;&equals;\&Gamma;$；並且，只有當 $\&Delta;&equals;\&Gamma;$ 時，$\&Delta;&sube;\&Gamma;$ 和 $\&Gamma;&sube;\&Delta;$ 才會都成立。
						</p>
						<p>
						另一個要注意的事情是，稍早我提到集合的成員可以是任何東西，包括集合本身。因此，$\{1,2,3,4,5\}$ 是一個集合，而 $\{1,2,3,\{4,5\}\}$ 也會是一個集合，而且它們會是兩個不一樣的集合。集合 $\{1,2,3,4,5\}$ 一共有五個成員，分別是 1、2、3、4、5 這五個阿拉伯數字；然而集合 $\{1,2,3,\{4,5\}\}$ 的成員卻只有四個，它的成員是 1、2、3 這三個阿拉伯數字，以及 $\{4,5\}$ 這個集合。
						</p>
						<p>
						另外，對集合 $\{1,2,3,4,5\}$ 來說，$\{4,5\}$ 是它的子集合，因為 $\{4,5\}$ 這個集合的所有成員（4、5 這兩個阿拉伯數字）都是 $\{1,2,3,4,5\}$ 這個集合的成員；但是 $\{4,5\}$ 這個集合卻不是 $\{1,2,3,\{4,5\}\}$ 這個集合的子集合，因為 $\{1,2,3,\{4,5\}\}$ 這個集合的成員中既沒有 4 這個阿拉伯數字，也沒有 5 這個阿拉伯數字。
						</p>
					</div>
					
					<div class="portion">
						<h5>$n$-元組</h5>
						<p>
						另外有一種跟集合類似，但卻不是集合的東西，叫做 <b>$n$-元組 ($n$-tuple)</b>。$n$-元組中的 $n$ 是任意的一個自然數，它代表的是這個組當中有幾個東西，任何有三個東西的組都叫做三元組，任何有四個東西的組就叫四元組，以此類推。我們通常用角括號 '$&LeftAngleBracket;$', '$&RightAngleBracket;$' 來表示一個 $n$-元組。比如說，$&#x27E8;1,2,3&#x27e9;$ 是一個三元組，$&#x27e8;5,6,7,8&#x27e9;$ 則是一個四元組，其餘的可以此類推。
						</p>
						<p>
						$n$-元組和集合除了記號上的不同之外，有兩個主要的差別：
						</p>
						<ol class="num local">
							<li>
							對集合來說，成員的順序不重要，但對一個 $n$-元組來說，變換成員的排列順序就會變成不同的 $n$-元組。比如說，前面提過，$\{1,2,3,4,5\}$ 和 $\{5,4,3,2,1\}$，儘管成員的順序不同，但它們仍是同一個集合；相反地，$&#x27e8;1,2,3,4,5&#x27e9;$ 和 $&#x27e8;5,4,3,2,1&#x27e9;$ 就是兩個不同的五元組。
							</li>
							<li>
							一個集合中不會有重複的成員，重複的成員只能算成是一個成員，因此 $\{1,2,3,4,5\}$ 和 $\{1,1,2,2,3,4,4,5\}$ 是同一個集合，在後面那個寫法中，所有重複的數字都只能算是一個，因此前後兩個集合都只有五個成員；相反地，$n$-元組就可以有重複的成員，因此 $&LeftAngleBracket;1,2,3,4,5&RightAngleBracket;$ 和 $&#x27e8;1,1,2,2,3,4,4,5&#x27e9;$ 就是兩個不同的 $n$-元組，前者是一個五元組，而後者則是一個八元組。
							</li>
						</ol>
					</div>
					
					<div class="portion">
						<h5>對集合的操作</h5>
						<p>
						對於集合，我們可以做各種不同的操作。比如說，對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$，我們可以試著取這兩個集合的<b>交集 (intersection)</b>：$\&Gamma;&cap;\&Delta;$。對兩個集合取交集，取得的交集也是一個集合，它是兩個集合最大的共同子集合。簡單說，$\&Gamma;&cap;\&Delta;$ 就是將 $\&Gamma;$ 和 $\&Delta;$ 中所有相同的成員都蒐集起來的集合。（如【圖二】左）
						</p>
						<p>
						對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$，我們也可以取這兩個集合的<b>聯集 (union)</b>：$\&Gamma;&cup;\&Delta;$。對兩個集合取聯集，取得的聯集也會是一個集合，它是同時蒐集了兩個集合中所有成員的集合。簡單說，$\&Gamma;&cup;\&Delta;$ 就是將 $\&Gamma;$ 和 $\&Delta;$ 中所有的成員都蒐集起來的集合（當蒐集到重複的成員時，只能算一個）。（如【圖二】右）
						</p>
						<svg height="180px">
							<defs>
								<clipPath id="Lrcircle">
									<circle r="74" cx="155" cy="75" />
								</clipPath>
							</defs>
							<circle class="lgrey" clip-path="url(#Lrcircle)" r="74" cx="80" cy="75" />
							<circle r="74" cx="80" cy="75" />
							<circle r="74" cx="155" cy="75" />
							<text class="bold" x="45" y="80">&Gamma;</text>
							<text class="bold" x="180" y="80">&Delta;</text>
							<text class="bold" x="97" y="179">&Gamma;&cap;&Delta;</text>
							<defs>
								<clipPath id="RlCircle">
									<circle r="74" cx="350" cy="75" />
								</clipPath>
								<clipPath id="RrCircle">
									<circle r="74" cx="425" cy="75" />
								</clipPath>
							</defs>
							<circle class="lgrey" r="74" cx="350" cy="75" />
							<circle class="lgrey" r="74" cx="425" cy="75" />
							<circle r="74" cx="350" cy="75" clip-path="url(#RrCircle)" />
							<text class="bold" x="315" y="80">&Gamma;</text>
							<text class="bold" x="450" y="80">&Delta;</text>
							<text class="bold" x="367" y="179">&Gamma;&cup;&Delta;</text>
							<text class="bold" x="510" y="179">【圖二】</text>
						</svg>
						<p>
						舉例來說，如果 $\&Gamma;&equals;\{1,2,3,4,5\}$，而 $\&Delta;&equals;\{4,5,6,7,8\}$，則 $\&Gamma;&cap;\&Delta;&equals;\{4,5\}$，因為只有 4、5 這兩個阿拉伯數字是 $\&Gamma;$ 和 $\&Delta;$ 這兩個集合所共有的成員。至於 $\&Gamma;&cup;&Delta;$ 則會是 $\{1,2,3,4,5,6,7,8\}$ 這個集合，因為將兩個集合中的所有成員都蒐集進同一個集合的話，會得到 $\{1,2,3,4,4,5,5,6,7,8\}$，而其中重複出現過兩次的 4 和 5 這兩個成員各自都只能算一個，所以其實是 $\{1,2,3,4,5,6,7,8\}$。
						</p>
						<p>
						除了對任意兩個集合取交集或聯集之外，我們也可以對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$ 取其<b>乘積 (product)</b>：$\&Gamma;&times;\&Delta;$。$\&Gamma;&times;\&Delta;$ 也是一個集合，不過這個集合的成員比較特別，我們要從 $\&Gamma;$ 和 $\&Delta;$ 這兩個集合中任意各取一個成員出來，然後將從 $\&Gamma;$ 中取出來的成員放前面，將從 $\&Delta;$ 中取出來的成員放後面，形成一個二元組。最後將所有依前述方法組成的二元組都蒐集進同一個集合，就是 $\&Gamma;&times;\&Delta;$。
						</p>
						<p>
						舉例來說，如果 $\&Gamma;&equals;\{1,2,3\}$，$\&Delta;=\{a,b,c\}$，那 $\&Gamma;&times;\&Delta;$ 就會等於 $\{&#x27e8;1,a&#x27e9;,&#x27e8;1,b&#x27e9;,$ $&#x27e8;1,c&#x27e9;,&#x27e8;2,a&#x27e9;,&#x27e8;2,b&#x27e9;,&#x27e8;2,c&#x27e9;,&#x27e8;3,a&#x27e9;,&#x27e8;3,b&#x27e9;,&#x27e8;3,c&#x27e9;\}$。這個集合一共有九個成員，每個成員都是一個二元組，每個二元組都是由一個取自 $\&Gamma;$ 的成員和一個取自 $\&Delta;$ 的成員所組成，而且取自 $\&Gamma;$ 的成員必須放在左邊，取自 $\&Delta;$ 的成員則必須放在右邊。（見【圖三】）
						</p>
						<svg height="200">
							<defs>
								<marker id="head" orient="auto" markerWidth="6" markerHeight="6" refX="0.1" refY="3">
									<path d="M0 0 V6 L6 3 Z" />
								</marker>
								<marker id="head2" orient="auto" markerWidth="3" markerHeight="3" refX="0.1" refY="1.5">
									<path d="M0 0 V3 L3 1.5 Z" />
								</marker>
							</defs>
							<ellipse cx="90" cy="50" rx="35" ry="45" />
							<text class="bold" x="30" y="55">&Gamma;</text>
							<text x="86" y="25">1</text>
							<path marker-end="url(#head)" d="M100 20 L305 20" />
							<path marker-end="url(#head)" d="M100 20 L150 40 L305 40" />
							<path marker-end="url(#head)" d="M100 20 L150 60 L305 60" />
							<text x="86" y="55">2</text>
							<path marker-end="url(#head)" stroke-dasharray="5,2" d="M100 50 L170 80 L305 80" />
							<path marker-end="url(#head)" stroke-dasharray="5,2" d="M100 50 L170 100 L305 100" />
							<path marker-end="url(#head)" stroke-dasharray="5,2" d="M100 50 L170 120 L305 120" />
							<text x="86" y="85">3</text>
							<path marker-end="url(#head2)" d="M100 80 L170 140 L305 140" style="stroke-width:2;"/>
							<path marker-end="url(#head2)" d="M100 80 L170 160 L305 160" style="stroke-width:2;" />
							<path marker-end="url(#head2)" d="M100 80 L170 180 L305 180" style="stroke-width:2;" />
							<ellipse cx="90" cy="150" rx="35" ry="45" />
							<text class="bold" x="30" y="155">&Delta;</text>
							<text x="86" y="125">a</text>
							<path d="M100 120 L150 20" />
							<path stroke-dasharray="5,2" d="M100 120 L170 80" />
							<path d="M100 120 L170 140" style="stroke-width:2;" />
							<text x="86" y="155">b</text>
							<path d="M100 150 L150 40" />
							<path stroke-dasharray="5,2" d="M100 150 L170 100" />
							<path d="M100 150 L170 160" style="stroke-width:2;" />
							<text x="86" y="185">c</text>
							<path d="M100 180 L150 60" />
							<path stroke-dasharray="5,2" d="M100 180 L170 120" />
							<path d="M100 180 L170 180" style="stroke-width:2;" />
							<ellipse cx="337" cy="100" rx="80" ry="99" />
							<text class="bold" x="430" y="105">&Gamma;&times;&Delta;</text>
							<text x="320" y="25">&#x27e8;1,a&#x27e9;</text>
							<text x="320" y="45">&#x27e8;1,b&#x27e9;</text>
							<text x="320" y="65">&#x27e8;1,c&#x27e9;</text>
							<text x="320" y="85">&#x27e8;2,a&#x27e9;</text>
							<text x="320" y="105">&#x27e8;2,b&#x27e9;</text>
							<text x="320" y="125">&#x27e8;2,c&#x27e9;</text>
							<text x="320" y="145">&#x27e8;3,a&#x27e9;</text>
							<text x="320" y="165">&#x27e8;3,b&#x27e9;</text>
							<text x="320" y="185">&#x27e8;3,c&#x27e9;</text>
							<text x="500" y="199">【圖三】</text>
						</svg>
						<p>
						以上這些操作都不只能作用在兩個集合之間，我們可以取五個集合的交集，那就必須將五個集合中所有相同的成員都蒐集起來；也可以取四個集合的聯集，那就是把四個集合的所有成員都蒐集起來；當然也可以取三個集合的乘績，如此得到的集合，其成員都會是由三個集合分別取出的成員所排列成的三元組。
						</p>
					</div>
				</div>
				
				<div class="subsection">
					<h3>函數</h3>
					<p>
					簡單介紹過關於集合的一些基本觀念之後，現在要說明什麼是函數。
					</p>
					<p>
					前面說，函數是用來描述兩個集合的成員之間的特殊對應關係，那這個特殊對應關係是什麼呢？更準確地說，一個函數就是以一個集合的成員作為輸入，然後會輸出另一個集合的成員的操作程序。我們將提供輸入的集合稱為這個函數的<b>論域 (domain)</b>，並將所有輸出的值所形成的集合稱為這個函數的<b>值域 (range)</b>。
					</p>
					<p>
					一個函數除了是兩個集合之間的「輸入／輸出」關係之外，還必須滿足以下兩個條件：<b>一、每一個輸入都一定要有一個輸出；二、每一個輸入都只能有一個輸出。</b>我們通常會將一個函數寫作 '$\sc{f}\：\&Gamma;&rarr;\&Delta;$'，意思是：「$\sc{f}$ 是一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數」 ，其中的 $\&Gamma;$ 和 $\&Delta;$ 都是集合，$\&Gamma;$ 寫在 '$&rarr;$' 的左邊，表示它是 $\sc{f}$ 這個函數的論域，而 $\&Delta;$ 寫在 '$&rarr;$' 的右邊，表示它是 $\sc{f}$ 這個函數的<b>對應域 (codomain)</b>。
					</p>
					<p>
					若我們以 '$x$' 來代表 $\&Gamma;$ 中的成員，以 '$y$' 來代表 $\&Delta;$ 中的成員，當 $\sc{f}$ 是一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數時，我們也可以把這個函數寫成 '$\sc{f}(x)=y$'，意思是：只要從 $\&Gamma;$ 當中挑任何一個 '$x$' 出來並輸入 '$\sc{f}$' 這個函數，這個函數就會輸出一個 $\&Delta;$ 中成員 '$y$'，而且只會輸出一個。換言之，一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數，就是一個以 $\&Gamma;$ 的成員為輸入，並且以 $\&Delta;$ 的成員為輸出的操作程序。
					</p>
					<p>
					以【圖四】為例，左、中、右三張圖分別呈現出 $\&Gamma;$ 和 $\&Delta;$ 這兩個集合之間的三種不同的輸入／輸出關係。左圖中，作為論域的 $\&Gamma;$ 中的 c 這一成員沒有對應到任何輸出，故不滿足條件一，因此不算是一個函數。而在中間那張圖裡，雖然每一個輸入確實都有對應的輸出，但 c 作為輸入時卻對應到兩個輸出（即 $\&Delta;$ 中的 2 和 3），故不滿足條件二，因此也不算是一個函數。唯有右圖中的每一個輸入確實都有一個對應的輸入，故滿足條件一，而且每一個輸入也確實都只對應到一個輸出，故也滿足條件二，因此右圖所呈現出來的輸入／輸出關係才算是一個函數。
					</p>
					<svg height="150">
						<ellipse cx="35" cy="75" rx="34" ry="74" /><text class="bold" x="0" y="11">&Gamma;</text>
						<text x="30" y="30">a</text>
						<text x="30" y="55">b</text>
						<text x="30" y="80">c</text>
						<text x="30" y="105">d</text>
						<text x="30" y="130">e</text>
						<ellipse cx="115" cy="75" rx="34" ry="74" /><text class="bold" x="80" y="11">&Delta;</text>
						<text x="110" y="30">1</text>
						<text x="110" y="55">2</text>
						<text x="110" y="80">3</text>
						<text x="110" y="105">4</text>
						<text x="110" y="130">5</text>
						<path marker-end="url(#head)" d="M45 25 L100 25" />
						<path marker-end="url(#head)" d="M45 50 L100 50" />
						<path marker-end="url(#head)" d="M45 100 L100 75" />
						<path marker-end="url(#head)" d="M45 125 L100 100" />
						<ellipse cx="215" cy="75" rx="34" ry="74" /><text class="bold" x="180" y="11">&Gamma;</text>
						<text x="210" y="30">a</text>
						<text x="210" y="55">b</text>
						<text x="210" y="80">c</text>
						<text x="210" y="105">d</text>
						<text x="210" y="130">e</text>
						<ellipse cx="295" cy="75" rx="34" ry="74" /><text class="bold" x="260" y="11">&Delta;</text>
						<text x="290" y="30">1</text>
						<text x="290" y="55">2</text>
						<text x="290" y="80">3</text>
						<text x="290" y="105">4</text>
						<text x="290" y="130">5</text>
						<path marker-end="url(#head)" d="M220 25 L280 25" />
						<path marker-end="url(#head)" d="M220 50 L280 50" />
						<path marker-end="url(#head)" d="M220 75 L280 58" />
						<path marker-end="url(#head)" d="M220 75 L280 75" />
						<path marker-end="url(#head)" d="M220 100 L280 100" />
						<path marker-end="url(#head)" d="M220 125 L280 125" />
						<ellipse cx="395" cy="75" rx="34" ry="74" /><text class="bold" x="360" y="11">&Gamma;</text>
						<text x="390" y="30">a</text>
						<text x="390" y="55">b</text>
						<text x="390" y="80">c</text>
						<text x="390" y="105">d</text>
						<text x="390" y="130">e</text>
						<ellipse cx="475" cy="75" rx="34" ry="74" /><text class="bold" x="440" y="11">&Delta;</text>
						<text x="470" y="30">1</text>
						<text x="470" y="55">2</text>
						<text x="470" y="80">3</text>
						<text x="470" y="105">4</text>
						<text x="470" y="130">5</text>
						<path marker-end="url(#head)" d="M400 25 L460 25" />
						<path marker-end="url(#head)" d="M400 50 L460 50" />
						<path marker-end="url(#head)" d="M400 75 L460 75" />
						<path marker-end="url(#head)" d="M400 100 L460 83" />
						<path marker-end="url(#head)" d="M400 125 L460 125" />
							<text class="bold" x="510" y="149">【圖四】</text>
					</svg>
					<p>
					要注意的是，對應域和值域雖然是不同的東西，但因為兩者關係密切而且極為相似，所以經常會被混淆。簡單來說，一個函數的值域一定是這個函數的對應域的子集合。以【圖五】為例，【圖五】是【圖四】最右圖的放大版。根據【圖五】，我們可以很明顯地看出來：$\sc{f}$ 雖然是從 $\&Gamma;$ 對應到 $\&Delta;$ 的函數，因此 $\&Delta;$ 確實是 $\sc{f}$ 的<b>對應域</b>。但 $\&Delta;$ 中有一個成員（數字 $4$）其實沒有對應的輸入值。
					</p>
					<p>
					也就是說，當我們以 $\&Gamma;$ 中的成員輸入到 $\sc{f}$ 這個函數時，我們可以得到的所有輸出所形成的集合（<b>值域</b>），會是 $\sc{f}(x)=\{1,2,3,5\}$ 這個集合，而非 $\&Delta;=\{1,2,3,4,5\}$ 這個集合。這是因為函數的定義只要求論域中的每一個成員作為輸入時，都一定要在對應域中有一個輸出，卻<b>沒有要求</b>對應域中的每一個輸出一定都要被對應到。因此函數的值域一定都是其對應域的子集合，只有當函數的對應域中的每一個成員都有被對應到時，函數的值域才會等於它的對應域。
					</p>
					<svg height="150">
						<ellipse cx="50" cy="75" rx="49" ry="74" />
						<text class="bold" x="0" y="11">&Gamma;</text>
						<text x="46" y="30">a</text>
						<text x="46" y="55">b</text>
						<text x="46" y="80">c</text>
						<text x="46" y="105">d</text>
						<text x="46" y="130">e</text>
						<ellipse cx="300" cy="75" rx="99" ry="74" />
						<text class="bold" x="200" y="11">&Delta;</text>
						<text x="350" y="80">4</text>
						<ellipse class="lgrey" cx="284" cy="75" rx="40" ry="60" />
						<path marker-end="url(#head)" d="M60 26 L270 30" />
						<text x="280" y="35">1</text>
						<path marker-end="url(#head)" d="M60 51 L270 60" />
						<text x="280" y="65">2</text>
						<path marker-end="url(#head)" d="M60 76 L270 87" />
						<path marker-end="url(#head)" d="M60 101 L270 93" />
						<text x="280" y="95">3</text>
						<path marker-end="url(#head)" d="M60 126 L270 120" />
						<text x="280" y="125">5</text>
						<path d="M305 50 L410 10" />
						<text class="bold" x="420" y="14"><tspan class="felipa">f</tspan><tspan>(</tspan><tspan class="ita">x</tspan><tspan>)</tspan></text>
						<text class="bold" x="450" y="149">【圖五】</text>
					</svg>
					<p>
					函數在生活中並不少見，例如自然數加法中的 '$&plus;1$' 就是一個從自然數的集合到自然數的集合的函數。對任何自然數的成員 '$x$' 來說，只要輸入 $+1$ 這個函數（即對 $x$ 做 $+1$ 的操作），就會輸出一個自然數的成員（$x+1$），而且每個輸入都只會有一個輸出。比如說，$1$ 是自然數的成員，只要把 $1$ 輸入 $+1$ 這個函數，就會得到 $2$ 這個輸出，而且只會得到 $2$ 這個輸出；$2$ 也是自然數的成員，只要把 $2$ 輸入 $+1$ 這個函數，就會得到 $3$ 這個輸出，而且只會得到 $3$ 這個輸出；以下類推。（見【圖六】）
					</p>
					<svg height="150">
						<text x="30" y="12">&#x2115;</text>
						<ellipse cx="70" cy="75" rx="40" ry="74" />
						<text x="67" y="30">0
							<tspan x="67" y="50">1</tspan>
							<tspan x="67" y="70">2</tspan>
							<tspan x="67" y="90">3</tspan>
							<tspan x="67" y="110">4</tspan>
							<tspan x="69" y="130">&vellip;</tspan>
						</text>
						<text x="360" y="12">&#x2115;</text>
						<ellipse cx="400" cy="75" rx="40" ry="74" />
						<text x="397" y="20">0
							<tspan x="397" y="40">1</tspan>
							<tspan x="397" y="60">2</tspan>
							<tspan x="397" y="80">3</tspan>
							<tspan x="397" y="100">4</tspan>
							<tspan x="397" y="120">5</tspan>
							<tspan x="399" y="140">&vellip;</tspan>
						</text>
						<path marker-end="url(#head)" d="M80 25 L385 35" />
						<path marker-end="url(#head)" d="M80 45 L385 55" />
						<path marker-end="url(#head)" d="M80 65 L385 75" />
						<path marker-end="url(#head)" d="M80 85 L385 95" />
						<path marker-end="url(#head)" d="M80 105 L385 115" />
						<path marker-end="url(#head)" d="M100 125 Q155 140 210 140" />
						<text x="145" y="135">輸入</text>
						<path marker-end="url(#head)" d="M250 140 Q320 140 364 125" />
						<text x="290" y="134">輸出</text>
						<text x="220" y="145">+1</text>
						<text x="450" y="149">【圖六】</text>
					</svg>
					<p>
					再舉一個例子來說，我們平時搭乘的電梯也是一個函數，當你輸入一個電梯樓層的按鈕，電梯就會以「到達對應的樓層」為輸出。你按下「3樓」的按鈕作為輸入，電梯就會以「到達3樓」為輸出；你按下「6樓」的按鈕作為輸入，電梯就會以「到達6樓」為輸出。每一個樓層按鈕的輸入都會對應到一個「到達樓層」的輸出，而且每一個樓層按鈕的輸入都只會對應到一個「到達樓層」的輸出。按下「3樓」的按鈕，電梯就只會到達3樓，而不會到達其它樓層。
					</p>
					<p>
					函數是一個輸入到輸出的操作，有輸入就一定要有輸出，而且每個輸入都一定只能有一個輸出。但函數的輸入可以不只是「一個東西」，有些函數也可以輸入「一組東西」。比如說，前面提到的 '$+1$' 是一個每次都只能輸入「一個東西」的函數，但四則運算中的 '$+$' 就必須同時輸入兩個數字才能得到一個輸出。如果我們只對 '$+$' 輸入一個數字，那不論是 '$2+$' 或 '$+2$'，都不會有任何輸出，唯有同時輸入兩個數字時，比如說 '$1+2$' 或 '$0+1$'，我們才能分別得到 '$3$' 和 '$1$' 這兩個輸出。
					</p>
					<p>
					由於 '$&plus;$' 這個函數一定要一次輸入兩個數字才能進行運算得到輸出，也就是說，要進行 '$+$' 這個函數的運算，我們必須先在自然數的集合裡取一個成員出來，然後再從自然數的集合裡取一個成員出來，並將這兩個取自自然數的集合的成員依序輸入 '$+$' 這個函數，才能進行運算並得到一個自然數（因為自然數的加法的結果也一定是自然數）。因此，'$+$' 這個函數的論域就是 $\&#x2115;&times;\&#x2115;$，而值域則是 $\&#x2115;$。（見【圖七】）
					</p>
					<svg height="200">
						<text x="60" y="12">&#x2115;</text>
						<ellipse cx="90" cy="50" rx="30" ry="45" />
						<text x="86" y="25">0
							<tspan x="86" y="45">1</tspan>
							<tspan x="86" y="65">2</tspan>
							<tspan x="88" y="85">&vellip;</tspan>
						</text>
						<text x="60" y="200">&#x2115;</text>
						<ellipse cx="90" cy="150" rx="30" ry="45" />
						<text x="86" y="125">0
							<tspan x="86" y="145">1</tspan>
							<tspan x="86" y="165">2</tspan>
							<tspan x="88" y="185">&vellip;</tspan>
						</text>
						<path d="M100 20 C150 30 150 95 100 120" /><path d="M100 20 C160 32 160 110 100 140" /><path d="M100 20 C170 34 170 125 100 160" />
						<path d="M80 40 C50 45 50 95 80 120" /><path d="M80 40 C40 50 40 110 80 140" /><path d="M80 40 C30 55 30 125 80 160" />
						<path d="M100 60 C110 65 110 115 100 120" /><path d="M100 60 C120 70 120 130 100 140" /><path d="M100 60 C130 75 130 145 100 160" />
						<text x="170" y="110" style="font-size:40px;">&rArr;</text>
						<text x="205" y="12">&#x2115;&times;&#x2115;</text>
						<ellipse cx="265" cy="100" rx="40" ry="99" />
						<text x="408" y="12">&#x2115;</text>
						<ellipse cx="440" cy="100" rx="40" ry="99" />
						<text x="248" y="25">&#x27e8;0,0&#x27e9;
							<tspan x="248" y="40">&#x27e8;0,1&#x27e9;</tspan>
							<tspan x="248" y="55">&#x27e8;0,2&#x27e9;</tspan>
							<tspan x="263" y="70">&vellip;</tspan>
							<tspan x="248" y="85">&#x27e8;1,0&#x27e9;</tspan>
							<tspan x="248" y="100">&#x27e8;1,1&#x27e9;</tspan>
							<tspan x="248" y="115">&#x27e8;1,2&#x27e9;</tspan>
							<tspan x="263" y="130">&vellip;</tspan>
							<tspan x="248" y="145">&#x27e8;2,0&#x27e9;</tspan>
							<tspan x="248" y="160">&#x27e8;2,1&#x27e9;</tspan>
							<tspan x="248" y="175">&#x27e8;2,2&#x27e9;</tspan>
							<tspan x="263" y="190">&vellip;</tspan>
						</text>
						<text x="436" y="30">0
							<tspan x="436" y="60">1</tspan>
							<tspan x="436" y="90">2</tspan>
							<tspan x="436" y="120">3</tspan>
							<tspan x="436" y="150">4</tspan>
							<tspan x="438" y="180">&vellip;</tspan>
						</text>
						<path marker-end="url(#head)" d="M280 20 L427 25" />
						<path marker-end="url(#head)" d="M280 35 L427 52" />
						<path marker-end="url(#head)" d="M280 50 L427 80" />
						<path marker-end="url(#head)" d="M280 80 L427 60" />
						<path marker-end="url(#head)" d="M280 95 L427 86" />
						<path marker-end="url(#head)" d="M280 110 L427 111" />
						<path marker-end="url(#head)" d="M280 140 L427 91" />
						<path marker-end="url(#head)" d="M280 155 L427 118" />
						<path marker-end="url(#head)" d="M280 170 L427 147" />
						<text x="345" y="200">+</text>
						<path marker-end="url(#head)" d="M288 180 Q310 195 334 195" />
						<path marker-end="url(#head)" d="M362 195 Q395 195 410 180" />
						<text x="305" y="187">輸入</text>
						<text x="365" y="187">輸出</text>
						<text x="480" y="199">【圖七】</text>
					</svg>
					<p>
					既然函數可以有「需要輸入多少個東西才能得到輸出」的差別，我們就可以根據一個函數必須輸入多少東西才能得到輸出，將函數區分成幾元的函數。必須輸入一個東西的函數被稱為<b>一元</b>函數，必須輸入兩個東西的函數被稱為<b>二元</b>函數，必須輸入三個東西的函數，就被稱為<b>三元</b>函數，以此類推。
					</p>
				</div>
				
				<div class="subsection">
					<h3>真值函數</h3>
					<p>
					簡單介紹過關於集合和函數的基本觀念後，我們就要來談<b>真值函數</b>了。在這一節的一開始，我提到以下這件事：語句邏輯中每一個語句，都是一個真值函數。在理解了函數的基本觀念後，我們就能理解這句話的意思是：語句邏輯中的每一個語句都是一個關於<b>真值 (truth value)</b> 的輸入／輸出的操作。
					</p>
					<p>
					舉例來說，'$&alpha;&and;&beta;$' 是一個以 '$&and;$' 作為主要連接詞，將 '$&alpha;$' 和 '$&beta;$' 這兩個言句連接起來的連言句。根據連言句的真值表，我們知道：
					</p>
					<ul class="tight">
						<li>當 '$&alpha;$' 為真、'$&beta;$' 為真時，'$&alpha;&and;&beta;$' 為真；</li>
						<li>當 '$&alpha;$' 為真、'$&beta;$' 為假時，'$&alpha;&and;&beta;$' 為假；</li>
						<li>當 '$&alpha;$' 為假、'$&beta;$' 為真時，'$&alpha;&and;&beta;$' 為假；</li>
						<li>當 '$&alpha;$' 為假、'$&beta;$' 為假時，'$&alpha;&and;&beta;$' 為假。</li>
					</ul>
					<p>
					如果把 '$&alpha;&and;&beta;$' 中的 '$&alpha;$' 和 '$&beta;$' 看成是可以輸入真假值的兩個位置，那麼 '$&alpha;&and;&beta;$' 就可以被看成是一個函數：只要在 '$&alpha;$' 和 '$&beta;$' 的位置分別填入真或假，那 '$&alpha;&and;&beta;$' 就會輸出一個真假值。比如說，在 '$&alpha;$' 的位置輸入「真」，在 '$&beta;$' 的位置輸入「真」，'$&alpha;&and;&beta;$' 就會輸出「真」；在 '$&alpha;$' 的位置輸入「假」，在 '$&beta;$' 的位置輸入「真」，'$&alpha;&and;&beta;$' 就會輸出假；……以此類推。
					</p>
					<p>
					由於每一個語句邏輯中的語句都只有「真」、「假」兩種可能性，因此我們可以把這兩種可能性蒐集進一個集合裡，形成 $\{\T,\F\}$ 這樣的一個集合。那麼，對於每一個語句連接詞，當它被用來當作構成某個語句的主要連接詞時，都可以被看成是一個以 $\{\T,\F\}$（一元連接詞），或者是以 $\{\T,\F\}&times;\{\T,\F\}$（二元連接詞）為論域，並且以 $\{\T,\F\}$ 為對應域的函數。
					</p>
					<p>
					當我們以一元連接詞 '$&not;$' 為主要連接詞來構成語句時，它就是一個從 $\{\T,\F\}$ 到 $\{\T,\F\}$ 的一元函數，只要輸入 $\T$ 或 $\F$，就會得到 $\T$ 或 $\F$ 的輸出；而當我們以二元連接詞 '$&and;$'、'$&or;$'、'$&rarr;$' 或 '$&harr;$' 作為主要來接詞來構成語句時，它就是一個從 $\{\T,\F\}&times;\{\T,\F\}$ 到 $\{\T,\F\}$ 的函數，只要輸入 $&#x27e8;\T,\T&#x27e9;$、$&#x27e8;\T,\F&#x27e9;$、$&#x27e8;\F,\T&#x27e9;$ 或 $&#x27e8;\F,\F&#x27e9;$，就會得到 $\T$ 或 $\F$ 的輸出。我們可以用【圖八】來表示這五個函數：
					</p>
					<svg height="200">
						<text class="bold" x="65" y="11">&not;<tspan class="ita">&alpha;</tspan></text>
						<ellipse cx="35" cy="50" rx="34" ry="49" />
						<text x="30" y="40">T</text>
						<path marker-end="url(#head)" d="M45 35 L105 63" />
						<text x="30" y="70">F</text>
						<path marker-end="url(#head)" d="M45 65 L105 38" />
						<ellipse cx="120" cy="50" rx="34" ry="49" />
						<text x="115" y="40">T</text>
						<text x="115" y="70">F</text>
						<text class="bold" x="263" y="11"><tspan class="ita">&alpha;</tspan>&and;<tspan class="ita">&beta;</tspan></text>
						<ellipse cx="240" cy="50" rx="34" ry="49" />
						<text x="220" y="25">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 22 L310 33" />
						<text x="220" y="45">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 42 L310 58" />
						<text x="220" y="65">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 61 L310 64" />
						<text x="220" y="85">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 81 L310 70" />
						<ellipse cx="325" cy="50" rx="34" ry="49" />
						<text x="320" y="40">T</text>
						<text x="320" y="70">F</text>
						<text class="bold" x="468" y="11"><tspan class="ita">&alpha;</tspan>&or;<tspan class="ita">&beta;</tspan></text>
						<ellipse cx="445" cy="50" rx="34" ry="49" />
						<text x="425" y="25">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 22 L515 30" />
						<text x="425" y="45">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 42 L515 36" />
						<text x="425" y="65">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 62 L515 42" />
						<text x="425" y="85">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 81 L515 66" />
						<ellipse cx="530" cy="50" rx="34" ry="49" />
						<text x="525" y="40">T</text>
						<text x="525" y="70">F</text>
						<text class="bold" x="158" y="196"><tspan class="ita">&alpha;</tspan><tspan y="197">&rarr;</tspan><tspan class="ita">&beta;</tspan></text>
						<ellipse cx="137" cy="150" rx="34" ry="49" />
						<text x="117" y="125">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 122 L207 130" />
						<text x="117" y="145">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 142 L207 162" />
						<text x="117" y="165">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 162 L207 137" />
						<text x="117" y="185">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 181 L207 144" />
						<ellipse cx="222" cy="150" rx="34" ry="49" />
						<text x="217" y="140">T</text>
						<text x="217" y="170">F</text>
						<text class="bold" x="363" y="196"><tspan class="ita">&alpha;</tspan><tspan y="197">&harr;</tspan><tspan class="ita">&beta;</tspan></text>
						<ellipse cx="342" cy="150" rx="34" ry="49" />
						<text x="322" y="125">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 122 L412 133" />
						<text x="322" y="145">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 142 L412 160" />
						<text x="322" y="165">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 162 L412 166" />
						<text x="322" y="185">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 181 L412 141" />
						<ellipse cx="427" cy="150" rx="34" ry="49" />
						<text x="422" y="140">T</text>
						<text x="422" y="170">F</text>
						<text class="bold" x="510" y="199">【圖八】</text>
					</svg>
					<p>
					從【圖八】可以清楚地看出來，這五個句型確實都滿足函數的定義，每個輸入（主要連接詞所連接之語句的真假，一元連接詞只連接一個語句，所以輸入就只有 $\T$ 或 $\F$；二元連接詞連接兩個語句，所以輸入就是一個二元組，左邊擺的是寫在連接詞左側之語句的真假，右邊擺的則是寫在連接詞左側之語句的真假）都一定有一個輸出，而且每個輸入都只會有一個輸出。
					</p>
					<p>
					前面說過，語句邏輯中除了原子語句之外，所有的語句一定都是用這五個語句連接詞所建構出來的，因此只要給定每一個原子語句的真假，我們就能夠根據【圖八】中的五個函數來確定每一個語句的真假。換言之，每一個語句邏輯中的語句也都可以看成是一個真值函數，這個函數的論域就是該語句所使用到的所有原子語句的真假，而對應域則依舊是 $\{\T,\F\}$ 這個集合。以 '$&not;A&and;(B&or;C)$' 這個語句為例：
					</p>
					<svg height="200">
						<text class="bold" x="110" y="21">&not;<tspan class="ita">A</tspan> &and; (<tspan class="ita">B</tspan> &or; <tspan class="ita">C</tspan>)</text>
						<ellipse cx="50" cy="100" rx="49" ry="99" />
						<text x="22" y="35">&#x27e8;T,T,T&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M80 32 L235 140" />
						<text x="22" y="55">&#x27e8;T,T,F&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M78 52 L235 144" />
						<text x="22" y="75">&#x27e8;T,F,T&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M78 72 L235 148" />
						<text x="22" y="95">&#x27e8;T,F,F&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M77 92 L235 152" />
						<text x="22" y="115">&#x27e8;F,T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M78 112 L235 97" />
						<text x="22" y="135">&#x27e8;F,T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M77 132 L235 102" />
						<text x="22" y="155">&#x27e8;F,F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M77 152 L235 107" />
						<text x="22" y="175">&#x27e8;F,F,F&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M75 172 L235 156" />
						<ellipse cx="250" cy="125" rx="49" ry="74" />
						<text x="245" y="105">T</text>
						<text x="245" y="155">F</text>
						<text class="bold" x="300" y="199">【圖九】</text>
					</svg>
					<p>
					根據【圖九】，只要輸入三個原子語句的真假（由 $\{\T,\F\}&times;\{\T,\F\}&times;\{\T,\F\}$ 形成的三元組），就會輸出一個 $\T$ 或 $\F$，而且每一組輸入都只會有一個輸出。因此，【圖九】亦可佐證語句邏輯中的每一個語句也都是一個真值函數的說法。
					</p>
					<p>
					既然所有語句都是一個由原子語句的真假（所形成的 $n$-元組）到 $\{\T,\F\}$ 的函數，那麼，只要有一個函數可以決定所有原子語句的真假，這個函數再加上【圖八】中所列出的五個句型的真值函數，就會得到一個能夠判斷出所有語句真假的函數。
					</p>
					<p>
					而我在前一章介紹過，每一個<b>語意模型</b>都會決定每一個原子語句的真假，因此，我們就可以利用語意模型來製造出能夠判別所有語句真假的函數。由於語意模型的符號是 $\sc{v}_n$（$n$ 是一個任意數），我們就把用語意模型創造出來的真值函數寫作 $\sc{v}_n'$。<span class="note"><span class="box">請注意，因為每一個語意模型所決定的原子語句之真假都不一樣，所以每一個不同的語意模型都會對應到一個不一樣的真值函數。比如說，$\sc{v}_1$ 就會對應到 $\sc{v}_1'$，而 $\sc{v}_2$ 就會對應到 $\sc{v}_2'$，以下類推。</span></span>
					</p>
					<p>
					$\sc{v}_n'$ 是一個以<b>所有語句邏輯的語句（包括所有原子語句和複雜語句）所形成的集合</b>為論域，並以 $\{\T,\F\}$ 為對應域的函數。我們將所有語句邏輯的語句所形成的集合簡稱為 $SL$（"sentential logic"，也就是語句邏輯的英文的縮寫），那麼，對於某個語意模型 $\sc{v}_n$ 所決定出來的真值函數 $\sc{v}_n'$，我們就可以將它寫成：$\sc{v}_n'\：SL&rarr;\{\T,\F\}$。然後，我們可以用以下方式定義 $\sc{v}_n'$ 這個函數：
					</p>
					<ol class="numd local tight">
						<li>當 $&alpha;$ 是原子語句時，$\sc{v}_n'(&alpha;)=\T$ 當且僅當 $\sc{v}_n&vDash;\sc{&alpha;}$。</li>
					</ol>
					<p>
					在利用定義 1 確定了所有原子語句之真假後，我們接下來定義五大句型的真值函數：
					</p>
					<ol class="numd tight">
						<li>$\sc{v}_n'(&not;&alpha;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\F$。</li>
						<li>$\sc{v}_n'(&alpha;&and;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\T$ 而且 $\sc{v}_n'(&beta;)=\T$。</li>
						<li>$\sc{v}_n'(&alpha;&or;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\T$ 或者 $\sc{v}_n'(&beta;)=\T$。</li>
						<li>$\sc{v}_n'(&alpha;&rarr;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\F$ 或者 $\sc{v}_n'(&beta;)=\T$。</li>
						<li>$\sc{v}_n'(&alpha;&harr;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\sc{v}_n'(&beta;)$。</li>
					</ol>
					<p>
					透過這六條定義，我們就能用這樣的函數來判斷任何語句的真假了。
					</p>
					<p>
					我們繼續採用 '$&not;A&and;(B&or;C)$' 這個語句來當作例子，要用上述函數來判斷這個語句的真假，我們就要將它輸入到那個函數之中。所以我們就是要求以下等式的解：
					</p>
					<ul>
						<li>$\sc{v}_n'(&not;A&and;(B&or;C))=\？$</li>
					</ul>
					<p>
					因為 '$&not;A&and;(B&or;C)$' 的主要連接詞是 '$&and;$'，所以第一步要先套用定義 3，得到：
					</p>
					<ul>
						<li>$\sc{v}_n'(&not;A&and;(B&or;C))=\T$ 當且僅當 $\sc{v}_n'(&not;A)=\T$ 而且 $\sc{v}_n'(B&or;C)=\T$</li>
					</ul>
					<p>
					因此我們需要分別求 $\sc{v}_n'(&not;A)$ 和 $\sc{v}_n'(B&or;C)$ 的值，因此要分別套用定義 2、4，得到：
					</p>
					<ul class="tight">
						<li>$\sc{v}_n'(&not;A)=\T$ 當且僅當 $\sc{v}_n'(A)=\F$。</li>
						<li>$\sc{v}_n'(B&or;C)=\T$ 當且僅當 $\sc{v}_n'(B)=\T$ 或者 $\sc{v}_n'(C)=\T$。</li>
					</ul>
					<p>
					最後，就可以根據定義 1 來分別判斷 $\sc{v}_n'(A)$、$\sc{v}_n'(B)$ 和 $\sc{v}_n'(C)$ 的值，而這個判斷就涉及我們選擇的語意模型究竟是哪一個了。比如說，假如我們選擇的語意模型是 $\sc{v}_1$，而 $\sc{v}_1$ 是所有原子語句都為真的語意模型，因此，透過 $\sc{v}_1$ 所對應到的真值函數 $\sc{v}_1'$ 來計算 '$&not;A&and;(B&or;C)$' 這個語句的真假時，計算的過程就會如下：
					</p>
					<table class="prf">
						<tr><td>$\sc{v}_1'(A)=\T$、$\sc{v}_1'(B)=\T$，而且 $\sc{v}_1'(C)=\T$</td><td>根據定義 1</td></tr>
						<tr><td>因 $\sc{v}_1'(A)=\T&ne;\F$，故 $\sc{v}_1'(&not;A)=\F$</td><td>根據 (1) 和定義 2</td></tr>
						<tr><td>因 $\sc{v}_1'(B)=\T$，故 $\sc{v}_1'(B&or;C)=\T$<span class="note"><span class="box">在這裡，根據定義 4，只要 $\sc{v}_1'(B)=\T$ 和 $\sc{v}_1'(C)=\T$ 任一成立，$\sc{v}_1'(B&or;C)=\T$ 就會成立，故此處只需要判斷 $\sc{v}_1'(B)=\T$，就足以判斷 $\sc{v}_1'(B&or;)=\T$。當然，如果你要用 $\sc{v}_1'(C)=\T$ 來判斷 $\sc{v}_1'(B&or;C)=\T$ 也是可以的。</span></span></td><td>根據 (1) 和定義 4</td></tr>
						<tr><td>因 $\sc{v}_1'(&not;A)=F&ne;\T$，<br/>故 $\sc{v}_1'(&not;A&and;(B&or;C))=\F$</td><td>根據 (2),(3) 和定義 3</td></tr>
					</table>
					<p>
					因此，我們可以知道，'$&not;A&and;(B&or;C)$' 在 $\sc{v}_1$ 這個語意模型之下為假。
					</p>
					<p>
					我們還可以再換另一個語意模型來測試看看，比如說 $\sc{v}_2$，$\sc{v}_2$ 是讓 '$A$' 為假而其餘原子語句皆為真的語意模型，因此用與之對應的真值函數 $\sc{v}_2'$ 去計算 '$&not;A&and;(B&or;C)$' 的真假時，計算方式如下：
					</p>
					<table class="prf">
						<tr><td>$\sc{v}_2'(A)=\F$、$\sc{v}_2'(B)=\T$，而且 $\sc{v}_2'(C)=\T$</td><td>根據定義 1</td></tr>
						<tr><td>因 $\sc{v}_2'(A)=\F$，故 $\sc{v}_2'(&not;A)=\T$</td><td>根據 (1) 和定義 2</td></tr>
						<tr><td>因 $\sc{v}_2'(B)=\T$，故 $\sc{v}_2'(B&or;C)=\T$<span class="note"><span class="box">同上，根據定義 4，只要 $\sc{v}_2'(B)=\T$ 和 $\sc{v}_2'(C)=\T$ 任一成立，$\sc{v}_2'(B&or;C)=\T$ 就會成立，故此處只需要判斷 $\sc{v}_2'(B)=\T$，就足以判斷 $\sc{v}_2'(B&or;)=\T$。當然，如果你要用 $\sc{v}_2'(C)=\T$ 來判斷 $\sc{v}_2'(B&or;C)=\T$ 也是可以的。</span></span></td><td>根據 (1) 和定義 4</td></tr>
						<tr><td>因 $\sc{v}_2'(&not;A)=\T$ 且 $\sc{v}_2'(B&or;C)=\T$，<br/>故 $\sc{v}_2'(&not;A&and;(B&or;C))=\T$</td><td>根據 (2),(3) 和定義 3</td></tr>
					</table>
					<p>
					因此，我們可以知道，'$&not;A&and;(B&or;C)$' 在 $\sc{v}_2$ 這個語意模型之下為真。
					</p>
					<p>
					這些真值函數的功能除了可以讓我們從原子語句的真假來判斷出語句的真假之外，還可以讓我們從語句的真假反推出原子語句的真假。我們一樣拿 '$&not;A&and;(B&or;C)$' 來做例子，假設 '$&not;A&and;(B&or;C)$' 為假，那原子語句的真假是如何分配的呢？
					</p>
					<p>
					一樣，因為這個語句是一個連言句，所以我們要先套用定義 3，得知：
					</p>
					<ul>
						<li>$\sc{v}_n'(&not;A&and;(B&or;C))=\T$ 當且僅當 $\sc{v}_n'(&not;A)=\T$ 而且 $\sc{v}_n'(B&or;C)=\T$</li>
					</ul>
					<p>
					由於我們現在要求的是 $\sc{v}_n'(&not;A&and;(B&or;C))=\F$，所以可以加上上述定義得知：
					</p>
					<ul>
						<li>$\sc{v}_n'(&not;A)=\F$ 或者 $\sc{v}_n'(B&or;C)=\F$</li>
					</ul>
					<p>
					既然令 '$&not;A&and;(B&or;C)$' 的可能性有兩個，我們就分別來判斷。首先，根據 $\sc{v}_n'(&not;A)=\F$，我們可以利用定義 2 得知：
					</p>
					<ul>
						<li>$\sc{v}_n'(A)=\T$
					</ul>
					<p>
					再來，根據 $\sc{v}_n'(B&or;C)=\F$，我們可以利用定義 4 得知：
					</p>
					<ul>
						<li>$\sc{v}_n'(B)=\F$ 而且 $\sc{v}_n'(C)=\F$</li>
					</ul>
					<p>
					</p>
					<p>
					從以上討論我們可以發現，要讓 '$&not;A&and;(B&or;C)$' 為假，總共有兩種方法可以做到：(1) 令 '$A$' 為真，只要 '$A$' 為真，無論 '$B$'、'$C$' 的真假是什麼，'$&not;A&and;(B&or;C)$' 都為假；(2) 令 '$B$'、'$C$' 為假，只要 '$B$'、'$C$' 為假，無論 '$A$' 的真假是什麼，'$&not;A&and;(B&or;C)$' 就為假。
					對應到語意模型的話，我們可以知道：
					</p>
					<ol class="num local tight">
						<li>對任何語意模型 $\sc{v}_n$，只要 $\sc{v}_n&vDash;A$，則 $\sc{v}_n&nvDash;&not;A&and;(B&or;C)$；而且，</li>
						<li>對任何語意模型 $\sc{v}_n$，只要 $\sc{v}_n&nvDash;B$ 且 $\sc{v}_n&nvDash;C$，則 $\sc{v}_n&nvDash;&not;A&and;(B&or;C)$。</li>
					</ol>
					<p>
					由以上討論可知，我們可以用任意一個語意模型定義出一個真值函數，並且使用這個真值函數來判斷語句邏輯中所有語句的真假；除此之外，我們還可以反過來利用真值函數判斷任何語句為真或為假的條件。由於這樣的真值函數可以較快速地做到上述這兩件事，因此能幫助我們有效地去判斷一個推論是不是有效的。下一節我們就會討論如何利用語意模型對應的真值函數來判斷一個論證是不是有效論證。
					</p>
				</div>
			</div>
			
			<div class="section" id="logical_properties_and_relations_of_sentences">
				<h2>語句的邏輯性質與邏輯關係</h2>
				
				<div class="subsection" id="logical_properties_of_sentences">
					<h3>語句的邏輯性質</h3>
					<p>
					前面說過，對所有語句邏輯中的語句，我們可以根據一個語句所使用的主要連接詞為其做分類；如今，我們要討論的是另一種分類方法，我們要利用語句的邏輯性質來為語句做分類。根據語句的邏輯性質，我們可以將語句邏輯的語句分為三類：<b>恆真句 (tautology)</b>、<b>矛盾句 (self-contradiction)</b>、<b>偶然語句 (contingent sentence)</b>。
					</p>
					
					<div class="portion" id="tautology">
						<h5>恆真句</h5>
						<p>
						<b>恆真句</b>如果顧名思義的話，會把它理解成是<b>永恆為真</b>的語句，但恆真句其實和時間的變化沒有任何關係，這是翻譯上的誤區，但已成為主流，故本文亦沿用此譯法。恆真句指的是那些在任何語意模型底下皆為真的語句。換言之，無論一個恆真句所使用到的原子語句的真假如何分派，恆真句都為真。
						</p>
						<p>
						因此，當我們畫一個恆真句的真值表時，其主要連接詞那一行一定會全部為真。舉例來說，'$A&or;&not;A$' 就是一個恆真句，它的真值表如下：
						</p>
						<table class="truth single">
							<tr><td>$A$</td><td>$A$</td><td>$&or;$</td><td>$&not;A$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
						</table>
						<p>
						'$A&rarr;(B&rarr;A)$' 也是一個恆真句，其真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$A$</td><td>$&rarr;$</td><td>$(B&rarr;A)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
						</table>
						<p>
						'$(A&rarr;B)&rarr;((A&and;C)&rarr;B)'$ 一樣是一個恆真句，我們也可以試著畫看看這個語句的真值表：
						</p>
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A&rarr;B)$</td><td>$&rarr;$</td><td>$((A&and;C)$</td><td>$&rarr;$</td><td>$B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td></tr>
						</table>
						<p>
						</p>
					</div>
					
					<div class="portion" id="self-contradiction">
						<h5>矛盾句</h5>
						<p>
						第二種語句類型是矛盾句，不過如果要翻譯得更精確的話，這種語句應該被稱作<b>自我矛盾的語句</b>。矛盾句這一名稱中的「矛盾」一詞，語出《韓非子．難一》篇，說楚國有武器商人在賣盾和矛，先誇其盾牌堅固，任何武器都穿不透，又誇其矛鋒利，任何盾牌都能穿透；於是有路人問他：「若用你的矛刺你的盾會怎樣？」那武器商人便啞口無言。
						</p>
						<p>
						如果他的盾果然沒有武器能穿透，那他的矛就不可能什麼都刺得穿；相反地，設若他的矛果然無堅不摧，那他的盾就不可能任何武器都穿不透。因為武器商人所說的話無論如何都不可能成真，因此<b>矛盾句</b>所指的便是在任何語意模型之下皆為假的語句。換言之，無論一個矛盾句所使用到的原子語句的真假如何分派，矛盾句都為假。
						</p>
						<p>
						因此，當我們畫一個矛盾句的真值表時，其主要連接詞那一行一定會全部為假。舉例來說，'$A&and;&not;A$' 就是一個矛盾句，它的真值表如下：
						</p>
						<table class="truth single">
							<tr><td>$A$</td><td>$A$</td><td>$&and;$</td><td>$&not;A$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td></tr>
						</table>
						<p>
							'$&not;(A&rarr;B)&and;&not;(B&rarr;A)$' 也是一個矛盾句，其真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$&not;$</td><td>$(A&rarr;B)$</td><td>$&and;$</td><td>$&not;$</td><td>$(B&rarr;A)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td><td>$\T$</td></tr>
						</table>
						<p>
							'$(A&rarr;(B&and;C))&and;(A&and;&not;B)$' 一樣是一個矛盾句，我們也可以試著畫看看這個語句的真值表：
						</p>
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td>$&rarr;$</td><td>$(B&and;C))$</td><td>$&and;$</td><td>$(A$</td><td>$&and;$</td><td>$&not;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\T$</td></tr>
						</table>
						<p>
						</p>
					</div>
					
					<div class="portion" id="linguistic_property">
						<h5>語言的特性</h5>
						<p>
						值得注意的是，根據定義，一個恆真句會在任何語意模型之下皆為真，而一個矛盾句則會在任何語意模型之下皆為假。那麼，考慮到<b>否定號</b>這個一元連接詞的語意特性是：<b>在任何語意模型下，只要一個語句為真，則它的否定句為假，只要一個語句為假，則它的否定句為真</b>。我們就能得知：恆真句的否定會在任何語意模型下皆為假，因此是矛盾句；而矛盾句的否定則會在任何語意模型下皆為真，因此是恆真句。
						</p>
						<p>
						由於恆真句和矛盾句的真值都不會因為語意模型的改變而改變，這意味著無論我們如何調整原子語句的真假，恆真句都會為真，而矛盾句都會為假。而我在前一章說過，我們可以把每一個語意模型都看成是對世界的某一個可能狀態的描述。因此，恆真句和矛盾句的真值不會因為語意模型的改變而改變，就意味著恆真句和矛盾句的真值不是由世界的狀態所決定的。
						</p>
						<p>
						之所以會如此，是因為恆真句與矛盾句的真值完全是由其語句結構來決定的。以 '$A&or;&not;A$' 這個語句來說明，它是一個恆真句，我們可以讓原子語句 '$A$' 代表以下這個中文的原子語句：
						</p>
					</p>
					<ol class="lltd tight song">
							<li>安安姓朱。</li>
					</ol>
					<p>
						<p>
						而它的否定句 '$&not;A$' 會是以下這個中文語句：
						</p>
					</p>
					<ol class="lltpd tight song">
							<li>安安不姓朱。</li>
					</ol>
					<p>
						<p>
						那麼 '$A&or;&not;A$' 就會是以下這個中文語句：
						</p>
					</p>
					<ol class="lltppd tight song">
							<li>安安姓朱，或者安安不姓朱。</li>
					</ol>
					<p>
						<p>
						a'' 這句話看起來像是在談論安安到底姓不姓朱的事情，但其實這句話完全沒有透露關於安安姓什麼的任何資訊。要注意的是，語句之所以可以傳遞任何資訊，不僅是因為我們可以透過意義來理解語句所表達的內容，更重要的是，我們可以透過判斷語句的真假來得到一些關於這個世界的資訊。
						</p>
						<p>
						就以 a 這個語句為例。我們知道 a 這個語句是在表達有個叫「安安」的人，他的姓是「朱」。但如果只是知道這句話的意思，而不知道這句話的真假，我們其實還是不會知道安安到底姓不姓朱，只有當我們知道這句話為真時，才會知道安安確實姓朱，或者當我們知道這句話為假時，才會知道安安不姓朱。
						</p>
						<p>
						然而像 a'' 這樣的語句，即使知道它的真假也不會告訴我們關於安安的任何事，因為 a'' 說的是：「a 和 a' 這兩個句子至少有一個會是真的」，而 a 和 a' 正好是彼此的否定句。給定語句的二值性，一個語句只能是真或是假，因此一個語句及其否定句，定有一個為真。也就是說，根據語言本身的邏輯特性，任何語句和其否定句中定有其一為真，故對任何語句來說，該語句和其否定句所形成的選言句定是真的。
						</p>
						<p>
						同理，給定 '$A$' 代表語句 a，而其否定句 a' 便是 '$&not;A$'，則 '$A&and;&not;A$' 就會代表以下中文語句：
						</p>
					</p>
					<ol class="lltpppd tight song">
							<li>安安姓朱，而且安安不姓朱。</li>
					</ol>
					<p>
						<p>
						語句 a''' 說的是「a 和 a' 這兩個語句皆為真」，但根據語言的二值性，任何語句不能既真又假，因此語句 a 與其否定句 a' 定不能皆為真。也就是說，根據語言本身的邏輯特性，任何語句和其否定句定不能皆為真，故對任何語句來說，該語句和其否定句所形成的連言句定是假的。
						</p>
						<p>
						以這兩個語句為例，恆真句和矛盾句並未透露任何關於世界的資訊，相對地，恆真句與矛盾句所透露的，其實是關於語言的一些特性。比如 '$A&or;&not;A$' 為恆真句一事，即是透露了任何語句與其否定句之中定有一為真，而 '$A&and;&not;A$' 為矛盾句一事，則透露了任何語句與其否定句定不可皆為真。其它的恆真句與矛盾句也都各自透露一些關於語言的特性，這在我們接觸更多語句之間的邏輯關係後會更清楚。
						</p>
					</div>
					
					<div class="portion" id="contingency">
						<h5>偶然語句</h5>
						<p>
						根據前面所說，恆真句和矛盾句並未透露任何關於世界的訊息，而是透露了關於語言本身的邏輯特性。由於世界無論如何改變，我們都是用相同的語言在談論它，因此語言本身（包括其邏輯特性）便不會因世界的改變而改變。那麼，實際上是和語言本身之邏輯特性有關的恆真句與矛盾句，其真假自然不會因為世界的改變而改變。
						</p>
						<p>
						然而，<b>偶然語句</b>則是那些談論世界狀態的語句，因此其真假是會因為世界的改變而改變的。舉例來說，任何一個原子語句一定都是一偶然語句，比如語句 a 這個原子語句，它就會在「<q>安安姓朱</q>」的世界中為真，而在「<q>安安不姓朱</q>」的世界中為假。由於我們用語句邏輯中的 '$A$' 這一原子語句來代表語句 a，故其真值表如下：
						</p>
						<table class="truth single">
							<tr><td>$A$</td><td>$A$</td></tr>
							<tr><td>$\T$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\F$</td><td class="mainc">$F$</td></tr>
						</table>
						<p>
						這個真值表的意思是：在任何 '$A$' 為真的世界裡，'$A$' 為真，而在任何 '$A$' 為假的世界裡，'$A$' 為假。
						</p>
						<p>
						這看起來像是一句廢話，但它其實透露了一個重要的訊息，就是 '$A$' 這樣的一個語句既有可能是真的，也有可能是假的，一切都要看我們在談論的是一個怎樣的世界。這就是偶然語句和恆真句與矛盾句之間的重要差異：偶然語句的真假會因世界的改變而改變，恆真句與矛盾句的真假則否。
						</p>
						<p>
						我們可以再看更多的例子，'$A&and;B$' 也是一個偶然語句，其真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$A&and;B$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td></tr>
						</table>
						<p>
						'$(A&or;B)&rarr;(B&and;C)$' 也是一個偶然語句，其真值表如下：
						</p>
						<table class="truth triple">
							<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A&or;B)$</td><td>$&rarr;$</td><td>$(B&and;C)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
						</table>
						<p>
						從以上幾個真值表應該不難看得出來，偶然語句的真值表一定有某些列為真，某些列為假，這意味著偶然語句的真假會隨著語意模型的不同而不同。由於每個語意模型都是世界的不同狀態，換言之，偶然語句的真假會隨世界的改變而改變。
						</p>
						<p>
						綜上所述，恆真句在所有語意模型之下皆為真，矛盾句在所有語意模型之下皆為假，而這又是基於這兩類語句的邏輯特性使然，故前者又被稱為<b>邏輯真 (logical truth)</b>，而後者則被稱為<b>邏輯假 (logical falsity)</b>。而偶然語句則是相對於此二者的，它的邏輯性質就是會在某些語意模型下為真，在另一些語意模型下為假。
						</p>
					</div>
				</div>
				
				<div class="subsection" id="logical_relations_between_sentences">
					<h3>語句間的邏輯關係</h3>
					<p>
					簡單談過語句的三種邏輯性質，即在所有語意模型下皆真（恆真句之邏輯性質）、在所有語意模型下皆假（矛盾句之邏輯性質）、在某些語意模型下為真而在另一些語意模型下為假（偶然語句之邏輯性質），接下來要介紹的則是語句之間的邏輯關係。
					</p>
					<p>
					語句邏輯中，任兩個語句之間可以存在許多邏輯關係，包括：<b>蘊涵 (entail)</b>、<b>等值 (equivalent)</b>、<b>相容 (compatible)</b>、<b>衝突 (conflict)</b>、<b>矛盾 (contradictory)</b> 和<b>邏輯獨立 (log&shy;i&shy;cally independent)</b> 等關係。不過我們可以將語句間的<b>蘊涵</b>關係視為最基本的一種邏輯關係，因為其它的邏輯關係皆可用蘊涵關係來定義。
					</p>
					
					<div class="portion" id="entailment">
						<h5>蘊涵</h5>
						<p>
						之前在介紹語句邏輯中的五個語句連接詞時，我有提過，'$&rarr;$' 這個語句連接詞表達的是兩個語句間的<b>單向</b>蘊涵關係，不過當時所談的蘊涵關係和此處所談的蘊涵關係是兩個不同的概念：'$&rarr;$' 所表達的是兩個語句之間的<b>實質蘊涵</b>關係，而此處所談的則是兩個語句之間的<b>邏輯蘊涵 (logical entailment)</b> 關係，或者，我們也可以稱之為兩個語句之間的<b>語意蘊涵 (semantic entailment)</b> 關係。
						</p>
						<p>
						給定 '$&alpha;$' 和 '$&beta;$' 是語句邏輯中的兩個語句，如果 '$&alpha;$' 邏輯蘊涵 '$&beta;$'，這就意味著在 '$&alpha;$' 為真的所有情況下，'$&beta;$' 也都為真。讓我們考慮 '$A&and;B$' 和 '$A&or;B$' 這兩個語句，我們可以將它們的真值表畫在一起如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$A&and;B$</td><td>$A&or;B$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$F$</td></tr>
						</table>
						<p>
						值得注意的是，為了判斷 '$A&and;B$' 是否蘊涵 '$A&or;B$'，我們需要檢查的是 '$A&and;B$' 為真的所有情況，因此 '$A&and;B$' 為假的情況都可以被忽略。在上面這個真值表當中，語句 '$A&and;B$' 為真的情況只有第一列，所以我們需要檢查的情況就只有第一列。檢查後發現，在 '$A&and;B$' 為真的所有情況下 '$A&or;B$' 確實都為真，故可以判斷 '$A&and;B$' 確實蘊涵 '$A&or;B$'。
						</p>
						<p>
						但若要反過來考慮 '$A&or;B$' 是否蘊涵 '$A&and;B$' 的話，我們就要檢查所有 '$A&or;B$' 為真的所有情況，而根據上表，'$A&or;B$' 為真的所有情況包括了第一、二、三列這三種情況，而在這三種情況中，只有在第一列的情況下 '$A&and;B$' 也為真，故 '$A&and;B$' 並沒有在所有 '$A&or;B$' 為真的情況下皆為真，因此 '$A&or;B$' 就不蘊涵 '$A&and;B$'。
						</p>
						<p>
						由以上判斷的結果可知，邏輯蘊涵（或語意蘊涵）關係也是一種單向關係：對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，即使 '$&alpha;$' 邏輯蘊涵 '$&beta;$'，'$&beta;$' 也不見得邏輯蘊涵 '$&alpha;$'。
						</p>
						<p>
						若要用更精確的方法來定義兩個語句之間的蘊涵關係，我們可以這麼說：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 邏輯蘊涵 '$&beta;$'，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中，'$&beta;$' 皆為真。</b>根據以上真值表我們可以看出，對所有語意模型 $\sc{v}_n&vDash;A&and;B$（$n$ 為任意自然數），$\sc{v}_n&vDash;A&or;B$，因此 '$A&and;B$' 邏輯蘊涵 '$A&or;B$'。
						</p>
						<p>
						相反地，對某些語意模型 $\sc{v}_n&vDash;A&or;B$（$n$ 為任意自然數），$\sc{v}_n&nvDash;A&and;B$，比如說，當 $\sc{v}_n&vDash;A$ 但 $\sc{v}_n&nvDash;B$，或者當 $\sc{v}_n&nvDash;A$ 但 $\sc{v}_n&vDash;B$ 時，$\sc{v}_n&vDash;A&or;B$ 但 $\sc{v}_n&nvDash;A&and;B$。因此 '$A&or;B$' 就沒有邏輯蘊涵 '$A&and;B$'。
						</p>
						<p>
						根據上述對邏輯蘊涵關係的定義，只要 'α' 邏輯蘊涵 'β'，則任何能讓 'α' 為真的語意模型都會讓 'β' 為真。因此，當 'α' 邏輯蘊涵 'β' 時，只要我們將這兩個語句用語句連接詞 '$&rarr;$' 連接起來，寫成 '$α&rarr;β$' 的形式，它就會是一個恆真句。
						</p>
						<p>
						我們繼續以 '$A&and;B$' 和 '$A&or;B$' 這兩個語句為例，若用 '$&rarr;$' 將此二語句連接，會形成 '$(A&and;B)&rarr;(A&or;B)$' 這一實質單條件句，而其真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$(A&and;B)$</td><td>$&rarr;$</td><td>$(A&or;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
						</table>
						<p>
						根據上表，'$(A&and;B)&rarr;(A&or;B)$' 確是一恆真句，故 '$A&and;B$' 邏輯蘊涵 '$A&or;B$'。
						</p>
						<p>
						相反地，如果要檢查 '$A&or;B$' 是否邏輯蘊涵 '$A&and;B$'，我們就要將 '$A&or;B$' 寫成實質單條件句的前件，而將 '$A&and;B$' 寫成實質單條件句的後件，也就是說，我們必須檢查 '$(A&or;B)&rarr;(A&and;B)$' 是不是一恆真句。'$(A&or;B)&rarr;(A&and;B)$' 的真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$(A&or;B)$</td><td>$&rarr;$</td><td>$(A&and;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
						</table>
						<p>
						根據上表，'$(A&or;B)&rarr;(A&and;B)$' 並不是一個恆真句，當 '$A$' 為真 '$B$' 為假，或 '$A$' 為假 '$B$' 為真的時候，'$(A&or;B)&rarr;(A&and;B)$' 都不為真，因此 '$(A&or;B)$' 就沒有邏輯蘊涵 '$(A&and;B)$'。
						</p>
						<p>
						根據以上對邏輯蘊涵關係的討論，我們可以發現邏輯蘊涵關係和實質蘊涵關係的差異在於，邏輯蘊涵關係是一種跨語意模型的關係，而實質蘊涵關係則是一種相對於個別語意模型的關係。
						</p>
						<p>
						當我們要檢查兩個語句之間是否存在實質蘊涵關係時，我們一定是在<b>某個語意模型</b>之下檢查這件事：只要某個特定的語意模型不會讓 '$&alpha;$' 為真又讓 '$&beta;$' 為假，在那個語意模型之下 '$&alpha;$' 就實質蘊涵 '$&beta;$'。而 '$&alpha;$' 在某個語意模型之下實質蘊涵 '$&beta;$'，意思其實就是：那個語意模型讓 '$&alpha;&rarr;&beta;$' 為真。
						</p>
						<p>
						相對地，當我們要檢查兩個語句間是否存在邏輯蘊涵關係時，我們要檢查的是兩個語句是否在<b>所有語意模型</b>之下皆有實質蘊涵關係：只要 '$&alpha;$' 在所有語意模型之下皆實質蘊涵 '$&beta;$'，'$&alpha;$' 就會邏輯蘊涵 '$&beta;$'。而「<q>'$&alpha;$' 在所有語意模型之下皆實質蘊涵 '$&beta;$'</q>」其實就是 '$&alpha;&rarr;&beta;$' 在所有語意模型之下皆為真的意思，換言之，'$&alpha;&rarr;&beta;$' 是一恆真句。這就是為什麼我們可以藉由檢查 '$&alpha;&rarr;&beta;$' 是不是恆真句，來檢查 '$&alpha;$' 是否邏輯蘊涵 '$&beta;$'。
						</p>
					</div>
					
					<div class="portion" id="equivalence">
						<h5>等值</h5>
						<p>
						緊接在蘊涵關係之後要談的，是<b>等值</b>關係，任兩個語句如果是等值的，就意味著這兩個語句會邏輯蘊涵彼此。所以我們可以將兩個語句間的等值關係定義如下：<b>對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是等值的，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中，'$&beta;$' 皆為真，並且在所有讓 '$&beta;$' 為真的語意模型中，'$&alpha;$' 皆為真。</b>
						</p>
						<p>
						既然等值關係指的是兩個語句彼此相互蘊涵的關係，因此等值關係是一個雙向關係，對任兩個語句 '$&alpha;$' 和 '$&beta;$'，只要 '$&alpha;$' 和 '$&beta;$' 是等值的，'$&beta;$' 和 '$&alpha;$' 也會是等值的。
						</p>
						<p>
						此外，根據等值關係的定義，當 '$&alpha;$' 和 '$&beta;$' 彼此等值的時候，就意味著 '$&alpha;$' 和 '$&beta;$' 的真假一定會在所有情況下都相同。要如何證明這件事呢？
						</p>
						<p>
						首先，假定 '$&alpha;$' 和 '$&beta;$' 是等值的兩個語句，那麼根據定義的前半，在 '$&alpha;$' 為真的所有情況下，'$&beta;$' 都會為真。也就是說，至少在 '$&alpha;$' 為真的那些情況中，'$&alpha;$' 和 '$&beta;$' 的真假會是一樣的（都為真）。因此，如果 '$&alpha;$' 和 '$&beta;$' 的真假有不同，就只能出現在 '$&alpha;$' 不為真的那些情況中。讓我們假設確實在有些情況下 '$&alpha;$' 和 '$&beta;$' 的真假是不同的，那麼在這些情況裡，就一定是 '$&alpha;$' 不為真但 '$&beta;$' 為真的情況。
						</p>
						<p>
						然而，根據等值關係之定義的後半，在 '$&beta;$' 為真的所有情況中，'$&alpha;$' 也都必須為真，因此不可能有那種 '$&beta;$' 為真但 '$&alpha;$' 不為真的情況。然而根據上一段的說明，如果真的在有些情況下 '$&alpha;$' 和 '$&beta;$' 真假是不同的，那麼這些情況一定是 '$&alpha;$' 不為真但 '$&beta;$' 為真的情況。那麼，既然根據等值關係的定義，不可能會有 '$&alpha;$' 不為真但 '$&beta;$' 為真的情況，這就表示不可能會有 '$&alpha;$' 和 '$&beta;$' 的真假不同的情況。
						</p>
						<p>
						故得證：當 '$&alpha;$' 和 '$&beta;$' 彼此等值的時候，'$&alpha;$' 和 '$&beta;$' 的真假一定會在所有情況下都相同。既然如此，我們就可以用真值表來檢查兩個語句是否等值。舉例來說，要檢查 '$&not;A&or;B$' 和 '$A&rarr;B$' 是不是彼此等值的兩個語句，我們可以將這兩個語句的真值表畫在一起如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$(&not;A&or;B)$</td><td>$(A&rarr;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">&ensp;$T$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td class="mainc">&ensp;$F$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td class="mainc">&ensp;$T$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">&ensp;$T$</td><td class="mainc">$T$</td></tr>
						</table>
						<p>
						如上表所示，兩個語句的真假在所有情況下確實都相同，所以 '$&not;A&or;B$' 和 '$A&rarr;B$' 是彼此等值的語句。
						</p>
						<p>
						由於兩個等值的語句之真假在所有情況下都相同，所以當我們將兩個等值的語句以 '$&harr;$' 連接在一起形成一雙條件句後，會得到一個恆真句（因為雙條件句是在前後件同真同假時為真）。因此我們也可以將 '$&not;A&or;B$' 和 '$A&rarr;B$' 以 '$&harr;$' 連接起來，得到一雙條件句 '$(&not;A&or;B)&harr;(A&rarr;B)$'，其真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$(&not;A&or;B)$</td><td>$&harr;$</td><td>$(A&rarr;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>&nbsp;&ensp;$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>&nbsp;&ensp;$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>&nbsp;&ensp;$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>&nbsp;&ensp;$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
						</table>
						<p>
						如表所示，'$(&not;A&or;B)&harr;(A&rarr;B)$' 果然是一個恆真句，因此可以證明 '$&not;A&or;B$' 和 '$A&rarr;B$' 確為彼此等值的兩個語句。
						</p>
						<p>
						值得注意的是，由於兩個彼此等值的語句會在所有情況下都同真同假，所以，只要能夠證明兩個語句是等值的，那麼我們就可以在語句邏輯的脈絡下，將這兩個語句視作意義相同的語句，因此可以在任何情況下替換這兩個語句，並且不會造成任何邏輯意義上的改變。
						</p>
						<p>
						比如說，假定 '$&alpha;$' 和 '$&beta;$' 是彼此等值的兩個語句，當 '$&alpha;$' 出現在某個比較複雜的語句並作為其中的一部分時，例如：'$&delta;&rarr;(&not;&alpha;&and;&gamma;)$'。我們可以用 '$&beta;$' 來替換該語句中的 '$&alpha;$' 得到：'$&delta;&rarr;(&not;&beta;&and;&gamma;)$'。而替換過後的這個新語句，也會和替換前的語句是等值的，也就是說，替換前後的兩個語句的真假會在所有情況下都一樣。
						</p>
						<p>
						基於這個性質，當 '$&alpha;$' 和 '$&beta;$' 彼此等值的時候，'$&alpha;$' 可以推論出來的語句，也都可以用 '$&beta;$' 推論出來，反之亦然；同樣地，當我們可以在任何時候推論出 '$&alpha;$'，我們就可以推論出 '$&beta;$'，反之亦然。至於這個性質有什麼好處，我們會在將來談到推論規則的時候更清楚地體會到。
						</p>
					</div>
					
					<div class="portion" id="compatibility">
						<h5>相容</h5>
						<p>
						前面提到，邏輯蘊涵關係是兩個語句之間的一種<b>單向</b>關係，而<b>相容關係</b>則是兩個語句之間的一種<b>雙向</b>關係。意即，對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，如果 '$&alpha;$' 相容於 '$&beta;$'，那麼 '$&beta;$' 也會相容於 '$&alpha;$'。也就是說，對任意兩個語句來說，只要這兩個語句是相容於，它們一定是相容於<b>彼此</b>的。
						</p>
						<p>
						對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，如果這兩個語句彼此是相容的，意味著這兩個語句可以同時為真。比如說，一樣考慮 '$A&and;B$' 和 '$A&or;B$' 這兩個語句，我們可以將它們的真值表畫在一起如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$A&and;B$</td><td>$A&or;B$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$F$</td></tr>
						</table>
						<p>
						從上表可以看出來，真值表的第一列剛好是 '$A&and;B$' 和 '$A&or;B$' 這兩個語句同時為真的情況：當 '$A$' 為真且'$B$' 也為真的時候，'$A&and;B$' 和 '$A&or;B$' 這兩個語句便同時為真，故此二語句是彼此相容的。
						</p>
						<p>
						如果要用更準確的方法來定義兩個語句之間的相容關係，我們可以這麼說：<b>任兩個語句是相容的，當且僅當，至少有一個語意模型使這兩個語句同時為真。</b>而根據上述真值表，我們可以知道，對任何一個語意模型 $\sc{v}_n$（$n$ 是未知數）滿足 $\sc{v}_n&vDash;A$ 和 $\sc{v}_n&vDash;B$ 這兩個條件，則 $\sc{v}_n&vDash;A&and;B$ 而且 $\sc{v}_n&vDash;A&or;B$。
						</p>
						<p>
						因此的確有語意模型可以讓 '$A&and;B$' 與 '$A&or;B$' 同時為真：任何讓 '$A$' 和 '$B$' 這兩個原子語句同時為真的語意模型，都會讓 '$A&and;B$' 與 '$A&or;B$' 同時為真，故此二語句確是相容的。
						</p>
						<p>
						由於兩個彼此相容的語句一定會在某個語意模型之下同時為真，因此我們可以用真值表來判斷任兩個語句之間是否相容：只要兩個語句是相容的，當我們用 '$&and;$' 將此二語句連接成一個連言句時，其真值表至少有會有一列為真。我們繼續以 '$A&and;B$' 和 '$A&or;B$' 這兩個語句為例，將此二語句以 '$&and;$' 連接起來，形成 '$(A&and;B)&and;(A&or;B)$' 這個連言句，其真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$(A&and;B)$</td><td>$&and;$</td><td>$(A&or;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
						</table>
						<p>
						如表所示，'$(A&and;B)&and;(A&or;B)$' 的真值表果然至少有一列（即第一列）為真，因此可以證明 '$A&and;B$' 和 '$A&or;B$' 這兩個語句確實相容。
						</p>
					</div>
					
					<div class="portion" id="conflict">
						<h5>衝突</h5>
						<p>
						緊接在相容關係之後要介紹的是兩個語句之間的<b>衝突</b>關係，任兩個語句如果是衝突的，就意味著這兩個語句是不相容的。因此，我們可以將兩個語句的衝突關係定義如下：<b>對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是衝突的，當且僅當，所有語意模型都不會讓 '$&alpha;$' 和 '$&beta;$' 同時為真。</b>
						</p>
						<p>
						舉例來說，考慮 '$&not;A$' 和 '$A&and;B$' 這兩個語句，我們可以將這兩個語句的真值表畫在一起如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$&not;A$</td><td>$A&and;B$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
						</table>
						<p>
						根據以上真值表所顯示的，'$&not;A$' 和 '$A&and;B$' 這兩個語句在所有可能的情況中都沒有同時為真。也就是說，對所有語意模型 $\sc{v}_n$（$n$ 是任意自然數）而言，$\sc{v}_n&nvDash;&not;A$ 或者 $\sc{v}_n&nvDash;A&and;B$。總之不會有任何一個語意模型讓兩個語句同時為真，故 '$&not;A$' 和 '$A&and;B$' 是衝突的。
						</p>
						<p>
						衝突關係除了可以用相容關係來定義（兩個不相容的語句就是衝突的語句）以外，其實也可以用蘊涵關係來定義。衝突關係的定義說：對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是衝突的，當且僅當，所有語意模型都不會讓 '$&alpha;$' 和 '$&beta;$' 同時為真。而「<q>所有語意模型都不會讓 '$&alpha;$' 和 '$&beta;$' 同時為真</q>」的意思其實就是「<q>所有語意模型都會讓 '$&alpha;$' 為假，或者讓 '$&beta;$' 為假</q>」。
						</p>
						<p>
						根據語句的二值性，我們可以知道，當一個語意模型讓 '$&alpha;$' 為假，其實就是讓 '$&not;&alpha;$' 為真；當一個語意模型讓 '$&beta;$' 為假，其實就是讓 '$&not;&beta;$' 為真。因此，「<q>所有語意模型都會讓 '$&alpha;$' 為假，或者讓 '$&beta;$' 為假</q>」就可以被理解為：
						</p>
						<ul class="disc song tight">
							<li>所有語意模型都會讓 '$&alpha;$' 為假，或者讓 '$&not;&beta;$' 為真；以及，</li>
							<li>所有語意模型都會讓 '$&beta;$' 為假，或者讓 '$&not;&alpha;$' 為真。</li>
						</ul>
						<p>
						然後，參考我們在第二章裡用語意模型，或者在第三章中用真值函數來定義實質單條件句的真值表的方法，就會發現上述兩個說法又可以被進一步理解為：
						</p>
						<ul class="disc song tight">
							<li>所有語意模型都會讓 '$&alpha;&rarr;&not;&beta;$' 為真；以及，</li>
							<li>所有語意模型都會讓 '$&beta;&rarr;&not;&alpha;$' 為真。</li>
						</ul>
						<p>
						而這兩個說法其實就是在說：
						</p>
						<ul class="disc song tight">
							<li>'$&alpha;&rarr;&not;&beta;$' 為一恆真句；以及，</li>
							<li>'$&beta;&rarr;&not;&alpha;$' 為一恆真句。</li>
						</ul>
						<p>
						接著，根據我們先前對邏輯蘊涵關係的定義，我們可以將上述兩個說法再進一步地理解為：
						</p>
						<ul class="disc song tight">
							<li>'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'；以及，</li>
							<li>'$&beta;$' 邏輯蘊涵 '$&not;&alpha;$'。</li>
						</ul>
						<p>
						因此，我們可以將衝突關係的定義重新改寫為：<b>對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是衝突的，當且僅當，'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'。</b><span class="note"><span class="box">或者也可以說是 '$&beta;$' 邏輯蘊涵 '$&not;&alpha;$'，兩個說法的意思是相同的。</span></span>換言之，任意兩個語句是衝突的，當且僅當，兩個語句會互相蘊涵彼此的否定句。
						</p>
						<p>
						反過來說，由於衝突的語句就是互不相容的語句，所以相容的語句其實就是互不衝突的語句。因此，我們也可以用邏輯蘊涵關係來定義相容關係：<b>任意兩個語句是相容的，當且僅當，這兩個語句都不會邏輯蘊涵彼此的否定句。</b>
						</p>
						<p>
						由於兩個彼此衝突的語句不會同時為真，因此當我們以 '$&and;$' 來連接兩個彼此衝突的語句時，所得的連言句就會是一矛盾句。以 '$&not;A$' 和 '$A&and;B$' 這兩個語句為例，將它們以 '$&and;$' 連接起來所形成的連言句之真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$&not;A$</td><td>$&and;$</td><td>$(A&and;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$F$</td><td>$\T$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$F$</td><td>$\F$</td></tr>
						</table>
						<p>
						依上表所示，用 '$&and;$' 連接 '$&not;A$' 和 '$A&and;B$' 所形成之連言句 '$&not;A&and;(A&and;B)$' 確實為一矛盾句，故 '$&not;A$' 和 '$A&and;B$' 彼此衝突。
						</p>
					</div>
					
					<div class="portion" id="contradiction">
						<h5>矛盾</h5>
						<p>
						在談語句的邏輯性質時，我們有介紹到一種語句類型叫做<b>矛盾句</b>，而此處要介紹的<b>矛盾 (contradictory) 關係</b>則是存在於兩個語句之間的邏輯關係。兩者雖然名稱幾乎一樣，而且也確實有千絲萬縷的關係，但仍是不同的概念，要注意區分，避免混淆。
						</p>
						<p>
						矛盾關係也是一種雙向關係，也就是說，對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，如果 '$&alpha;$' 和 '$&beta;$' 是矛盾的，則 '$&beta;$' 和 '$&alpha;$' 也是矛盾的。當兩個語句彼此矛盾時，就意味著這兩個語句既不會同時為真，也不會同時為假。換言之，當 '$&alpha;$' 和 '$&beta;$' 彼此矛盾時，只要 '$&alpha;$' 為真，'$&beta;$' 就會為假，並且，只要 '$&alpha;$' 為假，'$&beta;$' 就會為真。
						</p>
						<p>
						考慮一組最典型的矛盾句：'$A$' 和 '$&not;A$'，我們可以將這兩個語句的真值表畫在一起如下表：
						</p>
						<table class="single truth">
							<tr><td>$A$</td><td>$A$</td><td>$&not;A$</td></tr>
							<tr><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
						</table>
						<p>
						從上表可以清楚地看出來，由於 '$&not;A$' 是 '$A$' 的否定句，故當 '$A$' 為真時，'$&not;A$' 就為假；反之當 '$A$' 為假時，'$&not;A$' 就為真。故此二語句確實彼此矛盾。
						</p>
						<p>
						若要用更精確的方法來定義兩個語句之間的矛盾關係，我們可以這麼說：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 彼此矛盾，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中 '$&beta;$' 皆為假，而且在所有讓 '$&alpha;$' 為假的語意模型中 '$&beta;$' 皆為真。</b>根據以上真值表我們可以看出，對所有語意模型 $\sc{v}_n&vDash;A$（$n$ 為任意自然數），$\sc{v}_n&nvDash;&not;A$，而且對所有語意模型 $\sc{v}_n&nvDash;A$，$\sc{v}_n&vDash;&not;A$。因此 '$A$' 和 '$&not;A$' 是彼此矛盾的語句。
						</p>
						<p>
						值得注意的是，在定義兩個語句間的矛盾關係時，我們用到了「<q>在所有讓 '$α$' 為真的語意模型中 '$β$' 皆為假</q>」和「<q>在所有讓 '$α$' 為假的語意模型中 '$β$' 皆為真</q>」這兩個說法，而這兩個說法正好和邏輯蘊涵關係的定義是一致的，也就是說，我們其實可以用邏輯蘊涵關係來定義矛盾關係。
						</p>
						<p>
						首先，根據語句的二值性，當 '$&beta;$' 為假時，'$&not;&beta;$' 為真，而當 '$&alpha;$' 為假時，'$&not;&alpha;$' 為真，因此我們可以將矛盾關係的定義重新寫成：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 彼此矛盾，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中 '$&not;&beta;$' 皆為真，而且在所有讓 '$&not;&alpha;$' 為真的語意模型中 '$&beta;$' 皆為真。</b>
						</p>
						<p>
						接著，根據邏輯蘊涵關係的定義，對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，在所有讓 '$&alpha;$' 為真的語意模型中 '$&not;&beta;$' 皆為真，就意味著 '$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'；而在所有讓 '$&not;&alpha;$' 為真的語意模型中 '$&beta;$' 皆為真，則意味著 '$&not;&alpha;$' 邏輯蘊涵 '$&beta;$'。因此，我們可以將矛盾關係的定義進一步改寫如下：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 彼此矛盾，當且僅當，'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'，而且 '$&not;&alpha;$' 邏輯蘊涵 '$&beta;$'。</b><span class="note"><span class="box">同理，'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$' 就意味著 '$&beta;$' 邏輯蘊涵 '$&not;&alpha;$'；而 '$&not;&alpha;$' 邏輯蘊涵 '$&beta;$' 也意味著  '$&not;&beta;$' 邏輯蘊涵 '$&alpha;$'</span></span>
						</p>
						<p>
						也就是說，對任意兩個語句來說，只要這兩個語句會相互蘊涵彼此的否定句，而且這兩個語句都會被彼此的否定句蘊涵，則這兩個語句就是彼此矛盾的語句。
						</p>
						<p>
						若比較矛盾關係和衝突關係的定義可以發現，衝突關係只要求兩個語句要蘊涵彼此的否定句，而未要求兩個語句也要被彼此的否定句蘊涵，因此矛盾關係成立的條件比衝突關係還要更嚴格。也就是說，當兩個語句彼此矛盾時，這兩個語句一定是彼此衝突的，但反之則不一定。
						</p>
						<p>
						以之前在談衝突關係時用到的語句 '$&not;A$' 和 '$A&and;B$' 為例，固然在 '$&not;A$' 為真的所有情況下，'$A&and;B$' 都為假，而且在 '$A&and;B$' 為真的所有情況下，'$&not;A$' 也都為假，因此這兩個語句確實不會同時為真，故彼此衝突。但注意，當 '$A$' 為真而 '$B$' 為假時，'$&not;A$' 和 '$A&and;B$' 卻同時為假，因此這兩個語句可以同時為假，故彼此並不矛盾。
						</p>
						<p>
						由於兩個矛盾的語句會彼此蘊涵對方的否定句，同時也會被對方的否定句給蘊涵，這意味著，當 '$&alpha;$' 與 '$&beta;$' 彼此矛盾時，我們若以 '$&rarr;$' 來連接其中一個語句和另一個語句的否定句，例如 '$&alpha;$' 和 '$&not;&beta;$'（當然，'$&beta;$' 和 '$&not;&alpha;$' 也可以），形成的實質單條件句 '$&alpha;&rarr;&not;&beta;$' 會是恆真句；並且，將該實質單條件句的前後件對調所形成的語句 '$&not;&beta;&rarr;&alpha;$' 也會是恆真句。
						</p>
						<p>
						若將 '$&alpha;&rarr;&not;&beta;$' 和 '$&not;&beta;&rarr;&alpha;$' 這兩個單條件句合在一起，就會得到 '$&alpha;&harr;&not;&beta;$' 這一雙條件句，因此，當兩個語句 '$&alpha;$' 和 '$&beta;$' 彼此矛盾時，只要將其中一語句和另一個語句的否定句以 '$&harr;$' 連在一起，所形成的雙條件句（'$&alpha;&harr;&not;&beta;$' 或 '$&beta;&harr;&not;&alpha;$'）就會是恆真句。以 '$A$' 和 '$&not;A$' 這兩個語句為例，將 '$A$' 和 '$&not;A$' 的否定句 '$&not;&not;A$' 以 '$&harr;$' 連在一起，會得到 '$A&harr;&not;&not;A$'，其真值表如下：
						</p>
						<table class="single truth">
							<tr><td>$A$</td><td>$A$</td><td>$&harr;$</td><td>$&not;$</td><td>$(&not;A)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td><td>$\T$</td></tr>
						</table>
						<p>
						依上表所示，'$A&harr;&not;&not;A$' 果然是恆真句，故可證 '$A$' 與 '$&not;A$' 確實彼此矛盾。或者，我們也可以用 '$&harr;$' 連接 '$A$' 的否定句和 '$&not;A$' 這兩個語句，得到 '$&not;A&harr;&not;A$'，其真值表如下：
						</p>
						<table class="single truth">
							<tr><td>$A$</td><td>$&not;A$</td><td>$&harr;$</td><td>$&not;A$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
						</table>
						<p>
						依上表所示，'$&not;A&harr;&not;A$' 果然也是一恆真句，故亦得證 '$A$' 和 '$&not;A$' 彼此矛盾。
						</p>
						<p>
						為了加深讀者的印象，我再舉一組矛盾的語句為例：'$A&or;&not;B$' 與 '$&not;A&and;B$' 也是一組彼此矛盾的語句，我們可以將此二語句的真值表畫在一起如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$A&or;&not;B$</td><td>$&not;A&and;B$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
						</table>
						<p>
						依上表所示，在 '$A&or;&not;B$' 為真的所有情況中（也就是真值表的第一、二、四列這三種情況），'$&not;A&and;B$' 都為假，而且在 '$A&or;&not;B$' 為假的所有情況中（也就是真值表的第三列），'$&not;A&and;B$' 也確實都為真，因此這兩個語句確實彼此矛盾。
						</p>
						<p>
						除此以外，我們也可以用雙條件句的方式來檢查這兩個語句是否彼此矛盾，我們可以選擇用 '$A&or;&not;B$' 和 '$&not;A&and;B$' 的否定句（也就是 '$&not;(&not;A&and;B)$'）來形成雙條件句，也可以選擇用 '$A&or;&not;B$' 的否定句（即 '$&not;(A&or;&not;B)$'）和 '$&not;A&and;B$' 來形成雙條件句。只要 '$A&or;&not;B$' 與 '$&not;A&and;B$' 確實彼此矛盾，則前述兩個雙條件句一定都會是恆真句。我們分別以真值表檢查：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$(A&or;&not;B)$</td><td>$&harr;$</td><td>$&not;$</td><td>$(&not;A&and;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
						</table>
						<p>
						如上表，若以 '$&harr;$' 連接 '$A&or;&not;B$' 和 '$&not;A&and;B$' 的否定句（即 '$&not;(&not;A&and;B)$'），得到的雙條件句 '$(A&or;&not;B)&harr;&not;(&not;A&and;B)$' 確實是恆真句。我們也可以用 '$&harr;$' 來連接 '$A&or;&not;B$' 的否定句（即 '$&not;(A&or;&not;B)$'）和 '$&not;A&and;B$' 這兩個語句，如此我們將會得到 '$&not;(A&or;&not;B)&harr;(&not;A&and;B)$' 這一雙條件句，並以真值表檢查它是否為恆真句：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$&not;$</td><td>$(A&or;&not;B)$</td><td>$&harr;$</td><td>$(&not;A&and;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
						</table>
						<p>
						依上表所示，'$&not;(A&or;&not;B)&harr;(&not;A&and;B)$' 果然也是恆真句，故亦可證明 '$A&or;&not;B$' 和 '$&not;A&and;B$' 彼此矛盾。
						</p>
						<p>
						要注意的是，由於對於任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;&harr;&not;&beta;$' 和 '$&not;&alpha;&harr;&beta;$' 會是<b>等值</b>的兩個語句，所以只要檢查其中的一個就等於檢查了另一個。因此當我們要檢查兩個語句 '$&alpha;$' 和 '$&beta;$' 是否彼此矛盾時，其實只要在 '$&alpha;&harr;&not;&beta;$' 和 '$&not;&alpha;&harr;&beta;$' 之間選擇一個來檢查即可。我在上面之所以分別都檢查一遍，只是為了不要有所遺漏而已。
						</p>
						<p>
						此外，根據矛盾關係的定義，當兩個語句 '$&alpha;$' 和 '$&beta;$' 彼此矛盾時，這兩個語句的真假在所有情況下一定都不相同，因此當我們用 '$&harr;$' 來連接 '$&alpha;$' 和 '$&beta;$' 這兩個語句時，得到的雙條件句一定會是一個矛盾句。這是因為根據雙條件句的真值表，只要雙條件句的前後件真假不同，雙條件句就為假。因此我們也可以用這個方法來檢查兩個語句是否彼此矛盾。
						</p>
						<p>
						比如說，我們可以將 '$A$' 和 '$&not;A$' 用 '$&harr;$' 連接起來形成 '$A&harr;&not;A$'，並檢查其真值表如下：
						</p>
						<table class="single truth">
							<tr><td>$A$</td><td>$A$</td><td>$&harr;$</td><td>$&not;A$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
						</table>
						<p>
						如表所示，'$A&harr;&not;A$' 果為一矛盾句，因此 '$A$' 和 '$&not;A$' 彼此矛盾。
						</p>
						<p>
						又比如說，我們可以將 '$A&or;&not;B$' 和 '$&not;A&and;B$' 用 '$&harr;$' 連接起來，形成以下雙條件句： '$(A&or;&not;B)&harr;(&not;A&and;B)$'，並檢查其真值表如下：
						</p>
						<table class="truth double">
							<tr><td>$A$</td><td>$B$</td><td>$(A&or;&not;B)$</td><td>$&harr;$</td><td>$(&not;A&and;B)$</td></tr>
							<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
							<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
						</table>
						<p>
						如表所示，'$(A&or;&not;B)&harr;(&not;A&and;B)$' 確為矛盾句，故可證 '$A&or;&not;B$' 和 '$&not;A&and;B$' 為彼此矛盾的語句。
						</p>
					</div>
					
					<div class="portion" id="independence">
						<h5>邏輯獨立</h5>
						<p>
						在介紹完上述五個語句之間可能存在的邏輯關係之後，我們要介紹的是最後一個，<b>邏輯獨立</b>的關係。邏輯獨立也是一種雙向關係，在我們所介紹的這六個語句間的邏輯關係中，除了蘊涵關係是單向關係外，其它五種關係都是雙向關係。
						</p>
						<p>
						當兩個語句彼此是邏輯獨立的時候，就意味著這兩個語句除了相容之外，不具備其它任何邏輯關係。它們既不矛盾也不衝突、不等值、也沒有任何一個蘊涵另外一個。當兩個語句邏輯上彼此獨立時，無論將兩個語句寫成連言句、條件句或雙條件句，都只會得到偶然語句。
						</p>
					</div>
					
					<div class="portion" id="relation_chart">
						<h5>邏輯關係之關係圖</h5>
						<p>
						介紹完以上六種不同的邏輯關係之後，我們可以將語句間的邏輯關係之間的關係整理成以下圖表：
						</p>
						<svg height="426px">
							<rect height="50" width="75" x="0" y="100" />
								<text x="15" y="130"><tspan class="ita bold">&alpha;&emsp;&beta;</tspan></text>
								<path marker-end="url(#head)" d="M37.5 100 L37.5 50 L100 50" />
							<rect height="50" width="75" x="106" y="25" />
								<text x="127" y="56" class="bold">相容</text>
								<path marker-end="url(#head)" d="M181 50 L200 50 L200 26 L224 26" />
								<rect height="50" width="100" x="230" y="1" />
									<text x="239" y="23" class="bold">
										<tspan class="ita">&alpha;</tspan> 不蘊涵 <tspan class="ita">&beta;</tspan>
									</text>
									<text x="239" y="41" class="bold">
										<tspan class="ita">&beta;</tspan> 不蘊涵 <tspan class="ita">&alpha;</tspan>
									</text>
									<path marker-end="url(#head)" d="M330 26 L354 26" />
									<rect x="360" y="1" width="75" height="50" />
										<text class="bold">
											<tspan x="381" y="23">邏輯</tspan>
											<tspan x="381" y="41">獨立</tspan>
										</text>
										<path marker-end="url(#head)" d="M435 26 L502 26 L502 69" />
								<path marker-end="url(#head)" d="M200 50 L200 100 L224 100" />
								<rect height="50" width="100" x="230" y="75" />
									<text x="246" y="97" class="bold">
										<tspan class="ita">&alpha;</tspan> 蘊涵 <tspan class="ita">&beta;</tspan>
									</text>
									<text x="239" y="115" class="bold">
										<tspan class="ita">&beta;</tspan> 不蘊涵 <tspan class="ita">&alpha;</tspan>
									</text>
									<path marker-end="url(#head)" d="M330 100 L459 100" />
								<path marker-end="url(#head)" d="M200 100 L200 175 L224 175" />
								<rect height="50" width="100" x="230" y="150" />
									<text x="239" y="172" class="bold">
										<tspan class="ita">&alpha;</tspan> 不蘊涵 <tspan class="ita">&beta;</tspan>
									</text>
									<text x="246" y="190" class="bold">
										<tspan class="ita">&beta;</tspan> 蘊涵 <tspan class="ita">&alpha;</tspan>
									</text>
									<path d="M330 175 L398 175 L398 100" />
									<rect x="465" y="75" width="75" height="50" />
										<text class="bold">
											<tspan x="486" y="97">邏輯</tspan>
											<tspan x="478" y="115">不等值</tspan>
										</text>
								<path marker-end="url(#head)" d="M200 175 L200 250 L224 250" />
								<rect height="50" width="100" x="230" y="225" />
									<text x="246" y="247" class="bold">
										<tspan class="ita">&alpha;</tspan> 蘊涵 <tspan class="ita">&beta;</tspan>
									</text>
									<text x="246" y="265" class="bold">
										<tspan class="ita">&beta;</tspan> 蘊涵 <tspan class="ita">&alpha;</tspan>
									</text>
									<path marker-end="url(#head)" d="M330 250 L354 250" />
									<rect x="360" y="225" height="50" width="75" />
										<text class="bold">
											<tspan x="381" y="247">邏輯</tspan>
											<tspan x="381" y="265">等值</tspan>
										</text>
								<path marker-end="url(#head)" d="M37.5 150 L37.5 200 L100 200" />
								<rect x="106" y="175" height="50" width="75" />
									<text class="bold">
										<tspan x="127" y="197">衝突</tspan>
										<tspan x="112" y="215">(不相容)</tspan>
									</text>
									<path marker-end="url(#head)" d="M143 225 L143 325 L106 325" />
									<rect x="0" y="300" width="100" height="50" />
										<text class="bold">
											<tspan x="17" y="322">不可同真</tspan>
											<tspan x="17" y="341">但可同假</tspan>
										</text>
										<path marker-end="url(#head)" d="M50 350 L50 400 L354 400" />
										<rect x="360" y="375" width="75" height="50" />
											<text class="bold">
												<tspan x="381" y="397">衝突</tspan>
												<tspan x="366" y="416">但不矛盾</tspan>
											</text>
											<path d="M435 400 L502 400 L502 325" />
									<path marker-end="url(#head)" d="M143 325 L194 325" />
									<rect x="200" y="300" width="100" height="50" />
										<text class="bold">
											<tspan x="218" y="322">不可同真</tspan>
											<tspan x="210" y="341">亦不可同假</tspan>
										</text>
										<path marker-end="url(#head)" d="M300 325 L354 325" />
										<rect x="360" y="300" width="75" height="50" />
											<text class="bold" x="381" y="331">矛盾</text>
											<path marker-end="url(#head)" d="M435 325 L502 325 L502 131" />
						</svg>
					</div>
				</div>
			</div>
			
			<div class="section">
				<h2>真值函數的應用</h2>
				<p>
				前面介紹過語句的邏輯特性，也介紹過語句之間的邏輯關係，並且也說明了要如何利用真值表來判斷那些邏輯特性與邏輯關係。不過，就如我所強調的，當我們要判斷的語句所使用到的原子語句數量較多時，畫真值表會變得太麻煩，而且也很容易出錯，因此這一節要介紹一種新的判斷方法，它利用歸謬推論的原則，並以真值函數作為工具，能夠更迅速且確實地幫助我們判斷語句的邏輯特性，以及語句間的邏輯關係。
				</p>
			
				<div class="subsection">
					<h3>歸謬推論的原則</h3>
					<p>
					歸謬推論是一種推論技巧，這種推論技巧的應用時機是，當我們發現要直接去論證某個結論並不容易時，我們會假設它為假（也就是假設它的否定為真），然後試圖從這個假設出發，看看能不能推論出什麼荒謬的結果。
					</p>
					<p>
					一但推論出任何荒謬的結果，我們就能據此主張：為了拒絕這個荒謬的結果，我們只好回過頭去反對一開始的假設。由於我們一開始的假設是：我們原本想要論證的結論為假，那麼反對這個假設，其實就是主張：我們想要論證的結論為真。於是我們就間接地證明了我們原本想要推論的結論為真。
					</p>
					<p>
					歸謬推論的技巧其實經常被應用在生活中，舉例來說，在爭論同性婚姻是否應該要被法制化的時候，反對方就經常使用歸謬推論證據的技巧來論證他們想要支持的結論：同性婚姻不應該被法制化。
					</p>
					<p>
					比如說，他們指出，一但同性婚姻法制化的立法通過之後，孩子就不能稱自己的父母為「爸爸」或「媽媽」，而只能稱他們為「雙親」，因此才出現了那個「<a href="https://www.youtube.com/watch?v=MpE87QhI3MQ" target="_blank">爸爸媽媽不見了，爺爺奶奶消失了</a>」的知名廣告。
					</p>
					<p>
					雖然這個廣告的主張十分荒謬，因為我們都知道日常生活中人際之間的稱謂本來就不受到法律用語的約束，因此無法法律上用怎樣的語詞去稱呼人際之間的關係，都不影響我們繼續用我們習慣的方式來稱呼彼此的親友。但這仍然是一個歸謬推論技巧的使用（雖然是失敗的使用）。
					</p>
					<p>
					這個推論想要支持的結論是：<b>不應該修改民法容納同性婚姻</b>。但這個推論並不直接尋找理由來支持這個結論，而是先假設這個結論的否定為假，也就是「<b>應該修改民法容納同性婚姻</b>」，然後從這個假設出發，推論出一但這件事真的被付諸實踐，會讓爸爸媽媽不見，爺爺奶奶消失。
					</p>
					<p>
					基於這是一個我們都不樂見的荒謬結果，所以為了不讓這個結果發生，我們只好回過頭去反對一開始的假設：「<b>應該修改民法容納同性婚姻</b>」。也就是說，為了避免那些不好的後果，我們只好支持：「<b>不應該修改民法容納同性婚姻</b>」這個主張。於是，他們就間接地為他們本來想要支持的結論提供了一個論證。
					</p>
					<p>
					除此以外，我們平常聊天時也經常使用到歸謬推論的技巧，舉例來說，科科這學期從來沒有好好去上任何一堂課，下課也從不複習，甚至有些科目的考試只交白卷。學期剛結束時，科科和安安在聊天：
						<blockquote>
						科科：我這學期的課一定會 all pass！<br/>
						安安：你要是能 all pass，豬都會飛。
						</blockquote>
					在這段對話之中，可以明白地看出來安安一點都不相信科科有可能 all pass。之所以看得出來這件事，是因為我們看出來安安使用的歸謬推論。
					</p>
					<p>
					安安說：「你要是能 all pass，豬都會飛」，其實就是先假設他想要論證的結論：「科科不能 all pass」為假，也就是假設「科科能 all pass」為真，並且從這個假設推論出「豬都會飛」的結論。但因為「豬會飛」這個結論太過荒謬，不能接受，所以我們只好回頭反對一開始的假設，因此接受「科科不能 all pass」的結果。
					</p>
					<p>
					當然，在這個對話中，安安並沒有成功地說明為什麼只要科科能 all pass，豬就會飛，因此不算是一個成功的歸謬推論。但儘管不成功，我們還是可以從這樣的對話中看出來安安堅定地信念：科科不可能 all pass。這就像是上面那個反對同性婚姻的廣告一樣，即使推論並不成功，但我們還是可以清楚地察覺其意圖。
					</p>
					<p>
					整理以上的討論，歸謬推論的重點有兩個：一、從假設真的可以推論出荒謬的結果；二、那個結果必須真的是很荒謬的。如果條件一不能被滿足，從假設其實推論不出任何荒謬的結果，那自然不會有什麼荒謬的結果需要拒絕，也就無法促使我們回頭修改假設。如果條件二不能被滿足，也就是說推論出來的結果其實可以被接受，那一樣也無法促使我們回頭修改假設。所以，要做一個成功的歸謬推論，上述兩個條件必須同時被滿足。
					</p>
				</div>

				<div class="subsection">
					<h3>用歸謬方法判斷恆真句和矛盾句</h3>
					<p>
					介紹過歸謬推論的原則以及注意事項之後，現在要跟各位介紹如何使用歸謬推論的方法，來判斷一個語句是不是恆真句或矛盾句。
					</p>
					<p>
					前面說過，所謂恆真句，指的就是在所有語意模型之下皆為真的語句，而所謂矛盾句，指的則是在所有語意模型之下皆為假的語句。也就是說，對任何恆真句來說，它<b>不可能為假</b>；同樣地，對任何矛盾句來說，<b>它不可能為真</b>。由於恆真句和矛盾句分別有不可能為假和不可能為真的特性，當我們要判斷一個語句是不是恆真句或矛盾句時，我們就可以利用歸謬推論來判斷一個語句是不是恆真句或矛盾句
					</p>
					<p>
					以恆真句為例：當我們要判斷一個語句是不是恆真句時，我們可以先做一個歸謬假設：假設該語句為假。由於恆真句不可能為假，所以如果該語句是恆真句，那麼假設它為假就必定會有荒謬的結果。因此，如果我們確實可以從這個假設推論出荒謬的結果，那我們就可以回頭去否定原先的假設，而得到：<b>該語句不可能為假</b>這一結論，那就可以證明該語句是一恆真句。反之，如果窮盡一切可能也推論不出荒謬的結果，那就表示這個語句不是恆真句。
					</p>
					<p>
					同理，當我們要判斷一個語句是不是矛盾句時，我們也可以先做一個歸謬假設：假設該語句為真。由於矛盾句不可能為真，所以如果該語句是矛盾句，那麼假設它為真就必定會有荒謬的結果。因此，如果我們確實可以從這個假設推論出荒謬的結果，那我們就可以回去否定原先的假設，而得到：<b>該語句不可能為真</b>這一結論，那就可以證明該語句是一矛盾句。反之，如果窮盡一切可能也推論不出荒謬的結果，那就表示這個語句不是矛盾句。
					</p>
					<p>
					我們在底下將以實際的例子來演練，看看實際上要如何利用歸謬推論來判斷一個語句是不是恆真句或矛盾句。我們一樣先用 '$A&or;&not;A$' 這個經典的恆真句當例子。要判斷 '$A&or;&not;A$' 是不是一個恆真句，我們要先做一個歸謬假設：假設 '$A&or;&not;A$' 為假。然後從這個假設開始，利用我在本章第一節中定義的真值函數，<b>往回推算原子語句的真假</b><span class="note"><span class="box">一定要把一個語句的每個部分都推算到原子語句的層次為止，這點非常重要！否則會漏掉某些可能存在的矛盾！</span></span>要如何分配才能使 '$A&or;&not;A$' 為假：
					</p>
					<table class="prf">
							<tr><td>$\sc{v}_n'(A&or;&not;A)=\F$</td><td>歸謬假設</td></tr>
							<tr><td>$\sc{v}_n'(A)=\F$ 而且 $\sc{v}_n'(&not;A)=\F$</td><td>根據 (1) 和定義 4</td></tr>
							<tr><td>$\sc{v}_n'(A)=\F$ 而且 $\sc{v}_n'(A)=\T$</td><td>根據 (2) 和定義 2</td></tr>
							<tr><td>(3) 自相矛盾</td><td></td></tr>
					</table>
					<p>
					自相矛盾的結果當然是一個荒謬的結果，因為它不可能成立，所以為了拒絕這個荒謬的結果，我們只好回頭去否定一開始的假設，因此我們必須接受 '$A&or;&not;A$' 不可能為假，因此它是一個恆真句。
					</p>
					<p>
					讓我們再看另一個例子，以 '$A&rarr;(B&rarr;A)$' 為例，要判斷它是不是一個恆真句，我們一樣先假設它為假，然後再進行推論：
					</p>
					<table class="prf">
							<tr><td>$\sc{v}_n'(A&rarr;(B&rarr;A))=\F$</td><td>歸謬假設</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$ 而且 $\sc{v}_n'(B&rarr;A)=\F$</td><td>根據 (1) 和定義 5</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$</td><td>根據 (2)</td></tr>
							<tr><td>$\sc{v}_n'(B&rarr;A)=\F$</td><td>根據 (2)</td></tr>
							<tr><td>$\sc{v}_n'(B)=\T$ 而且 $\sc{v}_n'(A)=\F$</td><td>根據 (4) 和定義 5</td></tr>
							<tr><td>$\sc{v}_n'(A)=\F$</td><td>根據 (5)</td></tr>
							<tr><td>(3) 和 (6) 彼此矛盾</td><td></td></tr>
					</table>
					<p>
					在這個推論中，我們得到的是彼此矛盾的結果，而彼此矛盾的結果當然也是荒謬的結果。因此為了拒絕這個荒謬的結果，我們只好回頭去否定一開始的假設，所以我們必須接受 '$A&rarr;(B&rarr;A)$' 不可能為假，因此它是一個恆真句。
					</p>
					<p>
					從以上兩個例子可以看出來，當我們要以真值函數做歸謬推論時，我們要得到的荒謬結果其實就是矛盾的結果。只要在推論的過程中發現矛盾，就可以回過頭去否定原本做的歸謬假設。
					</p>
					<p>
					不過，有時候要發現矛盾的結果並不那麼容易。以我們前面討論過的兩個例子來看，它們都只用到了單線的推論。然而，在某些情況裡，我們的推論或許會產生分支，那就必須分成多條支線處理。我們可以試著判斷 '$(A&rarr;B)&rarr;((A&and;C)&rarr;B)$' 是不是一個恆真句：
					</p>
					<table class="prf">
							<tr><td>$\sc{v}_n'((A&rarr;B)&rarr;((A&and;C)&rarr;B))=\F$</td><td>歸謬假設</td></td></tr>
							<tr><td>$\sc{v}_n'(A&rarr;B)=\T$ 而且 $\sc{v}_n'((A&and;C)&rarr;B)=\F$</td><td>根據 (1) 和定義 5</td></tr>
							<tr><td>$\sc{v}_n'(A&rarr;B)=\T$</td><td>根據 (2)</td></tr>
							<tr><td>$\sc{v}_n'((A&and;C)&rarr;B)=\F$</td><td>根據 (2)</td></tr>
							<tr><td>$\sc{v}_n'(A&and;C)=\T$ 而且 $\sc{v}_n'(B)=\F$</td><td>根據 (4) 和定義 5</td></tr>
							<tr><td>$\sc{v}_n'(A&and;C)=\T$</td><td>根據 (5)</td></tr>
							<tr><td>$\sc{v}_n'(B)=\F$</td><td>根據 (5)</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$ 而且 $\sc{v}_n'(C)=\T$</td><td>根據 (6) 和定義 3</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$</td><td>根據 (8)</td></tr>
							<tr><td>$\sc{v}_n'(A)=\F$ 或者 $\sc{v}_n'(B)=\T$</td><td>根據 (3) 和定義 5</td></tr>
							<tr class="last"><td></td><td></td></tr>
					</table>
					<p>
					要注意的是，(10) 的連接詞是「或者」，也就是說，這兩種情況分別都可以讓歸謬假設成立，因此我們必須將兩種可能的情況分別考慮，只有當這兩種情況都會得到矛盾時，我們才能回頭去否定歸謬假設。
					</p>
					<p class="noind">
					<b>情況一</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 10">
							<tr><td>$\sc{v}_n'(A)=\F$</td><td>(10) 的第一種情況</td></tr>
							<tr><td>(9) 和 (11) 彼此矛盾&emsp;</td><td></td></tr>
					</table>
					<p>
					<b>情況二</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 10">
							<tr><td>$\sc{v}_n'(B)=\T$</td><td>(10) 的第二種情況</td></tr>
							<tr><td>(7) 和 (11) 佊此矛盾&emsp;</td><td></td></tr>
					</table>
					<p>
					分別考慮了情況一和二後發現，無論是哪一種情況都會得到矛盾的結果，因此可以知道歸謬假設是錯的，'$(A&rarr;B)&rarr;((A&and;C)&rarr;B)$' 不可能為假，因此是一個恆真句。
					</p>
					<p>
					然後我們再來看第四個例句，看看 '$(A&or;B)&rarr;(A&and;B)$' 是不是一個恆真句，判斷的方式當然還是透過歸謬推論，因此仍然是從歸謬假設開始：
					</p>
					<table class="prf">
							<tr><td>$\sc{v}_n'((A&or;B)&rarr;(A&and;B))=\F$</td><td>歸謬假設</td></tr>
							<tr><td>$\sc{v}_n'(A&or;B)=\T$ 而且 $\sc{v}_n'(A&and;B)=\F$</td><td>根據 (1) 和定義 5</td></tr>
							<tr><td>$\sc{v}_n'(A&or;B)=\T$</td><td>根據 (2)</td></tr>
							<tr><td>$\sc{v}_n'(A&and;B)=\F$</td><td>根據 (2)</td></tr>
							<tr class="last"><td></td><td></td></tr>
					</table>
					<p>
					分析到這個階段時，$\sc{v}_n'(A&or;B)=\T$ 和 $\sc{v}_n'(A&and;B)=\F$ 都還需要進一步地分析，因為它們都還沒被分析到原子語句的層次。
					</p>
					<p>
					可是無論要進一步分析這兩個條件，都會有分支。比如說，若要分析有哪些條件可以讓 $\sc{v}_n'(A&or;B)=\T$ 成立，那就會分成 $\sc{v}_n'(A)=\T$ 和 $\sc{v}_n'(B)=\T$ 這兩個情況；若要分析有哪些條件可以讓 $\sc{v}_n'(A&and;B)=\F$ 成立，則會分成 $\sc{v}_n'(A)=\F$ 和 $\sc{v}_n'(B)=\F$ 兩種情況。
					</p>
					<p>
					既然兩個都會產生分支，先分析哪一個就沒有什麼差別，所以可以任意選一個先做。比如說，我們先分析 $\sc{v}_n'(A&or;B)=\T$ 這個條件。因為會產生分支，所以要記得分成兩個情況來考慮：
					</p>
					<p class="noind">
					<b>情況一</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
							<tr><td>$\sc{v}_n'(A)=\T$</td><td>根據 (3) 和定義 4</td></tr>
							<tr class="last"><td></td><td></td></tr>
					</table>
					<p>
					<b>情況二</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
							<tr><td>$\sc{v}_n'(B)=\T$</td><td>根據 (3) 和定義 4</td></tr>
							<tr class="last"><td></td><td></td></tr>
					</table>
					<p>
					分析到這個步驟時，雖然 $\sc{v}_n'(A&or;B)=\T$ 這個條件已經被分析到原子語句的層次了，但還有 $\sc{v}_n'(A&and;B)=\F$ 這個條件尚未分析，因此在情況一和二當中，都必須繼續分析 $\sc{v}_n'(A&and;B)=\F$ 這個條件。然而，前提說過，若要分析 $\sc{v}_n'(A&and;B)=\F$ 這一條件，也會產生 $\sc{v}_n'(A)=\F$ 和 $\sc{v}_n'(B)=\F$ 這兩個分支。
					</p>
					<p>
					也就是說，既然在情況一和二當中都必須繼續分析 $\sc{v}_n'(A&and;B)=\F$ 這一條件，而分析這一條件又會產生分支，那就表示在情況一和二中又各自必須再分成兩個情況來考慮：
					</p>
					<p class="noind">
						<b>情況一之一</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
							<tr><td>$\sc{v}_n'(A)=\T$</td><td>根據 (3) 和定義 4</td></tr>
							<tr><td>$\sc{v}_n'(A)=\F$</td><td>根據 (4) 和定義 3</td></tr>
							<tr><td>(5) 和 (6) 彼此矛盾&emsp;</td><td>&emsp;</td></tr>
					</table>
					<p>
						<b>情況一之二</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
							<tr><td>$\sc{v}_n'(A)=\T$</td><td>根據 (3) 和定義 4</td></tr>
							<tr><td>$\sc{v}_n'(B)=\F$</td><td>根據 (4) 和定義 3</td></tr>
							<tr><td>沒有出現矛盾&emsp;</td><td></td></tr>
					</table>
					<p>
						<b>情況二之一</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
							<tr><td>$\sc{v}_n'(B)=\T$</td><td>根據 (3) 和定義 4</td></tr>
							<tr><td>$\sc{v}_n'(A)=\F$</td><td>根據 (4) 和定義 3</td></tr>
							<tr><td>沒有出現矛盾&emsp;</td><td></td></tr>
					</table>
					<p>
						<b>情況二之二</b>：
					</p>
					<table class="prf" style="counter-reset:tprf 4">
							<tr><td>$\sc{v}_n'(B)=\T$</td><td>根據 (3) 和定義 4</td></tr>
							<tr><td>$\sc{v}_n'(B)=\F$</td><td>根據 (4) 和定義 3</td></tr>
							<tr><td>(5) 和 (6) 彼此矛盾&emsp;</td><td></td></tr>
					</table>
					<p>
					到此為止，我們已經把 '$(A&or;B)&rarr;(A&and;B)$' 這個語句是不是恆真句的歸謬分析都做完了，因為語句中的每一個部分都被分析到原子語句的層次了。從結果來看，一共有四個分支，而這四個分析當中只有兩個情況是有矛盾的，另外二個情況則沒有任何矛盾。這意味著，至少有兩種不會產生矛盾的方式可以讓 '$(A&or;B)&rarr;(A&and;B)$' 為假，既然如此，這就意味著這個語句<b>可能為假</b>，因此就不是恆真句。
					</p>
					<p>
					以上所示範的都是判斷恆真句的方法，但相同的方法也可以用來判斷一個語句是不是矛盾句。前面說過，因為恆真句有<b>不可能為假</b>的特性，所以為了用歸謬方法來判斷一個語句是不是恆真句，我們在做歸謬假設時必須假設該語句<b>有可能為假</b>，也就是，假設至少有一個語意模型會讓該語句為假。同理，既然矛盾句有<b>不可能為真</b>的特性，在用歸謬方法判斷一個語句是否矛盾句時，歸謬假設就必須假設該語句<b>有可能為真</b>，也就是，假設至少有一個語意模型會讓該語句為真。
					</p>
					<p>
					為了示範實際操作的方法，我們一樣先從最經典的矛盾句 '$A&and;&not;A$' 的分析開始示範。為了使用歸謬法，我們必須假設 '$A&and;&not;A$' 有可能為真：
					</p>
					<table class="prf">
							<tr><td>$\sc{v}_n'(A&and;&not;A)=\T$</td><td>歸謬假設</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$ 而且 $\sc{v}_n'(&not;A)=\T$</td><td>根據 (1) 和定義 3</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$ 而且 $\sc{v}_n'(A)=\F$</td><td>根據 (2) 和定義 2</td></tr>
							<tr><td>(3) 自相矛盾</td><td></td></tr>
					</table>
					<p>
					由於 (3) 自相矛盾，這意味著要讓 '$A&and;&not;A$' 為真就會產生矛盾，也就是說，沒有方法可以讓 '$A&and;&not;A$' 為真而不矛盾，因此 '$A&and;&not;A$' 便不可能為真，故得證 '$A&and;&not;A$' 為一矛盾句。
					</p>
					<p>
					為了熟悉操作的方法，我們再選一個例子來示範，以 '$&not;(A&rarr;B)&and;&not;(B&rarr;A)$' 為例，要用歸謬法判斷它是不是矛盾句，就必須假設它可能為真：
					</p>
					<table class="prf">
							<tr><td>$\sc{v}_n'(&not;(A&rarr;B)&and;&not;(B&rarr;A))=\T$</td><td>歸謬假設</td></tr>
							<tr><td>$\sc{v}_n'(&not;(A&rarr;B))=\T$ 而且 $\sc{v}_n'(&not;(B&rarr;A))=\T$</td><td>根據 (1) 和定義 3</td></tr>
							<tr><td>$\sc{v}_n'(A&rarr;B)=\F$ 而且 $\sc{v}_n'(B&rarr;A)=\F$</td><td>根據 (2) 和定義 2</td></tr>
							<tr><td>$\sc{v}_n'(A&rarr;B)=\F$</td><td>根據 (3)</td></tr>
							<tr><td>$\sc{v}_n'(B&rarr;A)=\F$</td><td>根據 (3)</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$ 而且 $\sc{v}_n'(B)=\F$</td><td>根據 (4) 和定義 5</td></tr>
							<tr><td>$\sc{v}_n'(B)=\T$ 而且 $\sc{v}_n'(A)=\F$</td><td>根據 (5) 和定義 5</td></tr>
							<tr><td>$\sc{v}_n'(A)=\T$</td><td>根據 (6)</td></tr>
							<tr><td>$\sc{v}_n'(A)=\F$</td><td>根據 (7)</td></tr>
							<tr><td>(8) 和 (9) 彼此矛盾</td><td></td></tr>
					</table>
					<p>
					(8) 和 (9) 彼此矛盾的結論意味著要讓 '$&not;(A&rarr;B)&and;&not;(B&rarr;A)$' 為真就會產生矛盾，也就是說，'$&not;(A&rarr;B)&and;&not;(B&rarr;A)$' 不可能為真，因此是一個矛盾句。
					</p>
				</div>
				
				<div class="subsection" id="tree">
					<h3>樹枝法</h3>
					<p>
					在使用前一小節所介紹的推論方法時，可能會因為不確定產生分支的情況到底討論完了沒有而感到困惑，也可能會因為要寫一大堆等式而感到厭煩，所以這一小節要介紹一種更圖形化，而且更簡易的記號方式，讓整個推論的過程可以更清楚且更平易近人。這種方法因為直接將分支的情況以圖形化的方式來呈現，故又被稱為<b>樹枝法</b>，但其原理其實仍是利用歸謬法與真值函數進行推論。
					</p>
					<p>
					在使用樹枝法時，為了簡化記號的方式，我們將函數的記號一概省略，當我們原本要寫 '$\sc{v}_n'(&alpha;)=\T$' 時（意思是：$\sc{v}_n$ 這個語意模型會讓 '$&alpha;$' 這個語句為真），我們就直接寫 '$&alpha;$'；相反地，當我們需要寫 '$\sc{v}_n'(&alpha;)=\T$'（意思是：$\sc{v}_n$ 這個語意模型會讓 '$&alpha;$' 這個語句為假），我們就直接寫 '$&not;&alpha;$'。
					</p>
					<p>
					此外，在用樹枝法分析語句時還要謹記：如果一個分支已經出現矛盾，那就可以不用再分析下去，但對於那些一直沒有出現矛盾的分支，請一定要分析到所有語句部分都只剩下<b>原子語句</b>或<b>原子語句的否定句</b>為止，才能判斷該分支沒有矛盾，否則很有可能會有一些矛盾被遺漏掉。
					</p>
					<p>
					以下用 '$(A&rarr;B)&rarr;((A&and;C)&rarr;B)$' 當作例子來示範。為了用歸謬法證明這個語句是一個恆真句，我們必須先假設這個語句為假，然後用真值函數推論出要讓這個語句為假的條件是什麼，如果所有可能令該語句為假的條件都有矛盾，那麼這個語句就不可能為假，因此就是恆真句。反之，只要有任何可能令該語句為假的條件不會有任何矛盾，該語句就不是恆真句。以下是推論的做法：
					</p>
					<div class="tree">
						<span>$&not;((A&rarr;B)&rarr;((A&and;C)&rarr;B))$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;((A&and;C)&rarr;B)$</span>
					</div>
					<p>
					在這個樹狀圖中的第一行，我寫上了 '$&not;((A&rarr;B)&rarr;((A&and;C)&rarr;B))$'，這一行就是這個推論的歸謬假設，也就是假設 '$(A&rarr;B)&rarr;((A&and;C)&rarr;B)$' 有可能為假。接著，我畫了一條直線下來到第二組，我寫下 '$A&rarr;B$' 和 '$&not;((A&and;C)&rarr;B)$' 這兩行，意思是：為了讓歸謬假設成立，'$A&rarr;B$' 須為真，'$((A&and;C)&rarr;B)$' 則必須為假。
					</p>
					<p>
					然而 '$A&rarr;B$' 和 '$&not;((A&and;C)&rarr;B)$' 都還不是原子語句或原子語句的否定句，因此我們還得繼續分析下去：
					</p>
					<div class="tree">
						<span>$&not;((A&rarr;B)&rarr;((A&and;C)&rarr;B))$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;((A&and;C)&rarr;B)$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$A&and;C$</span><br/>
						<span>$&not;B$</span>
					</div>
					<p>
					在新的步驟中，我選擇先分析 '$&not;((A&and;C)&rarr;B)$' 這個條件，所以我先把 '$A&rarr;B$' 這個條件原封不動地移下來擺在第一行。然後將 '$&not;((A&and;C)&rarr;B)$' 可以成立的條件寫在第二和第三行。這兩行的意思是：為了讓 '$&not;((A&and;C)&rarr;B)$' 成立，'$A&and;C$' 必須為真，而 '$B$' 必須為假。
					</p>
					<p>
					到此，'$&not;B$' 已經是原子語句的否定句了，因此不必再分析，剩下來必須分析的條件還剩下 '$A&rarr;B$' 和 '$A&and;C$' 兩個。我們還是先不要處理 '$A&rarr;B$' 這個條件，先來分析 '$A&and;C$' 這個條件：
					</p>
					<div class="tree">
						<span>$&not;((A&rarr;B)&rarr;((A&and;C)&rarr;B))$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;((A&and;C)&rarr;B)$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$A&and;C$</span><br/>
						<span>$&not;B$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;B$</span><br/>
						<span>$A$</span><br/>
						<span>$C$</span>
					</div>
					<p>
					因此我再拉一條直線下來，並且把暫時不打算處理的 '$A&rarr;B$'，以及已經處理完畢的 '$&not;B$' 都先寫下來。而接下來的 '$A$' 和 '$C$' 這兩行則是表示：為了讓 '$A&and;C$' 這個條件成立，則 '$A$' 必須為真，而 '$C$' 也必須為真。
					</p>
					<p>
					由於 '$A$' 和 '$C$' 都是原子語句了，故不需要再分析，因此我們最後剩下來還未分析的條件，就只剩下 '$A&rarr;B$' 了。而之所以把它留到現在才處理，是因為它會產生分支：要讓 '$A&rarr;B$' 這個條件成立一共有兩個方法，其中一個方法是讓 '$A$' 為假，另一個方法則是讓 '$B$' 為真。
					</p>
					<p>
					由於一共有兩種方法可以讓 '$A&rarr;B$' 成立，所以我們就畫兩條件下來，分成兩種情況來考慮。在這兩種情況下，我們都先把之前分析完畢的其它條件都先搬下來（也就是 '$&not;B$'、'$A$'、'$C$' 這三個條件），因為這些條件是兩條支線所共享的條件。最後我們再把剛剛分析的兩個不同的條件分別寫在這兩個支線下方。意思是：在左邊這條支線下，我們藉由讓 '$A$' 為假來讓 '$A&rarr;B$' 成立；在右邊這條支線下，我們則是藉由讓 '$B$' 為真來讓 '$A&rarr;B$' 成立。
					</p>
					<div class="tree">
						<span>$&not;((A&rarr;B)&rarr;((A&and;C)&rarr;B))$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;((A&and;C)&rarr;B)$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$A&and;C$</span><br/>
						<span>$&not;B$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;B$</span><br/>
						<span>$A$</span><br/>
						<span>$C$</span>
						<svg>
							<path d="M300 1 L150 23" />
							<path d="M300 1 L450 23" />
						</svg>
						<div>
							<span>$&not;B$</span><br/>
							<span>$A$</span><br/>
							<span>$C$</span><br/>
							<span>$&not;A$</span><br/>
						</div>
						<div>
							<span>$&not;B$</span><br/>
							<span>$A$</span><br/>
							<span>$C$</span><br/>
							<span>$B$</span><br/>
						</div>
					</div>
					<p>
					到此，我們已經把所有為了讓歸謬假設可以成立而必須滿足的條件到分析成原子語句或原子語句的否定句了，這個樹狀圖最後的兩個分支所代表的意義是：為了讓一開始的歸謬假設可以成立，有兩種方法可以達成，第一種方法是讓 '$B$' 為假、讓 '$A$' 為真、讓 '$C$' 為真、讓 '$A$' 為假；第二種方法則是讓 '$B$' 為假、讓 '$A$' 為真、讓 '$C$' 為真、讓 '$B$' 為真。
					</p>
					<p>
					第一種方法會產生矛盾，因為我們不可能讓 '$A$' 既真又假；第二種方法也會產生矛盾，因為我們不可能讓 '$B$' 既真又假，因此我們將這兩組彼此矛盾的語句圈出來，並在產生矛盾的分支底下都畫個 '&cross;' 的記號，表示這些分支都會產生矛盾：
					</p>
					<div class="tree">
						<span>$&not;((A&rarr;B)&rarr;((A&and;C)&rarr;B))$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;((A&and;C)&rarr;B)$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$A&and;C$</span><br/>
						<span>$&not;B$</span>
						<svg>
							<path d="M300 0 L300 24" />
						</svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;B$</span><br/>
						<span>$A$</span><br/>
						<span>$C$</span>
						<svg>
							<path d="M300 1 L150 23" />
							<path d="M300 1 L450 23" />
						</svg>
						<div>
							<span>$&not;B$</span><br/>
							<svg class="back">
								<circle cx="150" cy="12" r="11" />
							</svg>
							<span>$A$</span><br/>
							<span>$C$</span><br/>
							<svg class="back">
								<ellipse cx="150" cy="12" rx="20" ry="11" />
							</svg>
							<span>$&not;A$</span><br/>
							<span>&cross;</span>
						</div>
						<div>
							<svg class="back">
								<ellipse cx="150" cy="12" rx="20" ry="11" />
							</svg>
							<span>$&not;B$</span><br/>
							<span>$A$</span><br/>
							<span>$C$</span><br/>
							<svg class="back">
								<circle cx="150" cy="12" r="11" />
							</svg>
							<span>$B$</span><br/>
							<span>&cross;</span><br/>
						</div>
					</div>
					<p>
					由於分支只有兩條，這意味著總共只有兩個方法可以讓一開始的歸謬假設成立。既然這兩種方法都會產生矛盾，這表示我們其實沒有任何方法可以讓歸謬假設成立，也就是說，我們不可能讓 '$(A&rarr;B)&rarr;((A&and;C)&rarr;B)$' 為假。既然它不可能為假，這就表示它是一恆真句。
					</p>
					<p>
					我再示範幾個例子，比如說，試證明 '$(A&rarr;(B&and;C))&and;(A&and;&not;C)$' 是一個矛盾句。我們一樣是用歸謬法和樹枝法來證明這件事，既然是用歸謬法，一開始就需要做歸謬假設，又因為我們要證明該語句<b>是</b>矛盾句，因此歸謬假設就必須假設它為真。若在假設它為真的情況下，所有分支都會推論出矛盾，那就證明它是矛盾句；反之，只要有一個分支不會出現矛盾，則證明它不是矛盾句：
					</p>
					<div class="tree">
						<span>$(A&rarr;(B&and;C))&and;(A&and;&not;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A&and;&not;C$</span>
					</div>
					<p class="noind">
					在這兩個步驟中，我首先做了歸謬假設，假設 '$(A&rarr;(B&and;C))&and;(A&and;&not;C)$' 為真，並推論說，為了讓它為真，則 '$A&rarr;(B&and;C)$' 和  '$A&and;&not;C$' 都必須為真。由於這兩個語句都還不是原子語句或原子語句的否定句，因此還需要接著分析：
					</p>
					<div class="tree">
						<span>$(A&rarr;(B&and;C))&and;(A&and;&not;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A&and;&not;C$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A$</span><br/>
						<span>$&not;C$</span>
					</div>
					<p class="noind">
					在這一新的步驟中，我先分析 '$A&and;&not;C$' 為真的條件，因此把 '$A&rarr;(B&and;C)$' 原封不動的移下來。然後，為了讓 '$A&and;&not;C$' 為真，'$A$' 必須為真，而 '$C$' 必須為假，因此我記下 '$A$'（代表 '$A$' 為真）和 '$&not;C$'（代表 '$C$' 為假）。由於 '$A$' 和 '$&not;C$' 都已經是原子語句或原子語句的否定了，因此接下來就要分析剩下的 '$A&rarr;(B&and;C)$'。
					</p>
					<p>
					然而，因為有兩個不同的方法可以讓 '$A&rarr;(B&and;C)$' 為真，所以兩個方法必須分別考慮，因此在這裡必須產生分支。我們一樣先把已經分析完畢的 '$A$' 和 '$&not;C$' 都搬到兩條分支底下，然後再分別考慮能讓 '$A&rarr;(B&and;C)$' 為真的兩個條件：
					</p>
					<div class="tree">
						<span>$(A&rarr;(B&and;C))&and;(A&and;&not;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A&and;&not;C$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A$</span><br/>
						<span>$&not;C$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<span>$&not;A$</span>
						</div>
						<div>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<span>$B&and;C$</span><br/>
						</div>
					</div>
					<p class="noind">
					左邊這條分支已經產生矛盾了，因為 '$A$' 不能既真又假，因此我們將 '$A$' 和 '$&not;A$' 分別圈起來，並在這條分支底下畫上 '&cross;' 的記號。這意味著，如果我們藉由讓 '$A$' 為假來讓 '$A&rarr;(B&and;C)$' 為真，會產生矛盾，因此左邊這個方法行不通。既然左邊這條路不可行，而右邊的分支還有 '$B&and;C$' 尚未被分析至原子語句或原子語句之否定的層次，故需要繼續分析下去：
					</p>
					<div class="tree">
						<span>$(A&rarr;(B&and;C))&and;(A&and;&not;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A&and;&not;C$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A$</span><br/>
						<span>$&not;C$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<svg class="back">
								<circle cx="150" cy="12" r="11" />
							</svg>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<svg class="back">
								<ellipse cx="150" cy="12" rx="20" ry="11" />
							</svg>
							<span>$&not;A$</span><br/>
							<span>&cross;</span>
						</div>
						<div>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<span>$B&and;C$</span>
							<svg><path d="M150 0 L150 24" />
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<span>$B$</span><br/>
							<span>$C$</span><br/>
						</div>
					</div>
					<p class="noind">
					繼續分析下去後發現，若要藉由讓 '$B&and;C$' 為真的方式來讓 '$A&rarr;(B&and;C)$' 為真，那麼 '$B$' 和 '$C$' 都必須為真。然而根據前面的分析，為了讓 '$A&and;&not;C$' 為真，我們必須讓 '$C$' 為假，因此產生矛盾，因為 '$C$' 不能既真又假，故右邊這條路也行不通。所以我們一樣把彼此矛盾的 '$&not;C$' 和 '$C$' 都圈起來，並在右邊這條分支下面也畫上一個 '&cross;' 的記號：
					</p>
					<div class="tree">
						<span>$(A&rarr;(B&and;C))&and;(A&and;&not;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A&and;&not;C$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;(B&and;C)$</span><br/>
						<span>$A$</span><br/>
						<span>$&not;C$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<svg class="back">
								<circle cx="150" cy="12" r="11" />
							</svg>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<svg class="back">
								<ellipse cx="150" cy="12" rx="20" ry="11" />
							</svg>
							<span>$&not;A$</span><br/>
							<span>&cross;</span>
						</div>
						<div>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<span>$B&and;C$</span>
							<svg><path d="M150 0 L150 24" /></svg>
							<span>$A$</span><br/>
							<svg class="back">
								<ellipse cx="150" cy="12" rx="20" ry="11" />
							</svg>
							<span>$&not;C$</span><br/>
							<span>$B$</span><br/>
							<svg class="back">
								<circle cx="150" cy="12" r="11" />
							</svg>
							<span>$C$</span><br/>
							<span>&cross;</span><br/>
						</div>
					</div>
					<p>
					由於兩條路都會產生矛盾，因此都行不通，這就意味著一開始的歸謬假設不可能成立，也就是說，'$(A&rarr;(B&and;C))&and;(A&and;&not;C)$' 不可能為真，既然不可能為真，故可證明它是一矛盾句。
					</p>
					<p>
					最後讓我示範最後一個例子，試判斷 '$(A&or;B)&rarr;(A&and;B)$' 是不是一個矛盾句。一樣是使用歸謬法和樹枝法來判斷，而且我這次不再逐步驟說明我做的事，我會直接把判斷的過程和結果一起畫出來：
					</p>
					<div class="tree">
						<span>$(A&or;B)&rarr;(A&and;B)$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<span>$&not;(A&or;B)$</span>
							<svg><path d="M150 0 L150 24" /></svg>
							<span>$&not;A$</span><br/>
							<span>$&not;B$</span><br/>
							<span>&check;</span><br/>
						</div>
						<div>
							<span>$A&and;B$</span>
							<svg><path d="M150 0 L150 24" /></svg>
							<span>$A$</span><br/>
							<span>$B$</span><br/>
							<span>&check;</span><br/>
						</div>
					</div>
					<p>
					由於現在是要判斷一個語句是不是矛盾句，因此在做歸謬假設時，我們要假設該語句為真。一路分析下來之後發現一共會有兩個分支，而在這兩個分支之下，都不會產生任何矛盾，因此我們在不會產生矛盾的分支底下都畫上一個 '&check;' 記號，以表示這些分支是可以讓歸謬假設成立的情況。
					</p>
					<p>既然有不矛盾的方法可以讓歸謬假設成立，就表示 '$(A&or;B)&rarr;(A&and;B)$' 有可能為真，故可證明它不是一個矛盾句。而在上一個小節中，我們其實已經用歸謬法證明過 '$(A&or;B)&rarr;(A&and;B)$' 不是一個恆真句了，我們可以用樹枝法再把那個證明做一遍：
					</p>
					<div class="tree">
						<span>$&not;((A&or;B)&rarr;(A&and;B))$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&or;B$</span><br/>
						<span>$&not;(A&and;B)$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<span>$A$</span><br/>
							<span>$&not;(A&and;B)$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<svg class="back">
									<circle cx="75" cy="12" r="11" />
								</svg>
								<span>$A$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11" />
								</svg>
								<span>$&not;A$</span><br/>
								<span>&cross;</span>
							</div>
							<div>
								<span>$A$</span><br/>
								<span>$&not;B$</span><br/>
								<span>&check;</span>
							</div>
						</div>
						<div>
							<span>$B$</span><br/>
							<span>$&not;(A&and;B)$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<span>$B$</span><br/>
								<span>$&not;A$</span><br/>
								<span>&check;</span>
							</div>
							<div>
								<svg class="back">
									<circle cx="75" cy="12" r="11" />
								</svg>
								<span>$B$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11" />
								</svg>
								<span>$&not;B$</span><br/>
								<span>&cross;</span><br/>
							</div>
						</div>
					</div>
					<p class="noind">
					在這個證明中，因為是要判斷 '$(A&or;B)&rarr;(A&and;B)$' 是不是恆真句，所以一開始的歸謬假設便假設該語句為假。經過一連串的分析後發現一共有四條分支，表示有四種不同的方法可以讓歸謬假設成立。由於其中有兩條分支是矛盾的，所以我們這些分支底下畫上 '&cross;' 以表示這些分支行不通；但有兩條分支沒有任何矛盾，所以我們在其下畫上 '&check;'。既然有兩條分支沒有矛盾，表示至少有兩種不矛盾的方法可以讓歸謬假設成立，因此 '$(A&or;B)&rarr;(A&and;B)$' 可能為假，故可證明它不是一個恆真句。
					</p>
					<p>
					既然我們可以證明 '$(A&or;B)&rarr;(A&and;B)$' 既不是恆真句也不是矛盾句，就表示它是一個偶然語句。也就是說，只要給定這套歸謬證明的方法，我們不僅能判斷一個語句是不是恆真句或矛盾句，也可以判斷一個語句是不是偶然語句：<b>只要一個語句可被證明為恆真句或矛盾句，該語句就不是偶然語句；相反，只要一個語句可被證明既不是恆真句也不是矛盾句，該語句就是偶然語句。</b>
					</p>
				</div>
				
				<div class="subsection" id="logical-relations-and-validity">
					<h3>判斷邏輯關係和有效論證</h3>
					<p>
					在介紹了如何用歸謬方法與真值函數來判斷一個語句的邏輯特性（也就是區辨一個語句是恆真句、矛盾句還是偶然語句）之後，我要來說明這個技巧可以怎麼被應用。
					</p>
					<p>
					我在上一節中介紹語句之間的邏輯關係時有提到，要判斷任意兩個語句 '$&alpha;$' 和 '$&beta;$' 之間是否具有某種邏輯關係時，我們可以用某些語句連接詞來連接 '$&alpha;$' 和 '$&beta;$'，然後判斷形成的語句是不是恆真句或矛盾句，藉此判斷 '$&alpha;$' 和 '$&beta;$' 之間有沒有什麼邏輯關係。在此我將把各種邏輯關係的判斷方法整理成一個清單如下：
					</p>
					<ol class="numd tight local">
						<li>'$&alpha;$' 邏輯蘊涵 '$&beta;$'，當且僅當，'$&alpha;&rarr;&beta;$' <b>是恆真句</b>。</li>
						<li>'$&alpha;$' 和 '$&beta;$' 等值，當且僅當，'$&alpha;&harr;&beta;$' <b>是恆真句</b>。</li>
						<li>'$&alpha;$' 和 '$&beta;$' 相容，當且僅當，'$&alpha;&and;&beta;$' <b>不是矛盾句</b>。</li>
						<li>'$&alpha;$' 和 '$&beta;$' 相容，當且僅當，'$&alpha;&and;&beta;$' <b>是矛盾句</b>。</li>
						<li>'$&alpha;$' 和 '$&beta;$'  矛盾，當且僅當，'$&alpha;&harr;&beta;$' <b>是矛盾句</b>。</li>
					</ol>
					<p>
					根據以上五條規則，當我們要判斷兩個語句 '$&alpha;$' 和 '$&beta;$' 之間是否具有某種邏輯關係時，只要把它們寫成某個特定的句型，然後再用歸謬法判斷該語句是不是恆真句或矛盾句，就能知道這兩個語句之間有沒有某種邏輯關係。
					</p>
					<p>
					因此，比如說，當我要判斷 '$(&not;A&or;B)$' 和 '$A&rarr;B$' 之間是否邏輯等值時，我可以把這兩個語句寫成 '$(&not;A&or;B)&harr;(A&rarr;B)$' 這樣的雙條件句，然後判斷它是不是一個恆真句。只要它是恆真句，這兩個語句便等值；不是則否。我們立刻來證明：
					</p>
					<div class="tree">
						<span>$&not;((&not;A&or;B)&harr;(A&rarr;B))$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<span>$&not;A&or;B$</span><br/>
							<span>$&not;(A&rarr;B)$</span>
							<svg><path d="M150 0 L150 24" /></svg>
							<span>$&not;A&or;B$</span><br/>
							<span>$A$</span><br/>
							<span>$&not;B$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<svg class="back">
									<circle cx="75" cy="12" r="11" />
								</svg>
								<span>$A$</span><br/>
								<span>$&not;B$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11" />
								</svg>
								<span>$&not;A$</span><br/>
								<span>&cross;</span>
							</div>
							<div>
								<span>$A$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11" />
								</svg>
								<span>$&not;B$</span><br/>
								<svg class="back">
									<circle cx="75" cy="12" r="11" />
								</svg>
								<span>$B$</span><br/>
								<span>&cross;</span>
							</div>
						</div>
						<div>
							<span>$&not;(&not;A&or;B)$</span><br/>
							<span>$A&rarr;B$</span>
							<svg><path d="M150 0 L150 24" /></svg>
							<span>$A&rarr;B$</span><br/>
							<span>$A$</span><br/>
							<span>$&not;B$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<svg class="back">
									<circle cx="75" cy="12" r="11" />
								</svg>
								<span>$A$</span><br/>
								<span>$&not;B$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11" />
								</svg>
								<span>$&not;A$</span><br/>
								<span>&cross;</span>
							</div>
							<div>
								<span>$A$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11" />
								</svg>
								<span>$&not;B$</span><br/>
								<svg class="back">
									<circle cx="75" cy="12" r="11" />
								</svg>
								<span>$B$</span><br/>
								<span>&cross;</span><br/>
							</div>
						</div>
					</div>
					<p>
					從以上證明可以看出來，在假設 '$(&not;A&or;B)&harr;(A&rarr;B)$' 為假後，分析出來的所有分支都有矛盾，表示 '$(&not;A&or;B)&harr;(A&rarr;B)$' 不可能為假，因此是恆真句，因此可以證明 '$&not;A&or;B$' 和 '$A&rarr;B$' 是邏輯等值的。
					</p>
					<p>
					又或者，如果我要判斷 '$A&rarr;B$' 是否邏輯蘊涵 '$A&and;(B&or;C)$'，我可以用 '$&rarr;$' 連接這兩個語句，得到 '$(A&rarr;B)&rarr;(A&and;(B&or;C))$'，然後再檢查它是不是恆真句：
					</p>
					<div class="tree">
						<span>$&not;((A&rarr;B)&rarr;(A&and;(B&or;C)))$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;B$</span><br/>
						<span>$&not;(A&and;(B&or;C))$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<span>$&not;A$</span><br/>
							<span>$&not;(A&and;(B&or;C))$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<span>$&not;A$</span><br/>
								<span>$&not;A$</span><br/>
								<span>&check;</span>
							</div>
							<div>
								<span>$&not;A$</span><br/>
								<span>$&not;(B&or;C)$</span>
								<svg><path d="M75 0 L75 24" /></svg>
								<span>$&not;A$</span><br/>
								<span>$&not;B$</span><br/>
								<span>$&not;C$</span><br/>
								<span>&check;</span>
							</div>
						</div>
						<div>
							<span>$B$</span><br/>
							<span>$&not;(A&and;(B&or;C))$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<span>$B$</span><br/>
								<span>$&not;A$</span><br/>
								<span>&check;</span>
							</div>
							<div>
								<span>$B$</span><br/>
								<span>$&not;(B&or;C)$</span>
								<svg><path d="M75 0 L75 24" /></svg>
								<svg class="back" height="24px">
									<circle cx="75" cy="12" r="11" />
								</svg>
								<span>$B$</span><br/>
								<svg class="back" height="24px">
									<ellipse cx="75" cy="12" rx="20" ry="11" />
								</svg>
								<span>$&not;B$</span><br/>
								<span>$&not;C$</span><br/>
								<span>&cross;</span><br/>
							</div>
						</div>
					</div>
					<p>
					根據以上分析，要令 '$(A&rarr;B)&rarr;(A&and;(B&or;C))$' 為假一共有四種不同的方法，因此有四個分支，而這四個分支中只有最後一個是有矛盾的，其它三個分支都沒有。這表示確實存在不矛盾的方法可以讓 '$(A&rarr;B)&rarr;(A&and;(B&or;C))$' 為假，因此它不是恆真句。故可證明 '$A&rarr;B$' 沒有邏輯蘊涵 '$A&and;(B&or;C)$'。
					</p>
					<p>
					我在最開始向大家介紹有效論證時，我說有效論證的定義是：<b>只要一個論證的前提全部為真，則結論就會是真的</b>。如今，我們有了許多邏輯概念可以使用，我們就能用更準確的方式來定義一個有效論證：<b>一個論證是一個有效的，當且僅當，在所有讓論證的前提全部為真的語意模型中，論證的結論都會真</b>。
					</p>
					<p>
					我們可以更精簡地界定出有效論證的定義：<b>一個論證是有效的，當且僅當，論證的所有前提共同邏輯蘊涵論證的結論</b>。這裡所謂的「共同蘊涵」，指的是這些前提要全部加在一起才會邏輯蘊涵結論，而不是指這些前提各自都會邏輯蘊涵結論。
					</p>
					<p>
					舉例來說，如果有一個有效論證使用了三個前提，分別是：(P1) $&alpha;$；(P2) $&beta;$ 和 (P3) $&gamma;$，而論證的結論則是 (C) $&delta;$。因為由 (P1)、(P2)、(P3) 三個前提推論出結論 (C) 的論證是一個有效論證，因此 '$&alpha;$'、'$&beta;$'、'$&gamma;$' 這三個前提會<b>共同邏輯蘊涵</b>結論，也就是 '$&delta;$'。意思是：'$&alpha;&and;(&beta;&and;&gamma;)$' 會邏輯蘊涵 '$&delta;$'。但 '$&alpha;$'、'$&beta;$'、'$&gamma;$' 這三個語句仍可能分別都沒有邏輯蘊涵 '$&delta;$'。
					</p>
					<p>
					既然有效論證可以用<b>前提邏輯蘊涵結論</b>來理解，要判斷一個論證是否有效，自然就可以用判斷蘊涵關係的方式來判斷。我們試著判斷以下論證是不是一個有效論證：
					</p>
					<ol class="prf">
						<li>如果科科年紀比安安大，則安安年紀比蔞雷大。</li>
						<li>如果科科年紀比安安大，而且安安年紀比蔞雷大，則科科年紀比蔞雷大。</li>
						<li>如果科科年紀比安安大，則科科年紀比蔞雷大。</li>
					</ol>
					<p>
					為了判斷這個論證是不是一個有效論證，我們需要設法將它的前提和結論都翻譯至語句邏輯的語言中，我們可以試著這樣翻譯：
					</p>
					<ul class="tight">
						<li>令語句符號 '$A$' 代表：科科年紀比安安大。</li>
						<li>令語句符號 '$B$' 代表：安安年紀比蔞雷大。</li>
						<li>令語句符號 '$C$' 代表：科科年紀比蔞雷大。</li>
					</ul>
					<p>
					如此指定之後，我們就可以把上面的論證翻譯如下：
					</p>
					<ol class="prfp">
						<li>$A&rarr;B$</li>
						<li>$(A&and;B)&rarr;C$</li>
						<li>$A&rarr;C$</li>
					</ol>
					<p>
					要檢查上述論證是不是一個有效論證，就是要檢查這個論證的前提是否共同邏輯蘊涵結論，也就是要判斷 '$(A&rarr;B)&and;((A&and;B)&rarr;C)$' 是否會邏輯蘊涵 '$A&rarr;C$'。因此，我們只要檢查 '$((A&rarr;B)&and;((A&and;B)&rarr;C))&rarr;(A&rarr;C)$' 是不是一個恆真句即可，若它是恆真句，就代論證有效，若它不是恆真句，則代表論證無效：
					</p>
					<div class="tree">
						<span>$&not;(((A&rarr;B)&and;((A&and;B)&rarr;C))&rarr;(A&rarr;C))$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$(A&rarr;B)&and;((A&and;B)&rarr;C)$</span><br/>
						<span>$&not;(A&rarr;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;B$</span><br/>
						<span>$(A&and;B)&rarr;C$</span><br/>
						<span>$&not;(A&rarr;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;B$</span><br/>
						<span>$(A&and;B)&rarr;C$</span><br/>
						<span>$A$</span><br/>
						<span>$&not;C$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<span>$A&rarr;B$</span><br/>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<span>$&not;(A&and;B)$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<span>$A&rarr;B$</span><br/>
								<svg class="back">
									<circle cx="75" cy="12" r="11"/>
								</svg>
								<span>$A$</span><br/>
								<span>$&not;C$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11"/>
								</svg>
								<span>$&not;A$</span><br/>
								<span>&cross;</span>
							</div>
							<div>
								<span>$A&rarr;B$</span><br/>
								<span>$A$</span><br/>
								<span>$&not;C$</span><br/>
								<span>$&not;B$</span>
								<svg><path d="M75 1 L37.5 23"/><path d="M75 1 L112.5 23"/></svg>
								<div>
									<svg class="back">
										<circle cx="37.5" cy="12" r="11"/>
									</svg>
									<span>$A$</span><br/>
									<span>$&not;C$</span><br/>
									<span>$&not;B$</span><br/>
									<svg class="back">
										<ellipse cx="37.5" cy="12" rx="20" ry="11"/>
									</svg>
									<span>$&not;A$</span><br/>
									<span>&cross;</span>
								</div>
								<div>
									<span>$A$</span><br/>
									<span>$&not;C$</span><br/>
									<svg class="back">
										<ellipse cx="37.5" cy="12" rx="20" ry="11"/>
									</svg>
									<span>$&not;B$</span><br/>
									<svg class="back">
										<circle cx="37.5" cy="12" r="11"/>
									</svg>
									<span>$B$</span><br/>
									<span>&cross;</span><br/>
								</div>
							</div>
						</div>
						<div>
							<span>$A&rarr;B$</span><br/>
							<span>$A$</span><br/>
									<svg class="back">
										<ellipse cx="150" cy="12" rx="20" ry="11"/>
									</svg>
							<span>$&not;C$</span><br/>
									<svg class="back">
										<circle cx="150" cy="12" r="11"/>
									</svg>
							<span>$C$</span><br/>
							<span>&cross;</span>
						</div>
					</div>
					<p>
					以上的樹枝圖當中，第一件要注意的事情是前三個步驟的意義。第一個步驟是歸謬假設，也就是假設「以論證前提共同構成的連言句作為前件，並以論證之結論作為後件的條件句」為假。
					</p>
					<p>
					由於歸謬假設是假設「以論證前提共同構成的連言句作為前件，並以論證之結論作為後件的條件句」為假，因此在第二步驟中第一次分析歸謬假設成立的條件時，就一定是把論證前提所共同構成的連言句，以及論證結論之否定句寫在一起。這表示：為了讓歸謬假設成立，就必須讓論證之前提所共同構成的連言句為真，並且讓論證之結論為假。
					</p>
					<p>
					既然由論證之前提所共同構成的連言句必須為真，這表示每一個論證的前提都必須要為真。因此第三步驟就會把論證的所有前提列在一起，並同時列上結論的否定句（因為結論必須為假）。
					</p>
					<p>
					無論我們要分析的論證長什麼樣子，用了多少前提，前三個步驟一定都是按照上述所說的順序進行的。也就是說，無論我們要分析的是哪一個論證，只要我們是要判斷一個論證的有效與否，我們都一定會經歷這三個步驟。因此，我們其實可以省略前兩個步驟，直接從第三個步驟開始。
					</p>
					<p>
					也就是說，在用樹枝法分析一個論證是否有效時，我們可以在第一步就把論證的所有前提，加上結論的否定句一併寫上去，並以此作為分析的起點。比如說，以上的樹狀圖其實可以被簡化成：
					</p>
					<div class="tree">
						<span>$A&rarr;B$</span><br/>
						<span>$(A&and;B)&rarr;C$</span><br/>
						<span>$&not;(A&rarr;C)$</span>
						<svg><path d="M300 0 L300 24" /></svg>
						<span>$A&rarr;B$</span><br/>
						<span>$(A&and;B)&rarr;C$</span><br/>
						<span>$A$</span><br/>
						<span>$&not;C$</span>
						<svg><path d="M300 1 L150 23" /><path d="M300 1 L450 23" /></svg>
						<div>
							<span>$A&rarr;B$</span><br/>
							<span>$A$</span><br/>
							<span>$&not;C$</span><br/>
							<span>$&not;(A&and;B)$</span>
							<svg><path d="M150 1 L75 23" /><path d="M150 1 L225 23" /></svg>
							<div>
								<span>$A&rarr;B$</span><br/>
								<svg class="back">
									<circle cx="75" cy="12" r="11"/>
								</svg>
								<span>$A$</span><br/>
								<span>$&not;C$</span><br/>
								<svg class="back">
									<ellipse cx="75" cy="12" rx="20" ry="11"/>
								</svg>
								<span>$&not;A$</span><br/>
								<span>&cross;</span>
							</div>
							<div>
								<span>$A&rarr;B$</span><br/>
								<span>$A$</span><br/>
								<span>$&not;C$</span><br/>
								<span>$&not;B$</span>
								<svg><path d="M75 1 L37.5 23"/><path d="M75 1 L112.5 23"/></svg>
								<div>
									<svg class="back">
										<circle cx="37.5" cy="12" r="11"/>
									</svg>
									<span>$A$</span><br/>
									<span>$&not;C$</span><br/>
									<span>$&not;B$</span><br/>
									<svg class="back">
										<ellipse cx="37.5" cy="12" rx="20" ry="11"/>
									</svg>
									<span>$&not;A$</span><br/>
									<span>&cross;</span>
								</div>
								<div>
									<span>$A$</span><br/>
									<span>$&not;C$</span><br/>
									<svg class="back">
										<ellipse cx="37.5" cy="12" rx="20" ry="11"/>
									</svg>
									<span>$&not;B$</span><br/>
									<svg class="back">
										<circle cx="37.5" cy="12" r="11"/>
									</svg>
									<span>$B$</span><br/>
									<span>&cross;</span><br/>
								</div>
							</div>
						</div>
						<div>
							<span>$A&rarr;B$</span><br/>
							<span>$A$</span><br/>
									<svg class="back">
										<ellipse cx="150" cy="12" rx="20" ry="11"/>
									</svg>
							<span>$&not;C$</span><br/>
									<svg class="back">
										<circle cx="150" cy="12" r="11"/>
									</svg>
							<span>$C$</span><br/>
							<span>&cross;</span>
						</div>
					</div>
					<p>
					如此簡化看起來雖然只省略了兩個步驟，但其實有其道理在。原本的分析是先將一個論證寫成一個條件句，然後再透過檢查條件句是否為恆真句，來判斷論證的前提是否共同蘊涵結論，藉此判斷論證是否有效。
					</p>
					<p>
					然而直接根據有效論證的定義，也就是<b>當論證的前提全部為真時，論證的結論也會為真</b>，我們其實也可以做出歸謬的假設，即假設：<b>當論證的前提全部為真時，結論仍可能為假</b>。而這個歸謬假設，其實就是把所有論證的前提都列出來，然後再加上結論的否定句。因此，要判斷任何論證是否有效，我們其實都可以用論證的前提與結論的否定來當作歸謬假設。
					</p>
				</div>
			</div>
		</div>
	</div>
</body>
