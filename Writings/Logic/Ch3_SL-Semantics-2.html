<!DOCTYPE html>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xml:lang="en-US" lang="en-US">

<head>
	<meta charset="utf-8"/>

	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/Computer-Modern/serif/cmun-serif.css"/><!--CMU Serif-->
	<link rel='stylesheet' href="https://isaacstn.github.io/fonts/STIXGeneral/STIXGeneral.css"/><!--STIXGeneral-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/FelipaFraktur/FelipaFraktur.css"/><!--Felipa,Unifraktur-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/NotoSerifTC/NotoSerifTC.css"/><!--Noto Serif TC-->
	<link rel="stylesheet" href="https://isaacstn.github.io/fonts/AdobeTC/AdobeTC.css"/><!--Adobe TC-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/Style/docstyle_v1.2.css"/><!--docstyle-->
	<link rel="stylesheet" href="https://isaacstn.github.io/CSS/jqmath-0.4.3.css"/><!--jqmath-->

	<style>
	h1::before {
		counter-increment:chapter 3;
	}
	div#main {
		counter-reset:page 49;
	}
	</style>

	<title>Ch3_SL-Semantics-2</title>
</head>

<body>
	<div id="main">
		<h1>語句邏輯的語意（二）</h1>
		
		<div class="chapter">
			
			<h2>真值函數</h2>
			
			<div class="section">
				<p>
				前一章關於真值表和語意模型的討論，其實都是建立在相同的基礎之上：語句邏輯中的每一個語句都是由一個語句連接詞作為主要連接詞，並連接相應數量的語句來形成的；而要判斷每一個語句的真假，一定都是用該語句之主要連接詞所連接的語句之真假來判斷。因此，每一個語句邏輯中的語句都是一個<b>真值函數 (truth function)</b>。
				</p>
				<p>
				為了說明真值函數是什麼，以及說明真值函數與真值表和語意模型之間的關係，我必須先簡單地介紹一下<b>函數 (function)</b> 這個概念。不過因為函數是一個<b>集合論 (set theory)</b> 的概念，它是用來描述兩個集合的成員之間的特殊對應關係，所以為了說明函數的概念，我也必須先介紹一些基礎的集合論觀念。
				</p>
				
				<h3>集合</h3>
				
				<div class="subsection">
					<p>
					什麼是<b>集合 (set)</b>？簡單地說，只要我們任意地蒐集一堆東西，就可以形成一個集合。我們通常用 '$\{\}$' 來表示一個集合，並將所有被蒐集進某一個集合內的東西寫在 '$\{\}$' 之中，然後用 '$,$' 將個別的東西分隔開來。比如說，$\{1,2,3,4,5\}$就是一個蒐集了 1-5 這五個阿拉伯數字的集合，而 $\{(A&rarr;B), (C&and;(D&or;B)), (&not;B), (A)\}$ 則是一個蒐集了 '$A&rarr;B$'、'$C&and;(D&or;B)$'、'$&not;B$'、'$A$' 這四個語句的集合。
					</p>
					<p>
					集合能夠蒐集的東西沒有任何限制，無論是抽象的或具體的事物，都可以被蒐集到某個集合之中，集合之中甚至可以蒐集其它的集合。因為集合可以聚集任意數量的任何東西，所以當我們要談論一堆東西的時候，集合就是一個很方便的概念工具。比如說，當我們要談所有自然數（所有 $&ge;0$ 的整數）的時候，因為自然數有無限多個，我們不可能一一指出來談，但有了集合之後，我們就可以直接談論自然數的集合。
					</p>
					<p>
					既然集合是在蒐集了任意一堆東西後所形成的，我們就說那些被一個集合蒐集起來的東西是那個集合的<b>成員 (member)</b>。比如說，'$1$'、'$2$'、'$3$'、'$4$'、'$5$' 都是 $\{1,2,3,4,5\}$ 這個集合的成員。讓我們用大寫的希臘字母（如 '$\&Gamma;$'、'$\&Delta;$'、'$\&Theta;$' 等）來表示一個集合（必要時可加上數字下標），並且令 $\{1,2,3,4,5\}=\&Gamma;$，我們就可以用 '$1&isin;\&Gamma;$' 來表示 $1$ 是 $\&Gamma;$ 這個集合的成員，我們將它讀作「$1$ 屬於 $\&Gamma;$」。
					</p>
					
					<h5>集合的寫法</h5>
					<div class="portion">
						<p>
						前面介紹過一個集合的寫法，就是用左右大括號 '{'、'}' 來包住所有的集合成員，這是所有集合最基本的寫法。這種寫法用來應付成員不多的集合不會有什麼問題，可是如果一個集合的成員很多的話，這種寫法就太浪費時間和空間。為了節省成本，對某些成員很多，但卻可以找到某種規律的集合，我們就用定義的方式來寫它。
						</p>
						<p>
						比如說，如果我們要寫一個蒐集了 $1$ 和 $100$（包括 $1$ 和 $100$）之間所有正整數的集合，照基本的寫法，我們就必須把這一百個數字全部寫下來。為了節省時間和空間，我們可以用定義的方式把這個集合寫成：$\{x|x&isin;&#x2115;,1&le;x&le;100\}$。這種寫法的意思是：這個集合蒐集了所有滿足 '$|$' 這個符號右邊所列條件的 '$x$'。也就是說，這個集合蒐集了所有「屬於自然數」，而且「大於等於 $1$ 並且小於等於 $100$」的 '$x$'。
						</p>
						<p>
						這樣一來，我們不必把那一百個數字全部都列出來，也能把蒐集了所有介於 1 和 100（包括 1 和 100）之間的自然數的集合寫出來。
						</p>
					</div>
					
					<h5>集合的同一性</h5>
					<div class="portion">
						<p>
						每個集合都是由它所包含的成員來決定的，只要擁有相同的成員，就會是同一個集合，無論成員的排列順序如何，也就是說，$\{1,2,3,4,5\}$ 和 $\{5,4,3,2,1\}$ 是同一個集合。除此以外，集合的成員不會有重複的，重複的成員也都會是同一個，因此 $\{1,2,3,4,5\}$ 和 $\{1,1,2,3,3,3,4,4,5,5,5,5\}$ 也是同一個集合。
						</p>
					</div>
						
					<h5>集合的大小</h5>
					<div class="portion">
						<p>
						集合和集合之間也可以比大小，一個集合的大小是由它擁有的成員的個數來決定的。比如說，$\{1,2,3,4,5\}$ 這個集合有五個成員，所以它的大小就是五；而 $\{6,7,8,9\}$ 這個集合只有四個成員，因此它的大小就是四。因為五大於四，所以 $\{1,2,3,4,5\}$ 這個集合就比 $\{6,7,8,9\}$ 這個集合還要大。而當兩個集合擁有的成員個數一樣多時，這兩個集合就一樣大。
						</p>
						<p>
						要注意的是，相同的集合，其大小一定是相等的，但兩個大小相等的集合，卻不一定會是同一個集合。比如說，$\{1,2,3,4,5\}$ 和 $\{1,1,2,3,3,3,4,4,5,5,5,5\}$ 是同一個集合，因此兩個集合的大小是相等的，它們的大小都是五（記得嗎？集合中重複的成員只能算成一個）；但 $\{1,2,3,4,5\}$ 和 $\{6,7,8,9,10\}$ 的大小雖然相等，都是有五個成員的集合，這兩個集合卻不是同一個集合，因為兩個集合各自的成員並不相同。
						</p>
					</div>
						
					<h5>子集合與超集合</h5>
					<div class="portion">
						<p>
						集合和集合之間除了可以判斷是否相等和比大小之外，也可以判斷兩個集合之間是否有<b>包含</b>的關係：對於任意兩個集合 $\&Gamma;$ 和 $\&Delta;$ 而言，如果 $\&Delta;$ 的所有成員也都是 $\&Gamma;$ 的成員，那麼 $\&Gamma;$ 就包含了 $\&Delta;$。這時候，我們稱 $\&Delta;$ 是 $\&Gamma;$ 的<b>子集合 (subset)</b>。我們用 '$&sube;$' 的記號來表示「……是……的子集合」這個關係，因此，
							<blockquote>
							$\&Delta;$ 是 $\&Gamma;$ 的子集合
							</blockquote>
						就可以被寫成：
							<blockquote>
							$\&Delta;&sube;\&Gamma;$
							</blockquote>
						同時，因為 $\&Delta;$ 是 $\&Gamma;$ 的子集合，所以 $\&Gamma;$ 是 $\&Delta;$ 的<b>超集合 (superset)</b>（由於 'subset' 在中文裡被譯成「子集合」的關係，也有人將 'superset' 的中文譯為「父集合」）。我們用 '$&supe;$' 這個記號來表示「……是……的超集合」這個關係，因此，
							<blockquote>
							$\&Gamma;$ 是 $\&Delta;$ 的超集合
							</blockquote>
						也可以被寫成：
							<blockquote>
							$\&Gamma;&supe;\&Delta;$
							</blockquote>
						簡單來說，子集合和超集合之間的關係是這樣的：對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$ 而言，只要 $\&Delta;$ 是 $\&Gamma;$ 的子集合，那 $\&Gamma;$ 就會是 $\&Delta;$ 的超集合。（參考【圖一】）
						</p>
						<svg height="200px">
							<circle cx="100" cy="100" r="99" />
							<circle class="lgrey" cx="83" cy="118" r="70" />
							<text class="bold" x="140" y="50">&Gamma;</text>
							<text class="bold" x="72" y="127">&Delta;</text>
							<text x="250" y="100">&Delta; 是 &Gamma; 的子集合</text>
							<text x="250" y="120">&Gamma; 是 &Delta; 的超集合</text>
							<text x="400" y="199">【圖一】</text>
						</svg>
						<p>
						要注意的是，當 $\&Delta;$ 的所有成員也都是 $\&Gamma;$ 的成員時，$\&Gamma;$ 並不一定就擁有比 $\&Delta;$ 更多的成員，它們有可能剛好擁有一模一樣的成員（也就是說，當 $\&Delta;$ 和 $\&Gamma;$ 有可能是同一個集合）。因此，當 $\&Delta;$ 是 $\&Gamma;$ 的子集合時，$\&Gamma;$ 也可能是 $\&Delta;$ 的子集合，不過這種情況只會發生在 $\&Delta;$ 和 $\&Gamma;$ 是同一個集合的情況下。因此：<b>$\&Delta;&sube;\&Gamma;$ 而且 $\&Gamma;&sube;&Delta;$，當且僅當 $\&Delta;&equals;\&Gamma;$。</b>也就是說：當 $\&Delta;&sube;\&Gamma;$ 而且 $\&Gamma;&sube;\&Delta;$ 時，$\&Delta;&equals;\&Gamma;$；並且，只有當 $\&Delta;&equals;\&Gamma;$ 時，$\&Delta;&sube;\&Gamma;$ 和 $\&Gamma;&sube;\&Delta;$ 才會都成立。
						</p>
						<p>
						另一個要注意的事情是，稍早我提到集合的成員可以是任何東西，包括集合本身。因此，$\{1,2,3,4,5\}$ 是一個集合，而 $\{1,2,3,\{4,5\}\}$ 也會是一個集合，而且它們會是兩個不一樣的集合。集合 $\{1,2,3,4,5\}$ 一共有五個成員，分別是 1、2、3、4、5 這五個阿拉伯數字；然而集合 $\{1,2,3,\{4,5\}\}$ 的成員卻只有四個，它的成員是 1、2、3 這三個阿拉伯數字，以及 $\{4,5\}$ 這個集合。
						</p>
						<p>
						另外，對集合 $\{1,2,3,4,5\}$ 來說，$\{4,5\}$ 是它的子集合，因為 $\{4,5\}$ 這個集合的所有成員（4、5 這兩個阿拉伯數字）都是 $\{1,2,3,4,5\}$ 這個集合的成員；但是 $\{4,5\}$ 這個集合卻不是 $\{1,2,3,\{4,5\}\}$ 這個集合的子集合，因為 $\{1,2,3,\{4,5\}\}$ 這個集合的成員中既沒有 4 這個阿拉伯數字，也沒有 5 這個阿拉伯數字。
						</p>
					</div>
					
					<h5>$n$-元組</h5>
					<div class="portion">
						<p>
						另外有一種跟集合類似，但卻不是集合的東西，叫做 <b>$n$-元組 ($n$-tuple)</b>。$n$-元組中的 $n$ 是任意的一個自然數，它代表的是這個組當中有幾個東西，任何有三個東西的組都叫做三元組，任何有四個東西的組就叫四元組，以此類推。我們通常用角括號 '$&LeftAngleBracket;$', '$&RightAngleBracket;$' 來表示一個 $n$-元組。比如說，$&#x27E8;1,2,3&#x27e9;$ 是一個三元組，$&#x27e8;5,6,7,8&#x27e9;$ 則是一個四元組，其餘的可以此類推。
						</p>
						<p>
						$n$-元組和集合除了記號上的不同之外，有兩個主要的差別：
							<ol class="num local">
								<li>
								對集合來說，成員的順序不重要，但對一個 $n$-元組來說，變換成員的排列順序就會變成不同的 $n$-元組。比如說，前面提過，$\{1,2,3,4,5\}$ 和 $\{5,4,3,2,1\}$，儘管成員的順序不同，但它們仍是同一個集合；相反地，$&#x27e8;1,2,3,4,5&#x27e9;$ 和 $&#x27e8;5,4,3,2,1&#x27e9;$ 就是兩個不同的五元組。
								</li>
								<li>
								一個集合中不會有重複的成員，重複的成員只能算成是一個成員，因此 $\{1,2,3,4,5\}$ 和 $\{1,1,2,2,3,4,4,5\}$ 是同一個集合，在後面那個寫法中，所有重複的數字都只能算是一個，因此前後兩個集合都只有五個成員；相反地，$n$-元組就可以有重複的成員，因此 $&LeftAngleBracket;1,2,3,4,5&RightAngleBracket;$ 和 $&#x27e8;1,1,2,2,3,4,4,5&#x27e9;$ 就是兩個不同的 $n$-元組，前者是一個五元組，而後者則是一個八元組。
								</li>
							</ol>
						</p>
					</div>
						
					<h5>對集合的操作</h5>
					<div class="portion">
						<p>
						對於集合，我們可以做各種不同的操作。比如說，對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$，我們可以試著取這兩個集合的<b>交集 (intersection)</b>：$\&Gamma;&cap;\&Delta;$。對兩個集合取交集，取得的交集也是一個集合，它是兩個集合最大的共同子集合。簡單說，$\&Gamma;&cap;\&Delta;$ 就是將 $\&Gamma;$ 和 $\&Delta;$ 中所有相同的成員都蒐集起來的集合。（如【圖二】左）
						</p>
						<p>
						對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$，我們也可以取這兩個集合的<b>聯集 (union)</b>：$\&Gamma;&cup;\&Delta;$。對兩個集合取聯集，取得的聯集也會是一個集合，它是同時蒐集了兩個集合中所有成員的集合。簡單說，$\&Gamma;&cup;\&Delta;$ 就是將 $\&Gamma;$ 和 $\&Delta;$ 中所有的成員都蒐集起來的集合（當蒐集到重複的成員時，只能算一個）。（如【圖二】右）
						</p>
						<svg height="180px">
							<defs>
								<clipPath id="Lrcircle">
									<circle r="74" cx="155" cy="75" />
								</clipPath>
							</defs>
							<circle class="lgrey" clip-path="url(#Lrcircle)" r="74" cx="80" cy="75" />
							<circle r="74" cx="80" cy="75" />
							<circle r="74" cx="155" cy="75" />
							<text class="bold" x="45" y="80">&Gamma;</text>
							<text class="bold" x="180" y="80">&Delta;</text>
							<text class="bold" x="97" y="179">&Gamma;&cap;&Delta;</text>
							<defs>
								<clipPath id="RrCircle">
									<circle r="74" cx="425" cy="75" />
								</clipPath>
							</defs>
							<circle class="lgrey" r="74" cx="350" cy="75" />
							<circle class="lgrey" r="74" cx="425" cy="75" />
							<circle r="74" cx="350" cy="75" clip-path="url(#RrCircle)" />
							<text class="bold" x="315" y="80">&Gamma;</text>
							<text class="bold" x="450" y="80">&Delta;</text>
							<text class="bold" x="367" y="179">&Gamma;&cup;&Delta;</text>
							<text class="bold" x="510" y="179">【圖二】</text>
						</svg>
						<p>
						舉例來說，如果 $\&Gamma;&equals;\{1,2,3,4,5\}$，而 $\&Delta;&equals;\{4,5,6,7,8\}$，那麼 $\&Gamma;&cap;\&Delta;&equals;\{4,5\}$，因為只有 4、5 這兩個阿拉伯數字是 $\&Gamma;$ 和 $\&Delta;$ 這兩個集合所共有的成員。至於 $\&Gamma;&cup;&Delta;$ 則會是 $\{1,2,3,4,5,6,7,8\}$ 這個集合，因為將兩個集合中的所有成員都蒐集進同一個集合的話，會得到 $\{1,2,3,4,4,5,5,6,7,8\}$，而其中重複出現過兩次的 4 和 5 這兩個成員各自都只能算一個，所以其實是 $\{1,2,3,4,5,6,7,8\}$。
						</p>
						<p>
						除了對任意兩個集合取交集或聯集之外，我們也可以對任意兩個集合 $\&Gamma;$ 和 $\&Delta;$ 取其<b>乘積 (product)</b>：$\&Gamma;&times;\&Delta;$。$\&Gamma;&times;\&Delta;$ 也是一個集合，不過這個集合的成員比較特別，我們要從 $\&Gamma;$ 和 $\&Delta;$ 這兩個集合中任意各取一個成員出來，然後將從 $\&Gamma;$ 中取出來的成員放前面，將從 $\&Delta;$ 中取出來的成員放後面，形成一個二元組。最後將所有依前述方法組成的二元組都蒐集進同一個集合，就是 $\&Gamma;&times;\&Delta;$。
						</p>
						<p>
						舉例來說，如果 $\&Gamma;&equals;\{1,2,3\}$，$\&Delta;=\{a,b,c\}$，那 $\&Gamma;&times;\&Delta;$ 就會等於 $\{&#x27e8;1,a&#x27e9;,&#x27e8;1,b&#x27e9;,$ $&#x27e8;1,c&#x27e9;,&#x27e8;2,a&#x27e9;,&#x27e8;2,b&#x27e9;,&#x27e8;2,c&#x27e9;,&#x27e8;3,a&#x27e9;,&#x27e8;3,b&#x27e9;,&#x27e8;3,c&#x27e9;\}$。這個集合一共有九個成員，每個成員都是一個二元組，每個二元組都是由一個取自 $\&Gamma;$ 的成員和一個取自 $\&Delta;$ 的成員所組成，而且取自 $\&Gamma;$ 的成員必須放在左邊，取自 $\&Delta;$ 的成員則必須放在右邊。（見【圖三】）
						</p>
						<svg height="200">
							<defs>
								<marker id="head" orient="auto" markerWidth="6" markerHeight="6" refX="0.1" refY="3">
									<path d="M0 0 V6 L6 3 Z" />
								</marker>
								<marker id="head2" orient="auto" markerWidth="3" markerHeight="3" refX="0.1" refY="1.5">
									<path d="M0 0 V3 L3 1.5 Z" />
								</marker>
							</defs>
							<ellipse cx="90" cy="50" rx="35" ry="45" />
							<text class="bold" x="30" y="55">&Gamma;</text>
							<text x="86" y="25">1</text>
							<path marker-end="url(#head)" d="M100 20 L305 20" />
							<path marker-end="url(#head)" d="M100 20 L150 40 L305 40" />
							<path marker-end="url(#head)" d="M100 20 L150 60 L305 60" />
							<text x="86" y="55">2</text>
							<path marker-end="url(#head)" stroke-dasharray="5,2" d="M100 50 L170 80 L305 80" />
							<path marker-end="url(#head)" stroke-dasharray="5,2" d="M100 50 L170 100 L305 100" />
							<path marker-end="url(#head)" stroke-dasharray="5,2" d="M100 50 L170 120 L305 120" />
							<text x="86" y="85">3</text>
							<path marker-end="url(#head2)" d="M100 80 L170 140 L305 140" style="stroke-width:2;"/>
							<path marker-end="url(#head2)" d="M100 80 L170 160 L305 160" style="stroke-width:2;" />
							<path marker-end="url(#head2)" d="M100 80 L170 180 L305 180" style="stroke-width:2;" />
							<ellipse cx="90" cy="150" rx="35" ry="45" />
							<text class="bold" x="30" y="155">&Delta;</text>
							<text x="86" y="125">a</text>
							<path d="M100 120 L150 20" />
							<path stroke-dasharray="5,2" d="M100 120 L170 80" />
							<path d="M100 120 L170 140" style="stroke-width:2;" />
							<text x="86" y="155">b</text>
							<path d="M100 150 L150 40" />
							<path stroke-dasharray="5,2" d="M100 150 L170 100" />
							<path d="M100 150 L170 160" style="stroke-width:2;" />
							<text x="86" y="185">c</text>
							<path d="M100 180 L150 60" />
							<path stroke-dasharray="5,2" d="M100 180 L170 120" />
							<path d="M100 180 L170 180" style="stroke-width:2;" />
							<ellipse cx="337" cy="100" rx="80" ry="99" />
							<text class="bold" x="430" y="105">&Gamma;&times;&Delta;</text>
							<text x="320" y="25">&#x27e8;1,a&#x27e9;</text>
							<text x="320" y="45">&#x27e8;1,b&#x27e9;</text>
							<text x="320" y="65">&#x27e8;1,c&#x27e9;</text>
							<text x="320" y="85">&#x27e8;2,a&#x27e9;</text>
							<text x="320" y="105">&#x27e8;2,b&#x27e9;</text>
							<text x="320" y="125">&#x27e8;2,c&#x27e9;</text>
							<text x="320" y="145">&#x27e8;3,a&#x27e9;</text>
							<text x="320" y="165">&#x27e8;3,b&#x27e9;</text>
							<text x="320" y="185">&#x27e8;3,c&#x27e9;</text>
							<text x="500" y="199">【圖三】</text>
						</svg>
						<p>
						以上這些操作都不只能作用在兩個集合之間，我們可以取五個集合的交集，那就必須將五個集合中所有相同的成員都蒐集起來；也可以取四個集合的聯集，那就是把四個集合的所有成員都蒐集起來；當然也可以取三個集合的乘績，如此得到的集合，其成員都會是由三個集合分別取出的成員所排列成的三元組。
						</p>
					</div>
				</div>
				
				<h3>函數</h3>
				
				<div class="subsection">
					<p>
					簡單介紹過關於集合的一些基本觀念之後，現在要說明什麼是函數。
					</p>
					<p>
					前面說，函數是用來描述兩個集合的成員之間的特殊對應關係，那這個特殊對應關係是什麼呢？更準確地說，一個函數就是以一個集合的成員作為輸入，然後會輸出另一個集合的成員的操作程序。我們將提供輸入的集合稱為這個函數的<b>論域 (domain)</b>，並將所有輸出的值所形成的集合稱為這個函數的<b>值域 (range)</b>。
					</p>
					<p>
					一個函數除了是兩個集合之間的「輸入／輸出」關係之外，還必須滿足以下兩個條件：<b>一、每一個輸入都一定要有一個輸出；二、每一個輸入都只能有一個輸出。</b>我們通常會將一個函數寫作 '$\sc{f}\：\&Gamma;&rarr;\&Delta;$'，意思是：「$\sc{f}$ 是一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數」 ，其中的 $\&Gamma;$ 和 $\&Delta;$ 都是集合，$\&Gamma;$ 寫在 '$&rarr;$' 的左邊，表示它是 $\sc{f}$ 這個函數的論域，而 $\&Delta;$ 寫在 '$&rarr;$' 的右邊，表示它是 $\sc{f}$ 這個函數的<b>對應域 (codomain)</b>。
					</p>
					<p>
					若我們以 '$x$' 來代表 $\&Gamma;$ 中的成員，以 '$y$' 來代表 $\&Delta;$ 中的成員，當 $\sc{f}$ 是一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數時，我們也可以把這個函數寫成 '$\sc{f}(x)=y$'，意思是：只要從 $\&Gamma;$ 當中挑任何一個 '$x$' 出來並輸入 '$\sc{f}$' 這個函數，這個函數就會輸出一個 $\&Delta;$ 中成員 '$y$'，而且只會輸出一個。換言之，一個從 $\&Gamma;$ 到 $\&Delta;$ 的函數，就是一個以 $\&Gamma;$ 的成員為輸入，並且以 $\&Delta;$ 的成員為輸出的操作程序。
					</p>
					<p>
					以【圖四】為例，左、中、右三張圖分別呈現出 $\&Gamma;$ 和 $\&Delta;$ 這兩個集合之間的三種不同的輸入／輸出關係。左圖中，作為論域的 $\&Gamma;$ 中的 c 這一成員沒有對應到任何輸出，故不滿足條件一，因此不算是一個函數。而在中間那張圖裡，雖然每一個輸入確實都有對應的輸出，但 c 作為輸入時卻對應到兩個輸出（即 $\&Delta;$ 中的 2 和 3），故不滿足條件二，因此也不算是一個函數。唯有右圖中的每一個輸入確實都有一個對應的輸入，故滿足條件一，而且每一個輸入也確實都只對應到一個輸出，故也滿足條件二，因此右圖所呈現出來的輸入／輸出關係才算是一個函數。
					</p>
					<svg height="150">
						<ellipse cx="35" cy="75" rx="34" ry="74" /><text class="bold" x="0" y="11">&Gamma;</text>
						<text x="30" y="30">a</text>
						<text x="30" y="55">b</text>
						<text x="30" y="80">c</text>
						<text x="30" y="105">d</text>
						<text x="30" y="130">e</text>
						<ellipse cx="115" cy="75" rx="34" ry="74" /><text class="bold" x="80" y="11">&Delta;</text>
						<text x="110" y="30">1</text>
						<text x="110" y="55">2</text>
						<text x="110" y="80">3</text>
						<text x="110" y="105">4</text>
						<text x="110" y="130">5</text>
						<path marker-end="url(#head)" d="M45 25 L100 25" />
						<path marker-end="url(#head)" d="M45 50 L100 50" />
						<path marker-end="url(#head)" d="M45 100 L100 75" />
						<path marker-end="url(#head)" d="M45 125 L100 100" />
						<ellipse cx="215" cy="75" rx="34" ry="74" /><text class="bold" x="180" y="11">&Gamma;</text>
						<text x="210" y="30">a</text>
						<text x="210" y="55">b</text>
						<text x="210" y="80">c</text>
						<text x="210" y="105">d</text>
						<text x="210" y="130">e</text>
						<ellipse cx="295" cy="75" rx="34" ry="74" /><text class="bold" x="260" y="11">&Delta;</text>
						<text x="290" y="30">1</text>
						<text x="290" y="55">2</text>
						<text x="290" y="80">3</text>
						<text x="290" y="105">4</text>
						<text x="290" y="130">5</text>
						<path marker-end="url(#head)" d="M220 25 L280 25" />
						<path marker-end="url(#head)" d="M220 50 L280 50" />
						<path marker-end="url(#head)" d="M220 75 L280 58" />
						<path marker-end="url(#head)" d="M220 75 L280 75" />
						<path marker-end="url(#head)" d="M220 100 L280 100" />
						<path marker-end="url(#head)" d="M220 125 L280 125" />
						<ellipse cx="395" cy="75" rx="34" ry="74" /><text class="bold" x="360" y="11">&Gamma;</text>
						<text x="390" y="30">a</text>
						<text x="390" y="55">b</text>
						<text x="390" y="80">c</text>
						<text x="390" y="105">d</text>
						<text x="390" y="130">e</text>
						<ellipse cx="475" cy="75" rx="34" ry="74" /><text class="bold" x="440" y="11">&Delta;</text>
						<text x="470" y="30">1</text>
						<text x="470" y="55">2</text>
						<text x="470" y="80">3</text>
						<text x="470" y="105">4</text>
						<text x="470" y="130">5</text>
						<path marker-end="url(#head)" d="M400 25 L460 25" />
						<path marker-end="url(#head)" d="M400 50 L460 50" />
						<path marker-end="url(#head)" d="M400 75 L460 75" />
						<path marker-end="url(#head)" d="M400 100 L460 83" />
						<path marker-end="url(#head)" d="M400 125 L460 125" />
							<text class="bold" x="510" y="149">【圖四】</text>
					</svg>
					<p>
					要注意的是，對應域和值域雖然是不同的東西，但因為兩者關係密切而且極為相似，所以經常會被混淆。簡單來說，一個函數的值域一定是這個函數的對應域的子集合。以【圖五】為例，【圖五】是【圖四】最右圖的放大版。根據【圖五】，我們可以很明顯地看出來：$\sc{f}$ 雖然是從 $\&Gamma;$ 對應到 $\&Delta;$ 的函數，因此 $\&Delta;$ 確實是 $\sc{f}$ 的<b>對應域</b>。但 $\&Delta;$ 中有一個成員（數字 $4$）其實沒有對應的輸入值。
					</p>
					<p>
					也就是說，當我們以 $\&Gamma;$ 中的成員輸入到 $\sc{f}$ 這個函數時，我們可以得到的所有輸出所形成的集合（<b>值域</b>），會是 $\sc{f}(x)=\{1,2,3,5\}$ 這個集合，而非 $\&Delta;=\{1,2,3,4,5\}$ 這個集合。這是因為函數的定義只要求論域中的每一個成員作為輸入時，都一定要在對應域中有一個輸出，卻<b>沒有要求</b>對應域中的每一個輸出一定都要被對應到。因此函數的值域一定都是其對應域的子集合，只有當函數的對應域中的每一個成員都有被對應到時，函數的值域才會等於它的對應域。
					</p>
					<svg height="150">
						<ellipse cx="50" cy="75" rx="49" ry="74" />
						<text class="bold" x="0" y="11">&Gamma;</text>
						<text x="46" y="30">a</text>
						<text x="46" y="55">b</text>
						<text x="46" y="80">c</text>
						<text x="46" y="105">d</text>
						<text x="46" y="130">e</text>
						<ellipse cx="300" cy="75" rx="99" ry="74" />
						<text class="bold" x="200" y="11">&Delta;</text>
						<text x="350" y="80">4</text>
						<ellipse class="lgrey" cx="284" cy="75" rx="40" ry="60" />
						<path marker-end="url(#head)" d="M60 26 L270 30" />
						<text x="280" y="35">1</text>
						<path marker-end="url(#head)" d="M60 51 L270 60" />
						<text x="280" y="65">2</text>
						<path marker-end="url(#head)" d="M60 76 L270 87" />
						<path marker-end="url(#head)" d="M60 101 L270 93" />
						<text x="280" y="95">3</text>
						<path marker-end="url(#head)" d="M60 126 L270 120" />
						<text x="280" y="125">5</text>
						<path d="M305 50 L410 10" />
						<text class="bold" x="420" y="14"><tspan class="felipa">f</tspan><tspan>(</tspan><tspan class="ita">x</tspan><tspan>)</tspan></text>
						<text class="bold" x="450" y="149">【圖五】</text>
					</svg>
					<p>
					函數在生活中並不少見，例如自然數加法中的 '$&plus;1$' 就是一個從自然數的集合到自然數的集合的函數。對任何自然數的成員 '$x$' 來說，只要輸入 $+1$ 這個函數（即對 $x$ 做 $+1$ 的操作），就會輸出一個自然數的成員（$x+1$），而且每個輸入都只會有一個輸出。比如說，$1$ 是自然數的成員，只要把 $1$ 輸入 $+1$ 這個函數，就會得到 $2$ 這個輸出，而且只會得到 $2$ 這個輸出；$2$ 也是自然數的成員，只要把 $2$ 輸入 $+1$ 這個函數，就會得到 $3$ 這個輸出，而且只會得到 $3$ 這個輸出；以下類推。（見【圖六】）
					</p>
					<svg height="150">
						<text x="30" y="12">&#x2115;</text>
						<ellipse cx="70" cy="75" rx="40" ry="74" />
						<text x="67" y="30">0
							<tspan x="67" y="50">1</tspan>
							<tspan x="67" y="70">2</tspan>
							<tspan x="67" y="90">3</tspan>
							<tspan x="67" y="110">4</tspan>
							<tspan x="69" y="130">&vellip;</tspan>
						</text>
						<text x="360" y="12">&#x2115;</text>
						<ellipse cx="400" cy="75" rx="40" ry="74" />
						<text x="397" y="20">0
							<tspan x="397" y="40">1</tspan>
							<tspan x="397" y="60">2</tspan>
							<tspan x="397" y="80">3</tspan>
							<tspan x="397" y="100">4</tspan>
							<tspan x="397" y="120">5</tspan>
							<tspan x="399" y="140">&vellip;</tspan>
						</text>
						<path marker-end="url(#head)" d="M80 25 L385 35" />
						<path marker-end="url(#head)" d="M80 45 L385 55" />
						<path marker-end="url(#head)" d="M80 65 L385 75" />
						<path marker-end="url(#head)" d="M80 85 L385 95" />
						<path marker-end="url(#head)" d="M80 105 L385 115" />
						<path marker-end="url(#head)" d="M100 125 Q155 140 210 140" />
						<text x="145" y="135">輸入</text>
						<path marker-end="url(#head)" d="M250 140 Q320 140 364 125" />
						<text x="290" y="134">輸出</text>
						<text x="220" y="145">+1</text>
						<text x="450" y="149">【圖六】</text>
					<p>
					再舉一個例子來說，我們平時搭乘的電梯也是一個函數，當你輸入一個電梯樓層的按鈕，電梯就會以「到達對應的樓層」為輸出。你按下「3樓」的按鈕作為輸入，電梯就會以「到達3樓」為輸出；你按下「6樓」的按鈕作為輸入，電梯就會以「到達6樓」為輸出。每一個樓層按鈕的輸入都會對應到一個「到達樓層」的輸出，而且每一個樓層按鈕的輸入都只會對應到一個「到達樓層」的輸出。按下「3樓」的按鈕，電梯就只會到達3樓，而不會到達其它樓層。
					</p>
					<p>
					函數是一個輸入到輸出的操作，有輸入就一定要有輸出，而且每個輸入都一定只能有一個輸出。但函數的輸入可以不只是「一個東西」，有些函數也可以輸入「一組東西」。比如說，前面提到的 '$+1$' 是一個每次都只能輸入「一個東西」的函數，但四則運算中的 '$+$' 就必須同時輸入兩個數字才能得到一個輸出。如果我們只對 '$+$' 輸入一個數字，那不論是 '$2+$' 或 '$+2$'，都不會有任何輸出，唯有同時輸入兩個數字時，比如說 '$1+2$' 或 '$0+1$'，我們才能分別得到 '$3$' 和 '$1$' 這兩個輸出。
					</p>
					<p>
					由於 '$&plus;$' 這個函數一定要一次輸入兩個數字才能進行運算得到輸出，也就是說，要進行 '$+$' 這個函數的運算，我們必須先在自然數的集合裡取一個成員出來，然後再從自然數的集合裡取一個成員出來，並將這兩個取自自然數的集合的成員依序輸入 '$+$' 這個函數，才能進行運算並得到一個自然數（因為自然數的加法的結果也一定是自然數）。因此，'$+$' 這個函數的論域就是 $\&#x2115;&times;\&#x2115;$，而值域則是 $\&#x2115;$。（見【圖七】）
					</p>
					<svg height="200">
						<text x="60" y="12">&#x2115;</text>
						<ellipse cx="90" cy="50" rx="30" ry="45" />
						<text x="86" y="25">0
							<tspan x="86" y="45">1</tspan>
							<tspan x="86" y="65">2</tspan>
							<tspan x="88" y="85">&vellip;</tspan>
						</text>
						<text x="60" y="200">&#x2115;</text>
						<ellipse cx="90" cy="150" rx="30" ry="45" />
						<text x="86" y="125">0
							<tspan x="86" y="145">1</tspan>
							<tspan x="86" y="165">2</tspan>
							<tspan x="88" y="185">&vellip;</tspan>
						</text>
						<path d="M100 20 C150 30 150 95 100 120" /><path d="M100 20 C160 32 160 110 100 140" /><path d="M100 20 C170 34 170 125 100 160" />
						<path d="M80 40 C50 45 50 95 80 120" /><path d="M80 40 C40 50 40 110 80 140" /><path d="M80 40 C30 55 30 125 80 160" />
						<path d="M100 60 C110 65 110 115 100 120" /><path d="M100 60 C120 70 120 130 100 140" /><path d="M100 60 C130 75 130 145 100 160" />
						<text x="170" y="110" style="font-size:40px;">&rArr;</text>
						<text x="205" y="12">&#x2115;&times;&#x2115;</text>
						<ellipse cx="265" cy="100" rx="40" ry="99" />
						<text x="408" y="12">&#x2115;</text>
						<ellipse cx="440" cy="100" rx="40" ry="99" />
						<text x="248" y="25">&#x27e8;0,0&#x27e9;
							<tspan x="248" y="40">&#x27e8;0,1&#x27e9;</tspan>
							<tspan x="248" y="55">&#x27e8;0,2&#x27e9;</tspan>
							<tspan x="263" y="70">&vellip;</tspan>
							<tspan x="248" y="85">&#x27e8;1,0&#x27e9;</tspan>
							<tspan x="248" y="100">&#x27e8;1,1&#x27e9;</tspan>
							<tspan x="248" y="115">&#x27e8;1,2&#x27e9;</tspan>
							<tspan x="263" y="130">&vellip;</tspan>
							<tspan x="248" y="145">&#x27e8;2,0&#x27e9;</tspan>
							<tspan x="248" y="160">&#x27e8;2,1&#x27e9;</tspan>
							<tspan x="248" y="175">&#x27e8;2,2&#x27e9;</tspan>
							<tspan x="263" y="190">&vellip;</tspan>
						</text>
						<text x="436" y="30">0
							<tspan x="436" y="60">1</tspan>
							<tspan x="436" y="90">2</tspan>
							<tspan x="436" y="120">3</tspan>
							<tspan x="436" y="150">4</tspan>
							<tspan x="438" y="180">&vellip;</tspan>
						</text>
						<path marker-end="url(#head)" d="M280 20 L427 25" />
						<path marker-end="url(#head)" d="M280 35 L427 52" />
						<path marker-end="url(#head)" d="M280 50 L427 80" />
						<path marker-end="url(#head)" d="M280 80 L427 60" />
						<path marker-end="url(#head)" d="M280 95 L427 86" />
						<path marker-end="url(#head)" d="M280 110 L427 111" />
						<path marker-end="url(#head)" d="M280 140 L427 91" />
						<path marker-end="url(#head)" d="M280 155 L427 118" />
						<path marker-end="url(#head)" d="M280 170 L427 147" />
						<text x="345" y="200">+</text>
						<path marker-end="url(#head)" d="M288 180 Q310 195 334 195" />
						<path marker-end="url(#head)" d="M362 195 Q395 195 410 180" />
						<text x="305" y="187">輸入</text>
						<text x="365" y="187">輸出</text>
						<text x="480" y="199">【圖七】</text>
					</svg>
					<p>
					既然函數可以有「需要輸入多少個東西才能得到輸出」的差別，我們就可以根據一個函數必須輸入多少東西才能得到輸出，將函數區分成幾元的函數。必須輸入一個東西的函數被稱為<b>一元</b>函數，必須輸入兩個東西的函數被稱為<b>二元</b>函數，必須輸入三個東西的函數，就被稱為<b>三元</b>函數，以此類推。
					</p>
				</div>
				
				<h3>真值函數</h3>
				
				<div class="subsection">
					<p>
					簡單介紹過關於集合和函數的基本觀念後，我們就要來談<b>真值函數</b>了。在這一節的一開始，我提到以下這件事：語句邏輯中每一個語句，都是一個真值函數。在理解了函數的基本觀念後，我們就能理解這句話的意思是：語句邏輯中的每一個語句都是一個關於<b>真值 (truth value)</b> 的輸入／輸出的操作。
					</p>
					<p>
					舉例來說，'$&alpha;&and;&beta;$' 是一個以 '$&and;$' 作為主要連接詞，將 '$&alpha;$' 和 '$&beta;$' 這兩個言句連接起來的連言句。根據連言句的真值表，我們知道：
						<ul class="tight">
							<li>當 '$&alpha;$' 為真、'$&beta;$' 為真時，'$&alpha;&and;&beta;$' 為真；</li>
							<li>當 '$&alpha;$' 為真、'$&beta;$' 為假時，'$&alpha;&and;&beta;$' 為假；</li>
							<li>當 '$&alpha;$' 為假、'$&beta;$' 為真時，'$&alpha;&and;&beta;$' 為假；</li>
							<li>當 '$&alpha;$' 為假、'$&beta;$' 為假時，'$&alpha;&and;&beta;$' 為假。</li>
						</ul>
					如果把 '$&alpha;&and;&beta;$' 中的 '$&alpha;$' 和 '$&beta;$' 看成是可以輸入真假值的兩個位置，那麼 '$&alpha;&and;&beta;$' 就可以被看成是一個函數：只要在 '$&alpha;$' 和 '$&beta;$' 的位置分別填入真或假，那 '$&alpha;&and;&beta;$' 就會輸出一個真假值。比如說，在 '$&alpha;$' 的位置輸入「真」，在 '$&beta;$' 的位置輸入「真」，'$&alpha;&and;&beta;$' 就會輸出「真」；在 '$&alpha;$' 的位置輸入「假」，在 '$&beta;$' 的位置輸入「真」，'$&alpha;&and;&beta;$' 就會輸出假；……以此類推。
					</p>
					<p>
					由於每一個語句邏輯中的語句都只有「真」、「假」兩種可能性，因此我們可以把這兩種可能性蒐集進一個集合裡，形成 $\{\T,\F\}$ 這樣的一個集合。那麼，對於每一個語句連接詞，當它被用來當作構成某個語句的主要連接詞時，都可以被看成是一個以 $\{\T,\F\}$（一元連接詞），或者是以 $\{\T,\F\}&times;\{\T,\F\}$（二元連接詞）為論域，並且以 $\{\T,\F\}$ 為對應域的函數。
					</p>
					<p>
					當我們以一元連接詞 '$&not;$' 為主要連接詞來構成語句時，它就是一個從 $\{\T,\F\}$ 到 $\{\T,\F\}$ 的一元函數，只要輸入 $\T$ 或 $\F$，就會得到 $\T$ 或 $\F$ 的輸出；而當我們以二元連接詞 '$&and;$'、'$&or;$'、'$&rarr;$' 或 '$&harr;$' 作為主要來接詞來構成語句時，它就是一個從 $\{\T,\F\}&times;\{\T,\F\}$ 到 $\{\T,\F\}$ 的函數，只要輸入 $&#x27e8;\T,\T&#x27e9;$、$&#x27e8;\T,\F&#x27e9;$、$&#x27e8;\F,\T&#x27e9;$ 或 $&#x27e8;\F,\F&#x27e9;$，就會得到 $\T$ 或 $\F$ 的輸出。我們可以用【圖八】來表示這五個函數：
					</p>
					<svg height="200">
						<text class="bold" x="65" y="11">&not;<tspan class="ita">&alpha;</tspan></text>
						<ellipse cx="35" cy="50" rx="34" ry="49" />
						<text x="30" y="40">T</text>
						<path marker-end="url(#head)" d="M45 35 L105 63" />
						<text x="30" y="70">F</text>
						<path marker-end="url(#head)" d="M45 65 L105 38" />
						<ellipse cx="120" cy="50" rx="34" ry="49" />
						<text x="115" y="40">T</text>
						<text x="115" y="70">F</text>
						<text class="bold" x="263" y="11"><tspan class="ita">&alpha;</tspan>&and;<tspan class="ita">&beta;</tspan></text>
						<ellipse cx="240" cy="50" rx="34" ry="49" />
						<text x="220" y="25">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 22 L310 33" />
						<text x="220" y="45">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 42 L310 58" />
						<text x="220" y="65">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 61 L310 64" />
						<text x="220" y="85">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M260 81 L310 70" />
						<ellipse cx="325" cy="50" rx="34" ry="49" />
						<text x="320" y="40">T</text>
						<text x="320" y="70">F</text>
						<text class="bold" x="468" y="11"><tspan class="ita">&alpha;</tspan>&or;<tspan class="ita">&beta;</tspan></text>
						<ellipse cx="445" cy="50" rx="34" ry="49" />
						<text x="425" y="25">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 22 L515 30" />
						<text x="425" y="45">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 42 L515 36" />
						<text x="425" y="65">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 62 L515 42" />
						<text x="425" y="85">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M465 81 L515 66" />
						<ellipse cx="530" cy="50" rx="34" ry="49" />
						<text x="525" y="40">T</text>
						<text x="525" y="70">F</text>
						<text class="bold" x="158" y="196"><tspan class="ita">&alpha;</tspan><tspan y="197">&rarr;</tspan><tspan class="ita">&beta;</tspan></text>
						<ellipse cx="137" cy="150" rx="34" ry="49" />
						<text x="117" y="125">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 122 L207 130" />
						<text x="117" y="145">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 142 L207 162" />
						<text x="117" y="165">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 162 L207 137" />
						<text x="117" y="185">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M157 181 L207 144" />
						<ellipse cx="222" cy="150" rx="34" ry="49" />
						<text x="217" y="140">T</text>
						<text x="217" y="170">F</text>
						<text class="bold" x="363" y="196"><tspan class="ita">&alpha;</tspan><tspan y="197">&harr;</tspan><tspan class="ita">&beta;</tspan></text>
						<ellipse cx="342" cy="150" rx="34" ry="49" />
						<text x="322" y="125">&#x27e8;T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 122 L412 133" />
						<text x="322" y="145">&#x27e8;T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 142 L412 160" />
						<text x="322" y="165">&#x27e8;F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 162 L412 166" />
						<text x="322" y="185">&#x27e8;F,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M362 181 L412 141" />
						<ellipse cx="427" cy="150" rx="34" ry="49" />
						<text x="422" y="140">T</text>
						<text x="422" y="170">F</text>
						<text class="bold" x="510" y="199">【圖八】</text>
					</svg>
					<p>
					從【圖八】可以清楚地看出來，這五個句型確實都滿足函數的定義，每個輸入（主要連接詞所連接之語句的真假，一元連接詞只連接一個語句，所以輸入就只有 $\T$ 或 $\F$；二元連接詞連接兩個語句，所以輸入就是一個二元組，左邊擺的是寫在連接詞左側之語句的真假，右邊擺的則是寫在連接詞左側之語句的真假）都一定有一個輸出，而且每個輸入都只會有一個輸出。
					</p>
					<p>
					前面說過，語句邏輯中除了原子語句之外，所有的語句一定都是用這五個語句連接詞所建構出來的，因此只要給定每一個原子語句的真假，我們就能夠根據【圖八】中的五個函數來確定每一個語句的真假。換言之，每一個語句邏輯中的語句也都可以看成是一個真值函數，這個函數的論域就是該語句所使用到的所有原子語句的真假，而對應域則依舊是 $\{\T,\F\}$ 這個集合。以 '$&not;A&and;(B&or;C)$' 這個語句為例：
					</p>
					<svg height="200">
						<text class="bold" x="110" y="21">&not;<tspan class="ita">A</tspan> &and; (<tspan class="ita">B</tspan> &or; <tspan class="ita">C</tspan>)</text>
						<ellipse cx="50" cy="100" rx="49" ry="99" />
						<text x="22" y="35">&#x27e8;T,T,T&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M80 32 L235 140" />
						<text x="22" y="55">&#x27e8;T,T,F&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M78 52 L235 144" />
						<text x="22" y="75">&#x27e8;T,F,T&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M78 72 L235 148" />
						<text x="22" y="95">&#x27e8;T,F,F&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M77 92 L235 152" />
						<text x="22" y="115">&#x27e8;F,T,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M78 112 L235 97" />
						<text x="22" y="135">&#x27e8;F,T,F&#x27e9;</text>
						<path marker-end="url(#head)" d="M77 132 L235 102" />
						<text x="22" y="155">&#x27e8;F,F,T&#x27e9;</text>
						<path marker-end="url(#head)" d="M77 152 L235 107" />
						<text x="22" y="175">&#x27e8;F,F,F&#x27e9;</text>
						<path marker-end="url(#head)" stroke-dasharray="5,2" d="M75 172 L235 156" />
						<ellipse cx="250" cy="125" rx="49" ry="74" />
						<text x="245" y="105">T</text>
						<text x="245" y="155">F</text>
						<text class="bold" x="300" y="199">【圖九】</text>
					</svg>
					<p>
					根據【圖九】，只要輸入三個原子語句的真假（由 $\{\T,\F\}&times;\{\T,\F\}&times;\{\T,\F\}$ 形成的三元組），就會輸出一個 $\T$ 或 $\F$，而且每一組輸入都只會有一個輸出。因此，【圖九】亦可佐證語句邏輯中的每一個語句也都是一個真值函數的說法。
					</p>
					<p>
					既然所有語句都是一個由原子語句的真假（所形成的 $n$-元組）到 $\{\T,\F\}$ 的函數，那麼，只要有一個函數可以決定所有原子語句的真假，這個函數再加上【圖八】中所列出的五個句型的真值函數，就會得到一個能夠判斷出所有語句真假的函數。
					</p>
					<p>
					而我在前一章介紹過，每一個<b>語意模型</b>都會決定每一個原子語句的真假，因此，我們就可以利用語意模型來製造出能夠判別所有語句真假的函數。由於語意模型的符號是 $\sc{v}_n$（$n$ 是一個任意數），我們就把用語意模型創造出來的真值函數寫作 $\sc{v}_n'$。<span class="note"><span class="box">請注意，因為每一個語意模型所決定的原子語句之真假都不一樣，所以每一個不同的語意模型都會對應到一個不一樣的真值函數。比如說，$\sc{v}_1$ 就會對應到 $\sc{v}_1'$，而 $\sc{v}_2$ 就會對應到 $\sc{v}_2'$，以下類推。</span></span>
					</p>
					<p>
					$\sc{v}_n'$ 是一個以<b>所有語句邏輯的語句（包括所有原子語句和複雜語句）所形成的集合</b>為論域，並以 $\{\T,\F\}$ 為對應域的函數。我們將所有語句邏輯的語句所形成的集合簡稱為 $SL$（"sentential logic"，也就是語句邏輯的英文的縮寫），那麼，對於某個語意模型 $\sc{v}_n$ 所決定出來的真值函數 $\sc{v}_n'$，我們就可以將它寫成：$\sc{v}_n'\：SL&rarr;\{\T,\F\}$。然後，我們可以用以下方式定義 $\sc{v}_n'$ 這個函數：
						<ol class="numd local tight">
							<li>當 $&alpha;$ 是原子語句時，$\sc{v}_n'(&alpha;)=\T$ 當且僅當 $\sc{v}_n&vDash;\sc{&alpha;}$。</li>
						</ol>
					在利用定義 1 確定了所有原子語句之真假後，我們接下來定義五大句型的真值函數：
						<ol class="numd tight">
							<li>$\sc{v}_n'(&not;&alpha;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\F$。</li>
							<li>$\sc{v}_n'(&alpha;&and;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\T$ 而且 $\sc{v}_n'(&beta;)=\T$。</li>
							<li>$\sc{v}_n'(&alpha;&or;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\T$ 或者 $\sc{v}_n'(&beta;)=\T$。</li>
							<li>$\sc{v}_n'(&alpha;&rarr;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\F$ 或者 $\sc{v}_n'(&beta;)=\T$。</li>
							<li>$\sc{v}_n'(&alpha;&harr;&beta;)=\T$ 當且僅當 $\sc{v}_n'(&alpha;)=\sc{v}_n'(&beta;)$。</li>
						</ol>
					</p>
					<p>
					透過這六條定義，我們就能用這樣的函數來判斷任何語句的真假了。我們繼續採用 '$&not;A&and;(B&or;C)$' 這個語句來當作例子，要用上述函數來判斷這個語句的真假，我們就要將它輸入到那個函數之中。所以我們就是要求：
						<ul>
							<li>$\sc{v}_n'(&not;A&and;(B&or;C))=\？$</li>
						</ul>
					因為 '$&not;A&and;(B&or;C)$' 的主要連接詞是 '$&and;$'，所以第一步要先套用定義 3，得到：
						<ul>
							<li>$\sc{v}_n'(&not;A&and;(B&or;C))=\T$ 當且僅當 $\sc{v}_n'(&not;A)=\T$ 而且 $\sc{v}_n'(B&or;C)=\T$</li>
						</ul>
					因此我們需要分別求 $\sc{v}_n'(&not;A)$ 和 $\sc{v}_n'(B&or;C)$ 的值，因此要分別套用定義 2、4，得到：
						<ul class="tight">
							<li>$\sc{v}_n'(&not;A)=\T$ 當且僅當 $\sc{v}_n'(A)=\F$。</li>
							<li>$\sc{v}_n'(B&or;C)=\T$ 當且僅當 $\sc{v}_n'(B)=\T$ 或者 $\sc{v}_n'(C)=\T$。</li>
						</ul>
					最後，就可以根據定義 1 來分別判斷 $\sc{v}_n'(A)$、$\sc{v}_n'(B)$ 和 $\sc{v}_n'(C)$ 的值，而這個判斷就涉及我們選擇的語意模型究竟是哪一個了。比如說，假如我們選擇的語意模型是 $\sc{v}_1$，而 $\sc{v}_1$ 是所有原子語句都為真的語意模型，因此，透過 $\sc{v}_1$ 所對應到的真值函數 $\sc{v}_1'$ 來計算 '$&not;A&and;(B&or;C)$' 這個語句的真假時，計算的過程就會如下：
						<table class="prf">
							<tr><td>$\sc{v}_1'(A)=\T$、$\sc{v}_1'(B)=\T$，而且 $\sc{v}_1'(C)=\T$</td><td>根據定義 1</td></tr>
							<tr><td>因 $\sc{v}_1'(A)=\T&ne;\F$，故 $\sc{v}_1'(&not;A)=\F$</td><td>根據 (1) 和定義 2</td></tr>
							<tr><td>因 $\sc{v}_1'(B)=\T$，故 $\sc{v}_1'(B&or;C)=\T$<span class="note"><span class="box">在這裡，根據定義 4，只要 $\sc{v}_1'(B)=\T$ 和 $\sc{v}_1'(C)=\T$ 任一成立，$\sc{v}_1'(B&or;C)=\T$ 就會成立，故此處只需要判斷 $\sc{v}_1'(B)=\T$，就足以判斷 $\sc{v}_1'(B&or;)=\T$。當然，如果你要用 $\sc{v}_1'(C)=\T$ 來判斷 $\sc{v}_1'(B&or;C)=\T$ 也是可以的。</span></span></td><td>根據 (1) 和定義 4</td></tr>
							<tr><td>因 $\sc{v}_1'(&not;A)=F&ne;\T$，<br/>故 $\sc{v}_1'(&not;A&and;(B&or;C))=\F$</td><td>根據 (2),(3) 和定義 3</td></tr>
						</table>
					因此，我們可以知道，'$&not;A&and;(B&or;C)$' 在 $\sc{v}_1$ 這個語意模型之下為假。
					</p>
					<p>
					我們還可以再換另一個語意模型來測試看看，比如說 $\sc{v}_2$，$\sc{v}_2$ 是讓 '$A$' 為假而其餘原子語句皆為真的語意模型，因此用與之對應的真值函數 $\sc{v}_2'$ 去計算 '$&not;A&and;(B&or;C)$' 的真假時，計算方式如下：
						<table class="prf">
							<tr><td>$\sc{v}_2'(A)=\F$、$\sc{v}_2'(B)=\T$，而且 $\sc{v}_2'(C)=\T$</td><td>根據定義 1</td></tr>
							<tr><td>因 $\sc{v}_2'(A)=\F$，故 $\sc{v}_2'(&not;A)=\T$</td><td>根據 (1) 和定義 2</td></tr>
							<tr><td>因 $\sc{v}_2'(B)=\T$，故 $\sc{v}_2'(B&or;C)=\T$<span class="note"><span class="box">同上，根據定義 4，只要 $\sc{v}_2'(B)=\T$ 和 $\sc{v}_2'(C)=\T$ 任一成立，$\sc{v}_2'(B&or;C)=\T$ 就會成立，故此處只需要判斷 $\sc{v}_2'(B)=\T$，就足以判斷 $\sc{v}_2'(B&or;)=\T$。當然，如果你要用 $\sc{v}_2'(C)=\T$ 來判斷 $\sc{v}_2'(B&or;C)=\T$ 也是可以的。</span></span></td><td>根據 (1) 和定義 4</td></tr>
							<tr><td>因 $\sc{v}_2'(&not;A)=\T$ 且 $\sc{v}_2'(B&or;C)=\T$，<br/>故 $\sc{v}_2'(&not;A&and;(B&or;C))=\T$</td><td>根據 (2),(3) 和定義 3</td></tr>
						</table>
					因此，我們可以知道，'$&not;A&and;(B&or;C)$' 在 $\sc{v}_2$ 這個語意模型之下為真。
					</p>
					<p>
					這些真值函數的功能除了可以讓我們從原子語句的真假來判斷出語句的真假之外，還可以讓我們從語句的真假反推出原子語句的真假。我們一樣拿 '$&not;A&and;(B&or;C)$' 來做例子，假設 '$&not;A&and;(B&or;C)$' 為假，那原子語句的真假是如何分配的呢？
					</p>
					<p>
					一樣，因為這個語句是一個連言句，所以我們要先套用定義 3，得知：
						<ul>
							<li>$\sc{v}_n'(&not;A&and;(B&or;C))=\T$ 當且僅當 $\sc{v}_n'(&not;A)=\sc{v}_n'(B&or;C)=\T$</li>
						</ul>
					由於我們現在要求的是 $\sc{v}_n'(&not;A&and;(B&or;C))=\F$，所以可以加上上述定義得知：
						<ul>
							<li>$\sc{v}_n'(&not;A)=\F$ 或者 $\sc{v}_n'(B&or;C)=\F$</li>
						</ul>
					既然令 '$&not;A&and;(B&or;C)$' 的可能性有兩個，我們就分別來判斷。首先，根據 $\sc{v}_n'(&not;A)=\F$，我們可以利用定義 2 得知：
						<ul>
							<li>$\sc{v}_n'(A)=\T$
						</ul>
					再來，根據 $\sc{v}_n'(B&or;C)=\F$，我們可以利用定義 4 得知：
						<ul>
							<li>$\sc{v}_n'(B)=\F$ 而且 $\sc{v}_n'(C)=\F$</li>
						</ul>
					</p>
					<p>
					我們可以從以上討論得知，要讓 '$&not;A&and;(B&or;C)$' 為假，總共有兩種方法可以做到：(1) 令 '$A$' 為真，只要 '$A$' 為真，無論 '$B$'、'$C$' 的真假是什麼，'$&not;A&and;(B&or;C)$' 都為假；(2) 令 '$B$'、'$C$' 為假，只要 '$B$'、'$C$' 為假，無論 '$A$' 的真假是什麼，'$&not;A&and;(B&or;C)$' 就為假。
					</p>
					<p>
					對應到語意模型的話，我們可以知道：
						<ol class="num local tight">
							<li>對任何語意模型 $\sc{v}_n$，只要 $\sc{v}_n&vDash;A$，則 $\sc{v}_n&nvDash;&not;A&and;(B&or;C)$；而且，</li>
							<li>對任何語意模型 $\sc{v}_n$，只要 $\sc{v}_n&nvDash;B$ 且 $\sc{v}_n&nvDash;C$，則 $\sc{v}_n&nvDash;&not;A&and;(B&or;C)$。</li>
						</ol>
					</p>
					<p>
					由以上討論可知，我們可以用任意一個語意模型定義出一個真值函數，並且使用這個真值函數來判斷語句邏輯中所有語句的真假；除此之外，我們還可以反過來利用真值函數判斷任何語句為真或為假的條件。由於這樣的真值函數可以較快速地做到上述這兩件事，因此能幫助我們有效地去判斷一個推論是不是有效的。下一節我們就會討論如何利用語意模型對應的真值函數來判斷一個論證是不是有效論證。
					</p>
				</div>
			</div>
			
			<h2>語句的邏輯性質與邏輯關係</h2>
			
			<div class="section" id="logical_properties_and_relations_of_sentences">
			
				<h3>語句的邏輯性質</h3>
				
				<div class="subsection" id="logical_properties_of_sentences">
					<p>
					前面說過，對所有語句邏輯中的語句，我們可以根據一個語句所使用的主要連接詞為其做分類；如今，我們要討論的是另一種分類方法，我們要利用語句的邏輯性質來為語句做分類。根據語句的邏輯性質，我們可以將語句邏輯的語句分為三類：<b>恆真句 (tautology)</b>、<b>矛盾句 (self-contradiction)</b>、<b>偶然語句 (contingent sentence)</b>。
					</p>
					
					<h5>恆真句</h5>
					
					<div class="portion" id="tautology">
						<p>
						<b>恆真句</b>如果顧名思義的話，會把它理解成是<b>永恆為真</b>的語句，但恆真句其實和時間的變化沒有任何關係，這是翻譯上的誤區，但已成為主流，故本文亦沿用此譯法。恆真句指的是那些在任何語意模型底下皆為真的語句。換言之，無論一個恆真句所使用到的原子語句的真假如何分派，恆真句都為真。
						</p>
						<p>
						因此，當我們畫一個恆真句的真值表時，其主要連接詞那一行一定會全部為真。舉例來說，'$A&or;&not;A$' 就是一個恆真句，它的真值表如下：
							<table class="truth single">
								<tr><td>$A$</td><td>$A$</td><td>$&or;$</td><td>$&not;A$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
							</table>
						'$A&rarr;(B&rarr;A)$' 也是一個恆真句，其真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$A$</td><td>$&rarr;$</td><td>$(B&rarr;A)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td></tr>
							</table>
						'$(A&rarr;B)&rarr;((A&and;C)&rarr;B)'$ 一樣是一個恆真句，我們也可以試著畫看看這個語句的真值表：
							<table class="truth triple">
								<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A&rarr;B)$</td><td>$&rarr;$</td><td>$((A&and;C)$</td><td>$&rarr;$</td><td>$B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$T$</b></td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td></tr>
							</table>
						</p>
					</div>
					
					<h5>矛盾句</h5>
					
					<div class="portion" id="self-contradiction">
						<p>
						第二種語句類型是矛盾句，不過如果要翻譯得更精確的話，這種語句應該被稱作<b>自我矛盾的語句</b>。矛盾句這一名稱中的「矛盾」一詞，語出《韓非子．難一》篇，說楚國有武器商人在賣盾和矛，先誇其盾牌堅固，任何武器都穿不透，又誇其矛鋒利，任何盾牌都能穿透；於是有路人問他：「若用你的矛刺你的盾會怎樣？」那武器商人便啞口無言。
						</p>
						<p>
						如果他的盾果然沒有武器能穿透，那他的矛就不可能什麼都刺得穿；相反地，設若他的矛果然無堅不摧，那他的盾就不可能任何武器都穿不透。因為武器商人所說的話無論如何都不可能成真，因此<b>矛盾句</b>所指的便是在任何語意模型之下皆為假的語句。換言之，無論一個矛盾句所使用到的原子語句的真假如何分派，矛盾句都為假。
						</p>
						<p>
						因此，當我們畫一個矛盾句的真值表時，其主要連接詞那一行一定會全部為假。舉例來說，'$A&and;&not;A$' 就是一個矛盾句，它的真值表如下：
							<table class="truth single">
								<tr><td>$A$</td><td>$A$</td><td>$&and;$</td><td>$&not;A$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td></tr>
							</table>
							'$&not;(A&rarr;B)&and;&not;(B&rarr;A)$' 也是一個矛盾句，其真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$&not;$</td><td>$(A&rarr;B)$</td><td>$&and;$</td><td>$&not;$</td><td>$(B&rarr;A)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\F$</td><td>$\T$</td></tr>
							</table>
							'$(A&rarr;(B&and;C))&and;(A&and;&not;B)$' 一樣是一個矛盾句，我們也可以試著畫看看這個語句的真值表：
							<table class="truth triple">
								<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A$</td><td>$&rarr;$</td><td>$(B&and;C))$</td><td>$&and;$</td><td>$(A$</td><td>$&and;$</td><td>$&not;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\T$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc2">$\T$</td><td>$\F$</td><td class="mainc"><b>$F$</b></td><td>$\T$</td><td class="mainc2">$\F$</td><td>$\T$</td></tr>
							</table>
						</p>
					</div>
					
					<h5>語言的特性</h5>
					
					<div class="portion" id="linguistic_property">
						<p>
						值得注意的是，根據定義，一個恆真句會在任何語意模型之下皆為真，而一個矛盾句則會在任何語意模型之下皆為假。那麼，考慮到<b>否定號</b>這個一元連接詞的語意特性是：<b>在任何語意模型下，只要一個語句為真，則它的否定句為假，只要一個語句為假，則它的否定句為真</b>。我們就能得知：恆真句的否定會在任何語意模型下皆為假，因此是矛盾句；而矛盾句的否定則會在任何語意模型下皆為真，因此是恆真句。
						</p>
						<p>
						由於恆真句和矛盾句的真值都不會因為語意模型的改變而改變，這意味著無論我們如何調整原子語句的真假，恆真句都會為真，而矛盾句都會為假。而我在前一章說過，我們可以把每一個語意模型都看成是對世界的某一個可能狀態的描述。因此，恆真句和矛盾句的真值不會因為語意模型的改變而改變，就意味著恆真句和矛盾句的真值不是由世界的狀態所決定的。
						</p>
						<p>
						之所以會如此，是因為恆真句與矛盾句的真值完全是由其語句結構來決定的。以 '$A&or;&not;A$' 這個語句來說明，它是一個恆真句，我們可以讓原子語句 '$A$' 代表以下這個中文的原子語句：
							<ol class="lltd tight song">
								<li>安安姓朱。</li>
							</ol>
						而它的否定句 '$&not;A$' 會是以下這個中文語句：
							<ol class="lltpd tight song">
								<li>安安不姓朱。</li>
							</ol>
						那麼 '$A&or;&not;A$' 就會是以下這個中文語句：
							<ol class="lltppd tight song">
								<li>安安姓朱，或者安安不姓朱。</li>
							</ol>
						a'' 這句話看起來像是在談論安安到底姓不姓朱的事情，但其實這句話完全沒有透露關於安安姓什麼的任何資訊。要注意的是，語句之所以可以傳遞任何資訊，不僅是因為我們可以透過意義來理解語句所表達的內容，更重要的是，我們可以透過判斷語句的真假來得到一些關於這個世界的資訊。
						</p>
						<p>
						就以 a 這個語句為例。我們知道 a 這個語句是在表達有個叫「安安」的人，他的姓是「朱」。但如果只是知道這句話的意思，而不知道這句話的真假，我們其實還是不會知道安安到底姓不姓朱，只有當我們知道這句話為真時，才會知道安安確實姓朱，或者當我們知道這句話為假時，才會知道安安不姓朱。
						</p>
						<p>
						然而像 a'' 這樣的語句，即使知道它的真假也不會告訴我們關於安安的任何事，因為 a'' 說的是：「a 和 a' 這兩個句子至少有一個會是真的」，而 a 和 a' 正好是彼此的否定句。給定語句的二值性，一個語句只能是真或是假，因此一個語句及其否定句，定有一個為真。也就是說，根據語言本身的邏輯特性，任何語句和其否定句中定有其一為真，故對任何語句來說，該語句和其否定句所形成的選言句定是真的。
						</p>
						<p>
						同理，給定 '$A$' 代表語句 a，而其否定句 a' 便是 '$&not;A$'，則 '$A&and;&not;A$' 就會代表以下中文語句：
							<ol class="lltpppd tight song">
								<li>安安姓朱，而且安安不姓朱。</li>
							</ol>
						語句 a''' 說的是「a 和 a' 這兩個語句皆為真」，但根據語言的二值性，任何語句不能既真又假，因此語句 a 與其否定句 a' 定不能皆為真。也就是說，根據語言本身的邏輯特性，任何語句和其否定句定不能皆為真，故對任何語句來說，該語句和其否定句所形成的連言句定是假的。
						</p>
						<p>
						以這兩個語句為例，恆真句和矛盾句並未透露任何關於世界的資訊，相對地，恆真句與矛盾句所透露的，其實是關於語言的一些特性。比如 '$A&or;&not;A$' 為恆真句一事，即是透露了任何語句與其否定句之中定有一為真，而 '$A&and;&not;A$' 為矛盾句一事，則透露了任何語句與其否定句定不可皆為真。其它的恆真句與矛盾句也都各自透露一些關於語言的特性，這在我們接觸更多語句之間的邏輯關係後會更清楚。
						</p>
					</div>
					
					<h5>偶然語句</h5>
					
					<div class="portion" id="contingency">
						<p>
						根據前面所說，恆真句和矛盾句並未透露任何關於世界的訊息，而是透露了關於語言本身的邏輯特性。由於世界無論如何改變，我們都是用相同的語言在談論它，因此語言本身（包括其邏輯特性）便不會因世界的改變而改變。那麼，實際上是和語言本身之邏輯特性有關的恆真句與矛盾句，其真假自然不會因為世界的改變而改變。
						</p>
						<p>
						然而，<b>偶然語句</b>則是那些談論世界狀態的語句，因此其真假是會因為世界的改變而改變的。舉例來說，任何一個原子語句一定都是一偶然語句，比如語句 a 這個原子語句，它就會在「<q>安安姓朱</q>」的世界中為真，而在「<q>安安不姓朱</q>」的世界中為假。由於我們用語句邏輯中的 '$A$' 這一原子語句來代表語句 a，故其真值表如下：
							<table class="truth single">
								<tr><td>$A$</td><td>$A$</td></tr>
								<tr><td>$\T$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\F$</td><td class="mainc">$F$</td></tr>
							</table>
						這個真值表的意思是：在任何 '$A$' 為真的世界裡，'$A$' 為真，而在任何 '$A$' 為假的世界裡，'$A$' 為假。
						</p>
						<p>
						這看起來像是一句廢話，但它其實透露了一個重要的訊息，就是 '$A$' 這樣的一個語句既有可能是真的，也有可能是假的，一切都要看我們在談論的是一個怎樣的世界。這就是偶然語句和恆真句與矛盾句之間的重要差異：偶然語句的真假會因世界的改變而改變，恆真句與矛盾句的真假則否。
						</p>
						<p>
						我們可以再看更多的例子，'$A&and;B$' 也是一個偶然語句，其真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$A&and;B$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td></tr>
							</table>
						'$(A&or;B)&rarr;(B&and;C)$' 也是一個偶然語句，其真值表如下：
							<table class="truth triple">
								<tr><td>$A$</td><td>$B$</td><td>$C$</td><td>$(A&or;B)$</td><td>$&rarr;$</td><td>$(B&and;C)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							</table>
						從以上幾個真值表應該不難看得出來，偶然語句的真值表一定有某些列為真，某些列為假，這意味著偶然語句的真假會隨著語意模型的不同而不同。由於每個語意模型都是世界的不同狀態，換言之，偶然語句的真假會隨世界的改變而改變。
						</p>
						<p>
						綜上所述，恆真句在所有語意模型之下皆為真，矛盾句在所有語意模型之下皆為假，而這又是基於這兩類語句的邏輯特性使然，故前者又被稱為<b>邏輯真 (logical truth)</b>，而後者則被稱為<b>邏輯假 (logical falsity)</b>。而偶然語句則是相對於此二者的，它的邏輯性質就是會在某些語意模型下為真，在另一些語意模型下為假。
						</p>
					</div>
				</div>
				
				<h3>語句間的邏輯關係</h5>
				
				<div class="subsection" id="logical_relations_between_sentences">
					<p>
					簡單談過語句的三種邏輯性質，即在所有語意模型下皆真（恆真句之邏輯性質）、在所有語意模型下皆假（矛盾句之邏輯性質）、在某些語意模型下為真而在另一些語意模型下為假（偶然語句之邏輯性質），接下來要介紹的則是語句之間的邏輯關係。
					</p>
					<p>
					語句邏輯中，任兩個語句之間可以存在許多邏輯關係，包括：<b>蘊涵 (entail)</b>、<b>等值 (equivalent)</b>、<b>相容 (compatible)</b>、<b>衝突 (conflict)</b>、<b>矛盾 (contradictory)</b> 和<b>邏輯獨立 (log&shy;i&shy;cally independent)</b> 等關係。不過我們可以將語句間的<b>蘊涵</b>關係視為最基本的一種邏輯關係，因為其它的邏輯關係皆可用蘊涵關係來定義。
					</p>
					
					<h5>蘊涵</h5>
					
					<div class="portion" id="entailment">
						<p>
						之前在介紹語句邏輯中的五個語句連接詞時，我有提過，'$&rarr;$' 這個語句連接詞表達的是兩個語句間的<b>單向</b>蘊涵關係，不過當時所談的蘊涵關係和此處所談的蘊涵關係是兩個不同的概念：'$&rarr;$' 所表達的是兩個語句之間的<b>實質蘊涵</b>關係，而此處所談的則是兩個語句之間的<b>邏輯蘊涵 (logical entailment)</b> 關係，或者，我們也可以稱之為兩個語句之間的<b>語意蘊涵 (semantic entailment)</b> 關係。
						</p>
						<p>
						給定 '$&alpha;$' 和 '$&beta;$' 是語句邏輯中的兩個語句，如果 '$&alpha;$' 邏輯蘊涵 '$&beta;$'，這意味著在 '$&alpha;$' 為真的所有情況下，'$&beta;$' 也都為真。讓我們考慮 '$A&and;B$' 和 '$A&or;B$' 這兩個語句，我們可以將它們的真值表畫在一起如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$A&and;B$</td><td>$A&or;B$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$F$</td></tr>
							</table>
						值得注意的是，為了判斷 '$A&and;B$' 是否蘊涵 '$A&or;B$'，我們需要檢查的是 '$A&and;B$' 為真的所有情況，因此 '$A&and;B$' 為假的情況都可以被忽略。在此真值表中，語句 '$A&and;B$' 為真的情況只有第一列，所以我們需要檢查的情況就只有第一列。而在 '$A&and;B$' 為真的所有情況下，'$A&or;B$' 確實都為真，因此 '$A&and;B$' 蘊涵 '$A&or;B$'。
						</p>
						<p>
						但若要反過來考慮 '$A&or;B$' 是否蘊涵 '$A&and;B$' 的話，我們就要檢查所有 '$A&or;B$' 為真的所有情況，而根據上表，'$A&or;B$' 為真的所有情況包括了第一、二、三列這三種情況，而在這三種情況中，只有在第一列的情況下 '$A&and;B$' 也為真，故 '$A&and;B$' 並沒有在所有 '$A&or;B$' 為真的情況下皆為真，因此 '$A&or;B$' 就不蘊涵 '$A&and;B$'。
						</p>
						<p>
						由以上判斷的結果可知，邏輯蘊涵（或語意蘊涵）關係也是一種單向關係：對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，即使 '$&alpha;$' 邏輯蘊涵 '$&beta;$'，'$&beta;$' 也不見得邏輯蘊涵 '$&alpha;$'。
						</p>
						<p>
						若要用更精確的方法來定義兩個語句之間的蘊涵關係，我們可以這麼說：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 邏輯蘊涵 '$&beta;$'，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中，'$&beta;$' 皆為真。</b>根據以上真值表我們可以看出，對所有語意模型 $\sc{v}_n&vDash;A&and;B$（$n$ 為任意自然數），$\sc{v}_n&vDash;A&or;B$，因此 '$A&and;B$' 邏輯蘊涵 '$A&or;B$'。
						</p>
						<p>
						相反地，對某些語意模型 $\sc{v}_n&vDash;A&or;B$（$n$ 為任意自然數），$\sc{v}_n&nvDash;A&and;B$，比如說，當 $\sc{v}_n&vDash;A$ 但 $\sc{v}_n&nvDash;B$，或者當 $\sc{v}_n&nvDash;A$ 但 $\sc{v}_n&vDash;B$ 時，$\sc{v}_n&vDash;A&or;B$ 但 $\sc{v}_n&nvDash;A&and;B$。因此 '$A&or;B$' 就沒有邏輯蘊涵 '$A&and;B$'。
						</p>
						<p>
						根據上述對邏輯蘊涵關係的定義，只要 'α' 邏輯蘊涵 'β'，則任何能讓 'α' 為真的語意模型都會讓 'β' 為真。因此，當 'α' 邏輯蘊涵 'β' 時，只要我們將這兩個語句用語句連接詞 '$&rarr;$' 連接起來，寫成 '$α&rarr;β$' 的形式，它就會是一個恆真句。
						</p>
						<p>
						我們繼續以 '$A&and;B$' 和 '$A&or;B$' 這兩個語句為例，若用 '$&rarr;$' 將此二語句連接，會形成 '$(A&and;B)&rarr;(A&or;B)$' 這一實質單條件句，而其真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$(A&and;B)$</td><td>$&rarr;$</td><td>$(A&or;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							</table>
						根據上表，'$(A&and;B)&rarr;(A&or;B)$' 確是一恆真句，故 '$A&and;B$' 邏輯蘊涵 '$A&or;B$'。
						</p>
						<p>
						相反地，如果要檢查 '$A&or;B$' 是否邏輯蘊涵 '$A&and;B$'，我們就要將 '$A&or;B$' 寫成實質單條件句的前件，而將 '$A&and;B$' 寫成實質單條件句的後件，也就是說，我們必須檢查 '$(A&or;B)&rarr;(A&and;B)$' 是不是一恆真句。'$(A&or;B)&rarr;(A&and;B)$' 的真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$(A&or;B)$</td><td>$&rarr;$</td><td>$(A&and;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							</table>
						根據上表，'$(A&or;B)&rarr;(A&and;B)$' 並不是一個恆真句，當 '$A$' 為真 '$B$' 為假，或 '$A$' 為假 '$B$' 為真的時候，'$(A&or;B)&rarr;(A&and;B)$' 都不為真，因此 '$(A&or;B)$' 就沒有邏輯蘊涵 '$(A&and;B)$'。
						</p>
						<p>
						根據以上對邏輯蘊涵關係的討論，我們可以發現邏輯蘊涵關係和實質蘊涵關係的差異在於，邏輯蘊涵關係是一種跨語意模型的關係，而實質蘊涵關係則是一種相對於個別語意模型的關係。
						</p>
						<p>
						當我們要檢查兩個語句之間是否存在實質蘊涵關係時，我們一定是在<b>某個語意模型</b>之下檢查這件事：只要某個特定的語意模型不會讓 '$&alpha;$' 為真又讓 '$&beta;$' 為假，在那個語意模型之下 '$&alpha;$' 就實質蘊涵 '$&beta;$'。而 '$&alpha;$' 在某個語意模型之下實質蘊涵 '$&beta;$'，意思其實就是：那個語意模型讓 '$&alpha;&rarr;&beta;$' 為真。
						</p>
						<p>
						相對地，當我們要檢查兩個語句間是否存在邏輯蘊涵關係時，我們要檢查的是兩個語句是否在<b>所有語意模型</b>之下皆有實質蘊涵關係：只要 '$&alpha;$' 在所有語意模型之下皆實質蘊涵 '$&beta;$'，'$&alpha;$' 就會邏輯蘊涵 '$&beta;$'。而「<q>'$&alpha;$' 在所有語意模型之下皆實質蘊涵 '$&beta;$'</q>」其實就是 '$&alpha;&rarr;&beta;$' 在所有語意模型之下皆為真的意思，換言之，'$&alpha;&rarr;&beta;$' 是一恆真句。這就是為什麼我們可以藉由檢查 '$&alpha;&rarr;&beta;$' 是不是恆真句，來檢查 '$&alpha;$' 是否邏輯蘊涵 '$&beta;$'。
						</p>
					</div>
					
					<h5>等值</h5>
					
					<div class="portion" id="equivalence">
						<p>
						緊接在蘊涵關係之後要談的，是<b>等值</b>關係，任兩個語句如果是等值的，就意味著這兩個語句會邏輯蘊涵彼此。所以我們可以將兩個語句間的等值關係定義如下：<b>對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是等值的，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中，'$&beta;$' 皆為真，並且在所有讓 '$&beta;$' 為真的語意模型中，'$&alpha;$' 皆為真。</b>
						</p>
						<p>
						既然等值關係指的是兩個語句彼此相互蘊涵的關係，因此等值關係是一個雙向關係，對任兩個語句 '$&alpha;$' 和 '$&beta;$'，只要 '$&alpha;$' 和 '$&beta;$' 是等值的，'$&beta;$' 和 '$&alpha;$' 也會是等值的。
						</p>
						<p>
						此外，根據等值關係的定義，當 '$&alpha;$' 和 '$&beta;$' 彼此等值的時候，就意味著 '$&alpha;$' 和 '$&beta;$' 的真假一定會在所有情況下都相同。要如何證明這件事呢？
						</p>
						<p>
						首先，假定 '$&alpha;$' 和 '$&beta;$' 是等值的兩個語句，那麼根據定義的前半，在 '$&alpha;$' 為真的所有情況下，'$&beta;$' 都會為真。也就是說，至少在 '$&alpha;$' 為真的那些情況中，'$&alpha;$' 和 '$&beta;$' 的真假會是一樣的（都為真）。因此，如果 '$&alpha;$' 和 '$&beta;$' 的真假有不同，就只能出現在 '$&alpha;$' 不為真的那些情況中。讓我們假設確實在有些情況下 '$&alpha;$' 和 '$&beta;$' 的真假是不同的，那麼在這些情況裡，就一定是 '$&alpha;$' 不為真但 '$&beta;$' 為真的情況。
						</p>
						<p>
						然而，根據等值關係之定義的後半，在 '$&beta;$' 為真的所有情況中，'$&alpha;$' 也都必須為真，因此不可能有那種 '$&beta;$' 為真但 '$&alpha;$' 不為真的情況。然而根據上一段的說明，如果真的在有些情況下 '$&alpha;$' 和 '$&beta;$' 真假是不同的，那麼這些情況一定是 '$&alpha;$' 不為真但 '$&beta;$' 為真的情況。那麼，既然根據等值關係的定義，不可能會有 '$&alpha;$' 不為真但 '$&beta;$' 為真的情況，這就表示不可能會有 '$&alpha;$' 和 '$&beta;$' 的真假不同的情況。
						</p>
						<p>
						故得證：當 '$&alpha;$' 和 '$&beta;$' 彼此等值的時候，'$&alpha;$' 和 '$&beta;$' 的真假一定會在所有情況下都相同。既然如此，我們就可以用真值表來檢查兩個語句是否等值。舉例來說，'$&not;A&or;B$' 和 '$A&rarr;B$' 是彼此等值的兩個語句，我們可以將這兩個語句的真值表畫在一起如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$(&not;A&or;B)$</td><td>$(A&rarr;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">&ensp;$T$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td class="mainc">&ensp;$F$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td class="mainc">&ensp;$T$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">&ensp;$T$</td><td class="mainc">$T$</td></tr>
							</table>
						如上表所示，兩個語句的真假在所有情況下確實都相同，所以 '$&not;A&or;B$' 和 '$A&rarr;B$' 是彼此等值的語句。
						</p>
						<p>
						由於兩個等值的語句之真假在所有情況下都相同，所以當我們將兩個等值的語句以 '$&harr;$' 連接在一起形成一雙條件句後，會得到一個恆真句（因為雙條件句是在前後件同真同假時為真）。因此我們也可以將 '$&not;A&or;B$' 和 '$A&rarr;B$' 以 '$&harr;$' 連接起來，得到一雙條件句 '$(&not;A&or;B)&harr;(A&rarr;B)$'，其真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$(&not;A&or;B)$</td><td>$&harr;$</td><td>$(A&rarr;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>&nbsp;&ensp;$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>&nbsp;&ensp;$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>&nbsp;&ensp;$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>&nbsp;&ensp;$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							</table>
						如表所示，'$(&not;A&or;B)&harr;(A&rarr;B)$' 果然是一恆真句，故可證明 '$&not;A&or;B$' 和 '$A&rarr;B$' 確為彼此等值的兩個語句。
						</p>
						<p>
						值得注意的是，由於兩個彼此等值的語句會在所有情況下都同真同假，所以，只要能夠證明兩個語句是等值的，那麼我們就可以在語句邏輯的脈絡下，將這兩個語句視作意義相同的語句，因此可以在任何情況下替換這兩個語句，並且不會造成任何邏輯意義上的改變。
						</p>
						<p>
						比如說，假定 '$&alpha;$' 和 '$&beta;$' 是彼此等值的兩個語句，當 '$&alpha;$' 出現在某個比較複雜的語句並作為其中的一部分時，例如：'$&delta;&rarr;(&not;&alpha;&and;&gamma;)$'。我們可以用 '$&beta;$' 來替換該語句中的 '$&alpha;$' 得到：'$&delta;&rarr;(&not;&beta;&and;&gamma;)$'。而替換過後的這個新語句，也會和替換前的語句是等值的，也就是說，替換前後的兩個語句的真假會在所有情況下都一樣。
						</p>
						<p>
						基於這個性質，當 '$&alpha;$' 和 '$&beta;$' 彼此等值的時候，'$&alpha;$' 可以推論出來的語句，也都可以用 '$&beta;$' 推論出來，反之亦然；同樣地，當我們可以在任何時候推論出 '$&alpha;$'，我們就可以推論出 '$&beta;$'，反之亦然。至於這個性質有什麼好處，我們會在將來談到推論規則的時候更清楚地體會到。
						</p>
					</div>
					
					<h5>相容</h5>
					
					<div class="portion" id="compatibility">
						<p>
						前面提到，邏輯蘊涵關係是兩個語句之間的一種<b>單向</b>關係，而<b>相容關係</b>則是兩個語句之間的一種<b>雙向</b>關係。也就是說，對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，如果 '$&alpha;$' 相容於 '$&beta;$'，那麼 '$&beta;$' 也會相容於 '$&alpha;$'。也就是說，對任意兩個語句來說，只要這兩個語句是相容於，它們一定是相容於<b>彼此</b>的。
						</p>
						<p>
						對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，如果這兩個語句彼此是相容的，意味著這兩個語句可以同時為真。比如說，一樣考慮 '$A&and;B$' 和 '$A&or;B$' 這兩個語句，我們可以將它們的真值表畫在一起如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$A&and;B$</td><td>$A&or;B$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$F$</td></tr>
							</table>
						從上表可以看出來，真值表的第一列剛好是 '$A&and;B$' 和 '$A&or;B$' 這兩個語句同時為真的情況：當 '$A$' 為真且'$B$' 也為真的時候，'$A&and;B$' 和 '$A&or;B$' 這兩個語句便同時為真，故此二語句是彼此相容的。
						</p>
						<p>
						如果要用更準確的方法來定義兩個語句之間的相容關係，我們可以這麼說：<b>任兩個語句是相容的，當且僅當，至少有一個語意模型使這兩個語句同時為真。</b>而根據上述真值表，我們可以知道，對任何一個語意模型 $\sc{v}_n$（$n$ 是未知數）滿足 $\sc{v}_n&vDash;A$ 和 $\sc{v}_n&vDash;B$ 這兩個條件，則 $\sc{v}_n&vDash;A&and;B$ 而且 $\sc{v}_n&vDash;A&or;B$。
						</p>
						<p>
						因此的確有語意模型可以讓 '$A&and;B$' 與 '$A&or;B$' 同時為真：任何讓 '$A$' 和 '$B$' 這兩個原子語句同時為真的語意模型，都會讓 '$A&and;B$' 與 '$A&or;B$' 同時為真，故此二語句確是相容的。
						</p>
						<p>
						由於兩個彼此相容的語句一定會在某個語意模型之下為真，因此我們可以用真值表來判斷任兩個語句之間是否相容：只要兩個語句是相容的，當我們用 '$&and;$' 將此二語句連接成一連言組時，其真值表就至少有會一列為真。我們繼續以 '$A&and;B$' 和 '$A&or;B$' 這兩個語句為例，將此二語句以 '$&and;$' 連接起來，形成 '$(A&and;B)&and;(A&or;B)$' 這個連言句，其真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$(A&and;B)$</td><td>$&and;$</td><td>$(A&or;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							</table>
						如表所示，'$(A&and;B)&and;(A&or;B)$' 的真值表果然至少有一列（即第一列）為真，因此可以證明 '$A&and;B$' 和 '$A&or;B$' 這兩個語句確實相容。
						</p>
					</div>
					
					<h5>衝突</h5>
					
					<div class="portion" id="conflict">
						<p>
						緊接在相容關係之後要介紹的是兩個語句之間的<b>衝突</b>關係，任兩個語句如果是衝突的，就意味著這兩個語句是不相容的。因此，我們可以將兩個語句的衝突關係定義如下：<b>對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是衝突的，當且僅當，所有語意模型都不會讓 '$&alpha;$' 和 '$&beta;$' 同時為真。</b>
						</p>
						<p>
						舉例來說，考慮 '$&not;A$' 和 '$A&and;B$' 這兩個語句，我們可以將這兩個語句的真值表畫在一起如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$&not;A$</td><td>$A&and;B$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
							</table>
						根據以上真值表所顯示的，'$&not;A$' 和 '$A&and;B$' 這兩個語句在所有可能的情況中都沒有同時為真。也就是說，對所有語意模型 $\sc{v}_n$（$n$ 是任意自然數）而言，$\sc{v}_n&nvDash;&not;A$ 或者 $\sc{v}_n&nvDash;A&and;B$。總之不會有任何一個語意模型讓兩個語句同時為真，故 '$&not;A$' 和 '$A&and;B$' 是衝突的。
						</p>
						<p>
						衝突關係除了可以用相容關係來定義（兩個不相容的語句就是衝突的語句）以外，其實也可以用蘊涵關係來定義。衝突關係的定義說：對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是衝突的，當且僅當，所有語意模型都不會讓 '$&alpha;$' 和 '$&beta;$' 同時為真。而「<q>所有語意模型都不會讓 '$&alpha;$' 和 '$&beta;$' 同時為真</q>」的意思其實就是「<q>所有語意模型都會讓 '$&alpha;$' 為假，或者讓 '$&beta;$' 為假</q>」。
						</p>
						<p>
						根據語句的二值性，我們可以知道，當一個語意模型讓 '$&alpha;$' 為假，其實就是讓 '$&not;&alpha;$' 為真；當一個語意模型讓 '$&beta;$' 為假，其實就是讓 '$&not;&beta;$' 為真。因此，「<q>所有語意模型都會讓 '$&alpha;$' 為假，或者讓 '$&beta;$' 為假</q>」就可以被理解為：
							<ul class="disc song tight">
								<li>所有語意模型都會讓 '$&alpha;$' 為假，或者讓 '$&not;&beta;$' 為真；以及，</li>
								<li>所有語意模型都會讓 '$&beta;$' 為假，或者讓 '$&not;&alpha;$' 為真。</li>
							</ul>
						然後，參考我們在第二章裡用語意模型，或者在第三章中用真值函數來定義實質單條件句的真值表的方法，就會發現上述兩個說法又可以被進一步理解為：
							<ul class="disc song tight">
								<li>所有語意模型都會讓 '$&alpha;&rarr;&not;&beta;$' 為真；以及，</li>
								<li>所有語意模型都會讓 '$&beta;&rarr;&not;&alpha;$' 為真。</li>
							</ul>
						而這兩個說法其實就是在說：
							<ul class="disc song tight">
								<li>'$&alpha;&rarr;&not;&beta;$' 為一恆真句；以及，</li>
								<li>'$&beta;&rarr;&not;&alpha;$' 為一恆真句。</li>
							</ul>
						接著，根據我們先前對邏輯蘊涵關係的定義，我們可以將上述兩個說法再進一步地理解為：
							<ul class="disc song tight">
								<li>'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'；以及，</li>
								<li>'$&beta;$' 邏輯蘊涵 '$&not;&alpha;$'。</li>
							</ul>
						因此，我們可以將衝突關係的定義重新改寫為：<b>對任兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 是衝突的，當且僅當，'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'。</b><span class="note"><span class="box">或者也可以說是 '$&beta;$' 邏輯蘊涵 '$&not;&alpha;$'，兩個說法的意思是相同的。</span></span>換言之，任意兩個語句是衝突的，當且僅當，兩個語句會互相蘊涵彼此的否定句。
						</p>
						<p>
						反過來說，由於衝突的語句就是互不相容的語句，所以相容的語句其實就是互不衝突的語句。因此，我們也可以用邏輯蘊涵關係來定義相容關係：<b>任意兩個語句是相容的，當且僅當，這兩個語句都不會邏輯蘊涵彼此的否定句。</b>
						</p>
						<p>
						由於兩個彼此衝突的語句不會同時為真，因此當我們以 '$&and;$' 來連接兩個彼此衝突的語句時，所得的連言句就會是一矛盾句。以 '$&not;A$' 和 '$A&and;B$' 這兩個語句為例，將它們以 '$&and;$' 連接起來所形成的連言句之真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$&not;A$</td><td>$&and;$</td><td>$(A&and;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$F$</td><td>$\T$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td>$F$</td><td>$\F$</td></tr>
							</table>
						依上表所示，用 '$&and;$' 連接 '$&not;A$' 和 '$A&and;B$' 所形成之連言句 '$&not;A&and;(A&and;B)$' 確實為一矛盾句，故 '$&not;A$' 和 '$A&and;B$' 彼此衝突。
						</p>
					</div>
					
					<h5>矛盾</h5>
					
					<div class="portion" id="contradiction">
						<p>
						在談語句的邏輯性質時，我們有介紹到一種語句類型叫做<b>矛盾句</b>，而此處要介紹的<b>矛盾 (contradictory) 關係</b>則是存在於兩個語句之間的邏輯關係。兩者雖然名稱幾乎一樣，而且也確實有千絲萬縷的關係，但仍是不同的概念，要注意區分，避免混淆。
						</p>
						<p>
						矛盾關係也是一種雙向關係，也就是說，對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，如果 '$&alpha;$' 和 '$&beta;$' 是矛盾的，則 '$&beta;$' 和 '$&alpha;$' 也是矛盾的。當兩個語句彼此矛盾時，就意味著這兩個語句既不會同時為真，也不會同時為假。換言之，當 '$&alpha;$' 和 '$&beta;$' 彼此矛盾時，只要 '$&alpha;$' 為真，'$&beta;$' 就會為假，並且，只要 '$&alpha;$' 為假，'$&beta;$' 就會為真。
						</p>
						<p>
						考慮一組最典型的矛盾句：'$A$' 和 '$&not;A$'，我們可以將這兩個語句的真值表畫在一起如下表：
							<table class="single truth">
								<tr><td>$A$</td><td>$A$</td><td>$&not;A$</td></tr>
								<tr><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\F$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
							</table>
						從上表可以清楚地看出來，由於 '$&not;A$' 是 '$A$' 的否定句，故當 '$A$' 為真時，'$&not;A$' 就為假；反之當 '$A$' 為假時，'$&not;A$' 就為真。故此二語句確實彼此矛盾。
						</p>
						<p>
						若要用更精確的方法來定義兩個語句之間的矛盾關係，我們可以這麼說：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 彼此矛盾，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中 '$&beta;$' 皆為假，而且在所有讓 '$&alpha;$' 為假的語意模型中 '$&beta;$' 皆為真。</b>根據以上真值表我們可以看出，對所有語意模型 $\sc{v}_n&vDash;A$（$n$ 為任意自然數），$\sc{v}_n&nvDash;&not;A$，而且對所有語意模型 $\sc{v}_n&nvDash;A$，$\sc{v}_n&vDash;&not;A$。因此 '$A$' 和 '$&not;A$' 是彼此矛盾的語句。
						</p>
						<p>
						值得注意的是，在定義兩個語句間的矛盾關係時，我們用到了「<q>在所有讓 '$α$' 為真的語意模型中 '$β$' 皆為假</q>」和「<q>在所有讓 '$α$' 為假的語意模型中 '$β$' 皆為真</q>」這兩個說法，而這兩個說法正好和邏輯蘊涵關係的定義是一致的，也就是說，我們其實可以用邏輯蘊涵關係來定義矛盾關係。
						</p>
						<p>
						首先，根據語句的二值性，當 '$&beta;$' 為假時，'$&not;&beta;$' 為真，而當 '$&alpha;$' 為假時，'$&not;&alpha;$' 為真，因此我們可以將矛盾關係的定義重新寫成：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 彼此矛盾，當且僅當，在所有讓 '$&alpha;$' 為真的語意模型中 '$&not;&beta;$' 皆為真，而且在所有讓 '$&not;&alpha;$' 為真的語意模型中 '$&beta;$' 皆為真。</b>
						</p>
						<p>
						接著，根據邏輯蘊涵關係的定義，對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，在所有讓 '$&alpha;$' 為真的語意模型中 '$&not;&beta;$' 皆為真，就意味著 '$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'；而在所有讓 '$&not;&alpha;$' 為真的語意模型中 '$&beta;$' 皆為真，則意味著 '$&not;&alpha;$' 邏輯蘊涵 '$&beta;$'。因此，我們可以將矛盾關係的定義進一步改寫如下：<b>對任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;$' 和 '$&beta;$' 彼此矛盾，當且僅當，'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$'，而且 '$&not;&alpha;$' 邏輯蘊涵 '$&beta;$'。</b><span class="note"><span class="box">同理，'$&alpha;$' 邏輯蘊涵 '$&not;&beta;$' 就意味著 '$&beta;$' 邏輯蘊涵 '$&not;&alpha;$'；而 '$&not;&alpha;$' 邏輯蘊涵 '$&beta;$' 也意味著  '$&not;&beta;$' 邏輯蘊涵 '$&alpha;$'</span></span>
						</p>
						<p>
						也就是說，對任意兩個語句來說，只要這兩個語句會相互蘊涵彼此的否定句，而且這兩個語句都會被彼此的否定句蘊涵，則這兩個語句就是彼此矛盾的語句。
						</p>
						<p>
						若比較矛盾關係和衝突關係的定義可以發現，衝突關係只要求兩個語句要蘊涵彼此的否定句，而未要求兩個語句也要被彼此的否定句蘊涵，因此矛盾關係成立的條件比衝突關係還要更嚴格。也就是說，當兩個語句彼此矛盾時，這兩個語句一定是彼此衝突的，但反之則不一定。
						</p>
						<p>
						以之前在談衝突關係時用到的語句 '$&not;A$' 和 '$A&and;B$' 為例，固然在 '$&not;A$' 為真的所有情況下，'$A&and;B$' 都為假，而且在 '$A&and;B$' 為真的所有情況下，'$&not;A$' 也都為假，因此這兩個語句確實不會同時為真，故彼此衝突。但注意，當 '$A$' 為真而 '$B$' 為假時，'$&not;A$' 和 '$A&and;B$' 卻同時為假，因此這兩個語句可以同時為假，故彼此並不矛盾。
						</p>
						<p>
						由於兩個矛盾的語句會彼此蘊涵對方的否定句，同時也會被對方的否定句給蘊涵，這意味著，當 '$&alpha;$' 與 '$&beta;$' 彼此矛盾時，我們若以 '$&rarr;$' 來連接其中一個語句和另一個語句的否定句，例如 '$&alpha;$' 和 '$&not;&beta;$'（當然，'$&beta;$' 和 '$&not;&alpha;$' 也可以），形成的實質單條件句 '$&alpha;&rarr;&not;&beta;$' 會是恆真句；並且，將該實質單條件句的前後件對調所形成的語句 '$&not;&beta;&rarr;&alpha;$' 也會是恆真句。
						</p>
						<p>
						若將 '$&alpha;&rarr;&not;&beta;$' 和 '$&not;&beta;&rarr;&alpha;$' 這兩個單條件句合在一起，就會得到 '$&alpha;&harr;&not;&beta;$' 這一雙條件句，因此，當兩個語句 '$&alpha;$' 和 '$&beta;$' 彼此矛盾時，只要將其中一語句和另一個語句的否定句以 '$&harr;$' 連在一起，所形成的雙條件句（'$&alpha;&harr;&not;&beta;$' 或 '$&beta;&harr;&not;&alpha;$'）就會是恆真句。以 '$A$' 和 '$&not;A$' 這兩個語句為例，將 '$A$' 和 '$&not;A$' 的否定句 '$&not;&not;A$' 以 '$&harr;$' 連在一起，會得到 '$A&harr;&not;&not;A$'，其真值表如下：
							<table class="single truth">
								<tr><td>$A$</td><td>$A$</td><td>$&harr;$</td><td>$&not;$</td><td>$(&not;A)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td><td>$\T$</td></tr>
							</table>
						依上表所示，'$A&harr;&not;&not;A$' 果然是恆真句，故可證 '$A$' 與 '$&not;A$' 確實彼此矛盾。或者，我們也可以用 '$&harr;$' 連接 '$A$' 的否定句和 '$&not;A$' 這兩個語句，得到 '$&not;A&harr;&not;A$'，其真值表如下：
							<table class="single truth">
								<tr><td>$A$</td><td>$&not;A$</td><td>$&harr;$</td><td>$&not;A$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
							</table>
						依上表所示，'$&not;A&harr;&not;A$' 果然也是一恆真句，故亦得證 '$A$' 和 '$&not;A$' 彼此矛盾。
						</p>
						<p>
						為了加深讀者的印象，我再舉一組矛盾的語句為例：'$A&or;&not;B$' 與 '$&not;A&and;B$' 也是一組彼此矛盾的語句，我們可以將此二語句的真值表畫在一起如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$A&or;&not;B$</td><td>$&not;A&and;B$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td class="mainc">$T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$T$</td><td class="mainc">$F$</td></tr>
							</table>
						依上表所示，在 '$A&or;&not;B$' 為真的所有情況中（也就是真值表的第一、二、四列），'$&not;A&and;B$' 都為假，而且在 '$&not;A&and;B$' 為真的所有情況中（也就是真值表的第三列），'$A&or;&not;B$' 也確實都為假，因此這兩個語句確實彼此矛盾。
						</p>
						<p>
						除此以外，我們也可以用雙條件句的方式來檢查這兩個語句是否彼此矛盾，我們可以選擇用 '$A&or;&not;B$' 和 '$&not;A&and;B$' 的否定句（也就是 '$&not;(&not;A&and;B)$'）來形成雙條件句，也可以選擇用 '$A&or;&not;B$' 的否定句（即 '$&not;(A&or;&not;B)$'）和 '$&not;A&and;B$' 來形成雙條件句。只要 '$A&or;&not;B$' 與 '$&not;A&and;B$' 確實彼此矛盾，則前述兩個雙條件句一定都會是恆真句。我們分別以真值表檢查：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$(A&or;&not;B)$</td><td>$&harr;$</td><td>$&not;$</td><td>$(&not;A&and;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\F$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\T$</td><td>$\F$</td></tr>
							</table>
						如上表，當我們以 '$&harr;$' 連接 '$A&or;&not;B$' 和 '$&not;A&and;B$' 的否定句（即 '$&not;(&not;A&and;B)$'），得到的雙條件句 '$(A&or;&not;B)&harr;&not;(&not;A&and;B)$' 確實是恆真句。我們也可以用 '$&harr;$' 來連接 '$A&or;&not;B$' 的否定句（即 '$&not;(A&or;&not;B)$'）和 '$&not;A&and;B$' 得到 '$&not;(A&or;&not;B)&harr;(&not;A&and;B)$' 這一雙條件句，並以真值表檢查它是否為恆真句：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$&not;$</td><td>$(A&or;&not;B)$</td><td>$&harr;$</td><td>$(&not;A&and;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$T$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$T$</td><td>$\F$</td></tr>
							</table>
						依上表所示，'$&not;(A&or;&not;B)&harr;(&not;A&and;B)$' 果然也是一恆真句，故亦可證 '$A&or;&not;B$' 和 '$&not;A&and;B$' 彼此矛盾。
						</p>
						<p>
						要注意的是，當我們要檢查兩個語句 '$&alpha;$' 和 '$&beta;$' 是否彼此矛盾時，只要在 '$&alpha;&harr;&not;&beta;$' 和 '$&not;&alpha;&harr;&beta;$' 之間選擇一個來檢查即可，這是因為對於任意兩個語句 '$&alpha;$' 和 '$&beta;$' 而言，'$&alpha;&harr;&not;&beta;$' 和 '$&not;&alpha;&harr;&beta;$' 會是<b>等值</b>的兩個語句，因此檢查其中的一個就等於檢查了另一個。我在上面之所以分別都檢查一遍，只是為了不要有所遺漏而已。
						</p>
						<p>
						此外，根據矛盾關係的定義，當兩個語句 '$&alpha;$' 和 '$&beta;$' 彼此矛盾時，這兩個語句的真假在所有情況下一定都不相同，因此當我們用 '$&harr;$' 來連接 '$&alpha;$' 和 '$&beta;$' 這兩個語句時，得到的雙條件句一定會是一個矛盾句。這是因為根據雙條件句的真值表，只要雙條件句的前後件真假不同，雙條件句就為假。因此我們也可以用這個方法來檢查兩個語句是否彼此矛盾。
						</p>
						<p>
						比如說，我們可以將 '$A$' 和 '$&not;A$' 用 '$&harr;$' 連接起來形成 '$A&harr;&not;A$'，並檢查其真值表如下：
							<table class="single truth">
								<tr><td>$A$</td><td>$A$</td><td>$&harr;$</td><td>$&not;A$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
							</table>
						如表所示，'$A&harr;&not;A$' 果為一矛盾句，因此 '$A$' 和 '$&not;A$' 彼此矛盾。
						</p>
						<p>
						又比如說，我們可以將 '$A&or;&not;B$' 和 '$&not;A&and;B$' 用 '$&harr;$' 連接起來，形成以下雙條件句： '$(A&or;&not;B)&harr;(&not;A&and;B)$'，並檢查其真值表如下：
							<table class="truth double">
								<tr><td>$A$</td><td>$B$</td><td>$(A&or;&not;B)$</td><td>$&harr;$</td><td>$(&not;A&and;B)$</td></tr>
								<tr><td>$\T$</td><td>$\T$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\T$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
								<tr><td>$\F$</td><td>$\T$</td><td>$\F$</td><td class="mainc">$F$</td><td>$\T$</td></tr>
								<tr><td>$\F$</td><td>$\F$</td><td>$\T$</td><td class="mainc">$F$</td><td>$\F$</td></tr>
							</table>
						如果所示，'$(A&or;&not;B)&harr;(&not;A&and;B)$' 確為一矛盾句，故可證 '$A&or;&not;B$' 和 '$&not;A&and;B$' 為彼此矛盾的語句。
						</p>
					</div>
				</div>
			</div>
		</div>
	</div>
	<script src="https://isaacstn.github.io/script/jquery-3.5.0.min.js"></script>
	<script src="https://isaacstn.github.io/script/jqmath-etc-0.4.6.min.js"></script>
	<script src="note.bubble.v1.1.js"></script>
</body>
